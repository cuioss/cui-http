= HTTP Client Extension Documentation
:toc: left
:toc-title: Table of Contents
:toclevels: 3
:sectnums:
:source-highlighter: highlight.js

[IMPORTANT]
====
**Breaking Change Policy - Pre-1.0 Project**

This is a pre-1.0 project. Breaking changes are acceptable and expected.

This plan will **replace** the existing `ResilientHttpHandler` implementation entirely, not deprecate or refactor it. The old implementation will be removed.

All dependent projects (e.g., cui-jwt) must migrate before the 1.0 release.
====

== Navigation

=== Architecture & Design

. link:02-proposed-architecture.adoc[Architecture] - Design patterns and layers
. link:03-core-components.adoc[Components] - Interface specifications
. link:04-etag-aware-adapter.adoc[ETag Adapter] - Base adapter with caching
. link:05-resilient-adapter.adoc[Resilient Adapter] - Non-blocking async retry with exponential backoff

=== Usage & Examples

. link:07-usage-examples.adoc[Usage Examples] - 24 complete examples
. link:09-security-considerations.adoc[Security] - Best practices

NOTE: Document 08 is reserved for future testing guidelines. Current test requirements are documented in link:06-implementation-plan.adoc[Implementation Plan].

== Architecture

[source]
----
Client Code
    ↓ calls
HttpAdapter.get() → CompletableFuture<HttpResult<T>>
    ↓ delegates to (if wrapped)
ResilientHttpAdapter (optional async retry with exponential backoff)
    ↓ delegates to (returns CompletableFuture)
ETagAwareHttpAdapter (base adapter + ETag caching)
    ↓ uses (returns CompletableFuture)
HttpHandler (SSL, timeouts, connection pooling)
    ↓ calls (async)
java.net.http.HttpClient.sendAsync()
    ↓ returns
CompletableFuture<HttpResponse<String>>

All layers are non-blocking - zero threads blocked during I/O or retries
----

== Terminology

Understanding the distinction between **Handler** and **Adapter**:

[cols="1,3"]
|===
|Term |Definition

|**HttpHandler**
|Low-level HTTP execution component. Configures SSL/TLS context, timeouts, connection pooling, and provides `HttpRequest.Builder`. Wraps `java.net.http.HttpClient`.

|**HttpAdapter**
|High-level typed operations interface. Provides method-specific API (`get()`, `post()`, etc.) returning `CompletableFuture<HttpResult<T>>`. Handles request/response conversion, error handling, and async execution.

|**ETagAwareHttpAdapter**
|Base adapter implementation with built-in ETag caching. Adds conditional requests (If-None-Match) and 304 handling.

|**ResilientHttpAdapter**
|Decorator adapter that adds retry logic with exponential backoff. Wraps any `HttpAdapter` to add resilience.
|===

**Conceptual Layers:**

* **Handler** = Configuration + Low-level HTTP mechanics
* **Adapter** = Business logic + Type safety + HTTP method semantics
* **Decorator** = Cross-cutting concerns (caching, retry, auth, validation)

**Example:**

[source,java]
----
// Handler: Low-level HTTP configuration
HttpHandler handler = HttpHandler.builder()
    .uri("https://api.example.com")
    .connectionTimeoutSeconds(5)
    .build();

// Adapter: High-level typed operations
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)  // Uses handler for actual HTTP calls
    .responseConverter(userConverter)
    .build();

// Use adapter for business operations
CompletableFuture<HttpResult<User>> future = adapter.get();
----

== Key Decisions

[cols="1,2"]
|===
|Decision |Choice

|HTTP Methods |Method-specific API (`adapter.get()`, `adapter.post()`, etc.)
|ETag Caching |Built into `ETagAwareHttpAdapter` (default enabled, configurable)
|Retry Logic |`ResilientHttpAdapter` with `RetryConfig` - non-blocking async with exponential backoff
|Content Conversion |Separate `HttpResponseConverter<T>` and `HttpRequestConverter<R>` interfaces
|Content Types |`ContentType` enum
|Async First |All operations return `CompletableFuture<HttpResult<T>>` - zero blocked threads
|Blocking Convenience |`*Blocking()` methods available for simple synchronous use cases
|===

== Quick Examples

=== GET Request (Async)

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .build();

// Async execution
CompletableFuture<HttpResult<User>> futureResult = adapter.get();

// Handle asynchronously (recommended)
futureResult.thenAccept(result -> {
    if (result.isSuccess()) {
        processUser(result.getContent().orElseThrow());
    }
});

// Or blocking for simple cases
HttpResult<User> result = adapter.getBlocking();
----

=== POST with JSON

[source,java]
----
User newUser = User.builder().name("John").email("john@example.com").build();

// Async
CompletableFuture<HttpResult<User>> futureResult = adapter.post(newUser);

// Or blocking
HttpResult<User> result = adapter.postBlocking(newUser);
----

=== With Retry

[source,java]
----
HttpAdapter<User> resilient = ResilientHttpAdapter.wrap(baseAdapter);

// Async execution with retry - returns CompletableFuture
CompletableFuture<HttpResult<User>> future = resilient.get();

// Handle asynchronously (recommended)
future.thenAccept(result -> {
    if (result.isSuccess()) {
        processUser(result.getContent().orElseThrow());
    }
});

// Or blocking
HttpResult<User> result = resilient.getBlocking();
----

=== Single-User Client (No Token Bloat)

**⚠️ IMPORTANT:** If your application uses authentication tokens (e.g., `Authorization: Bearer <token>`) that refresh periodically, the default `CacheKeyHeaderFilter.ALL` will create cache bloat because each new token creates a new cache entry for the same resource.

[source,java]
----
// Single-user scenarios: Mobile app, desktop app, or service account
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    // Recommended: Exclude auth headers while keeping content-affecting headers
    .cacheKeyHeaderFilter(CacheKeyHeaderFilter.excluding("Authorization"))
    .build();

// Alternative for simple single-user cases (ignores all headers):
// .cacheKeyHeaderFilter(CacheKeyHeaderFilter.NONE)

// Token refresh doesn't create duplicate cache entries
----

== Adapter Composition

Adapters can be composed by wrapping to add cross-cutting concerns. Custom decorators can be implemented by wrapping the `HttpAdapter` interface:

[source,java]
----
// Example: Compose retry with base adapter
HttpAdapter<User> baseAdapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .build();

HttpAdapter<User> resilient = ResilientHttpAdapter.wrap(baseAdapter);

// Custom decorators can be implemented by wrapping HttpAdapter
// Example pattern for custom decorator:
class CustomDecorator<T> implements HttpAdapter<T> {
    private final HttpAdapter<T> delegate;

    CustomDecorator(HttpAdapter<T> delegate) {
        this.delegate = delegate;
    }

    @Override
    public CompletableFuture<HttpResult<T>> get(Map<String, String> headers) {
        // Add custom logic before/after delegation
        return delegate.get(headers);
    }
    // ... implement other methods ...
}
----

**Rule:** Composition order matters - place stable concerns outside, variable concerns inside.

== 304 Not Modified Handling

The adapter uses a safe request flow pattern: cache entry retrieved at request start, reference held throughout. This guarantees:

* 304 response returns `Success` with cached content
* Thread-safe: local reference immune to concurrent cache modifications
* Safe by design: 304 can only occur when cache entry exists

See link:04-etag-aware-adapter.adoc#_304_not_modified_handling_pattern[304 Implementation]

== Documents

[cols="1,2"]
|===
|Document |Content

|README |This file - navigation and quick reference
|01-current-architecture |Analysis of existing architecture and integration points
|02-proposed-architecture |Design patterns, async architecture, and data flows
|03-core-components |`HttpAdapter<T>` interface with async-first design
|04-etag-aware-adapter |Base adapter implementation with ETag caching
|05-resilient-adapter |Non-blocking retry with exponential backoff and `CompletableFuture`
|06-implementation-plan |Step-by-step implementation roadmap and test requirements
|07-usage-examples |24 complete code examples (async and blocking patterns)
|08-testing-guidelines |_Reserved for future testing guidelines_
|09-security-considerations |Security best practices
|===
