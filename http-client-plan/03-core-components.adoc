= Core Components Specification
:toc: left
:toc-title: Table of Contents
:toclevels: 3
:sectnums:
:source-highlighter: highlight.js

== Overview

This document provides complete specifications for all core components introduced in the HTTP method extension.

== CacheKeyHeaderFilter Interface

*Package:* `de.cuioss.http.client.adapter`

*Purpose:* Fine-grained control over which HTTP headers are included in ETag cache keys using functional predicates.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client.adapter;

import java.util.Set;
import java.util.function.Predicate;

/**
 * Strategy for determining which HTTP headers should be included in cache keys.
 *
 * <p>Headers included in cache keys create separate cache entries per header
 * combination. Headers excluded from cache keys allow cache sharing across
 * different header values.
 *
 * <p>This functional interface allows fine-grained control beyond simple all-or-nothing
 * choices, solving the token refresh cache bloat problem while maintaining security.
 *
 * @since 1.0
 */
@FunctionalInterface
public interface CacheKeyHeaderFilter {

    /**
     * Determines if the given header should be included in the cache key.
     *
     * @param headerName The HTTP header name (case-insensitive)
     * @return true if header should be included in cache key, false otherwise
     */
    boolean includeInCacheKey(String headerName);

    // ========== PRESET FILTERS ==========

    /**
     * Include all headers in cache key (default, safest).
     *
     * <p><b>Use when:</b>
     * <ul>
     *   <li>Adapter is shared across multiple users</li>
     *   <li>Headers affect response content</li>
     *   <li>Defense-in-depth against server ETag bugs</li>
     * </ul>
     *
     * <p><b>Trade-off:</b> Token refresh creates cache bloat
     */
    CacheKeyHeaderFilter ALL = header -> true;

    /**
     * Exclude all headers from cache key (URI only).
     *
     * <p><b>Use ONLY when:</b>
     * <ul>
     *   <li>Single-user client (not shared)</li>
     *   <li>Server implements user-aware ETags</li>
     * </ul>
     *
     * <p><b>Risk:</b> Multi-user scenarios may cache wrong content
     */
    CacheKeyHeaderFilter NONE = header -> false;

    // ========== FACTORY METHODS ==========

    /**
     * Exclude specific headers from cache key, include all others.
     *
     * <p><b>Solves token refresh cache bloat</b> by excluding Authorization
     * while keeping content-affecting headers like Accept-Language.
     *
     * <p>Example:
     * <pre>{@code
     * // Exclude frequently-changing headers, include others
     * .cacheKeyHeaderFilter(CacheKeyHeaderFilter.excluding(
     *     "Authorization", "X-Request-ID", "X-Trace-ID"
     * ))
     * }</pre>
     *
     * @param headerNames Case-insensitive header names to exclude
     * @return Filter that includes all headers except specified ones
     */
    static CacheKeyHeaderFilter excluding(String... headerNames) {
        Set<String> excluded = Set.of(headerNames).stream()
            .map(String::toLowerCase)
            .collect(java.util.stream.Collectors.toSet());
        return header -> !excluded.contains(header.toLowerCase());
    }

    /**
     * Include only specific headers in cache key, exclude all others.
     *
     * <p><b>Whitelist approach</b> for precise control over cache key composition.
     *
     * <p>Example:
     * <pre>{@code
     * // Include only content-affecting headers
     * .cacheKeyHeaderFilter(CacheKeyHeaderFilter.including(
     *     "Accept-Language", "Accept-Encoding"
     * ))
     * }</pre>
     *
     * @param headerNames Case-insensitive header names to include
     * @return Filter that includes only specified headers
     */
    static CacheKeyHeaderFilter including(String... headerNames) {
        Set<String> included = Set.of(headerNames).stream()
            .map(String::toLowerCase)
            .collect(java.util.stream.Collectors.toSet());
        return header -> included.contains(header.toLowerCase());
    }

    /**
     * Exclude headers matching a prefix (case-insensitive).
     *
     * <p>Example:
     * <pre>{@code
     * // Exclude all X- headers (trace IDs, custom headers)
     * .cacheKeyHeaderFilter(CacheKeyHeaderFilter.excludingPrefix("X-"))
     * }</pre>
     *
     * @param prefix Case-insensitive prefix to match
     * @return Filter that excludes headers starting with prefix
     */
    static CacheKeyHeaderFilter excludingPrefix(String prefix) {
        String lowerPrefix = prefix.toLowerCase();
        return header -> !header.toLowerCase().startsWith(lowerPrefix);
    }

    /**
     * Custom predicate-based filter for complex logic.
     *
     * <p>Example:
     * <pre>{@code
     * .cacheKeyHeaderFilter(CacheKeyHeaderFilter.matching(
     *     header -> !header.startsWith("X-") && !header.equals("Authorization")
     * ))
     * }</pre>
     *
     * @param predicate Custom header inclusion logic
     * @return Filter using the predicate
     */
    static CacheKeyHeaderFilter matching(Predicate<String> predicate) {
        return predicate::test;
    }

    // ========== COMPOSITION ==========

    /**
     * Combines this filter with another using logical AND.
     * Header is included only if both filters return true.
     *
     * <p>Example:
     * <pre>{@code
     * CacheKeyHeaderFilter filter = CacheKeyHeaderFilter
     *     .excluding("Authorization")
     *     .and(CacheKeyHeaderFilter.excludingPrefix("X-"));
     * }</pre>
     */
    default CacheKeyHeaderFilter and(CacheKeyHeaderFilter other) {
        return header -> this.includeInCacheKey(header) && other.includeInCacheKey(header);
    }

    /**
     * Combines this filter with another using logical OR.
     * Header is included if either filter returns true.
     */
    default CacheKeyHeaderFilter or(CacheKeyHeaderFilter other) {
        return header -> this.includeInCacheKey(header) || other.includeInCacheKey(header);
    }

    /**
     * Negates this filter.
     *
     * <p>Example:
     * <pre>{@code
     * // Include all EXCEPT Accept-Language
     * CacheKeyHeaderFilter.including("Accept-Language").negate()
     * }</pre>
     */
    default CacheKeyHeaderFilter negate() {
        return header -> !this.includeInCacheKey(header);
    }
}
----

=== Common Use Cases

[cols="2,3,2"]
|===
|Scenario |Filter Configuration |Rationale

|Multi-user web server (default)
|`CacheKeyHeaderFilter.ALL`
|Safe: separate cache per user

|Single-user mobile app
|`CacheKeyHeaderFilter.NONE`
|No token refresh cache bloat

|Token refresh cache bloat fix
|`CacheKeyHeaderFilter.excluding("Authorization")`
|**Best of both worlds**: keeps Accept-Language, excludes Auth

|Service account
|`CacheKeyHeaderFilter.NONE`
|Token rarely changes

|Content negotiation only
|`CacheKeyHeaderFilter.including("Accept-Language", "Accept-Encoding")`
|Precise control over cache keys

|Exclude debug/trace headers
|`CacheKeyHeaderFilter.excludingPrefix("X-")`
|Clean cache keys without noise

|Multi-tenant SaaS
|`CacheKeyHeaderFilter.ALL`
|Defense against cross-tenant leakage

|Complex requirements
|`CacheKeyHeaderFilter.matching(header -> ...)`
|Full custom logic
|===

=== Usage Examples

==== Example 1: Solve Token Refresh Cache Bloat

[source,java]
----
// Problem: ALL causes cache bloat on token refresh
// Solution: Exclude Authorization, keep content-affecting headers
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .cacheKeyHeaderFilter(CacheKeyHeaderFilter.excluding("Authorization"))
    .build();

// Now:
// - Accept-Language IS included → separate cache per language ✓
// - Authorization NOT included → token refresh doesn't bloat cache ✓
----

==== Example 2: Exclude All Trace Headers

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .cacheKeyHeaderFilter(
        CacheKeyHeaderFilter.excludingPrefix("X-")
            .and(CacheKeyHeaderFilter.excluding("Authorization"))
    )
    .build();
----

==== Example 3: Whitelist Content Headers Only

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .cacheKeyHeaderFilter(CacheKeyHeaderFilter.including(
        "Accept-Language",
        "Accept-Encoding",
        "Accept-Charset"
    ))
    .build();
----

==== Example 4: Custom Logic

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .cacheKeyHeaderFilter(CacheKeyHeaderFilter.matching(header -> {
        // Include Accept-* headers
        if (header.startsWith("Accept-")) return true;
        // Exclude auth and trace headers
        if (header.equals("Authorization")) return false;
        if (header.startsWith("X-")) return false;
        // Include everything else
        return true;
    }))
    .build();
----

=== Migration from Binary Choice

The old all-or-nothing approach had limitations:

[source,java]
----
// OLD: Binary choice (cache bloat OR potential mismatches)
// .cacheKeyHeaderFilter(CacheKeyHeaderFilter.ALL)   // Problem: token refresh bloat
// .cacheKeyHeaderFilter(CacheKeyHeaderFilter.NONE)  // Problem: multi-user risks

// NEW: Fine-grained control (best of both worlds)
.cacheKeyHeaderFilter(CacheKeyHeaderFilter.excluding("Authorization"))

// Or use presets for simple cases
.cacheKeyHeaderFilter(CacheKeyHeaderFilter.ALL)   // Same as old ALL
.cacheKeyHeaderFilter(CacheKeyHeaderFilter.NONE)  // Same as old NONE
----

== HttpMethod Enum

*Package:* `de.cuioss.http.client`

*Purpose:* Public enum for HTTP method classification, retry decisions, and logging.

**Visibility:** Public - available for logging and debugging. Users typically interact with methods via `HttpAdapter` interface (`get()`, `post()`, etc.) rather than passing `HttpMethod` values directly.

=== Enum Definition

[source,java]
----
package de.cuioss.http.client;

/**
 * HTTP methods as defined by RFC 7231 and RFC 5789.
 * Public for logging and debugging purposes.
 *
 * @since 1.0
 */
public enum HttpMethod {
    /**
     * GET - Retrieve resource (safe, idempotent, cacheable).
     */
    GET(true, true, "GET"),

    /**
     * POST - Create resource or submit data (unsafe, non-idempotent).
     */
    POST(false, false, "POST"),

    /**
     * PUT - Replace resource (unsafe, idempotent).
     */
    PUT(false, true, "PUT"),

    /**
     * DELETE - Remove resource (unsafe, idempotent).
     */
    DELETE(false, true, "DELETE"),

    /**
     * PATCH - Partially update resource (unsafe, non-idempotent).
     */
    PATCH(false, false, "PATCH"),

    /**
     * HEAD - Retrieve headers only (safe, idempotent, cacheable).
     */
    HEAD(true, true, "HEAD"),

    /**
     * OPTIONS - Query supported methods (safe, idempotent).
     */
    OPTIONS(true, true, "OPTIONS");

    private final boolean safe;
    private final boolean idempotent;
    private final String name;

    HttpMethod(boolean safe, boolean idempotent, String name) {
        this.safe = safe;
        this.idempotent = idempotent;
        this.name = name;
    }

    /**
     * Returns true if method is safe (read-only, no side effects).
     * Safe methods: GET, HEAD, OPTIONS
     */
    public boolean isSafe() {
        return safe;
    }

    /**
     * Returns true if method is idempotent (multiple identical requests
     * have same effect as single request).
     * Idempotent methods: GET, PUT, DELETE, HEAD, OPTIONS
     */
    public boolean isIdempotent() {
        return idempotent;
    }

    /**
     * Returns HTTP method name as string (e.g., "GET", "POST").
     */
    public String methodName() {
        return name;
    }
}
----

=== HTTP Method Properties

[cols="1,1,1,3"]
|===
|Method |Safe? |Idempotent? |Use Case

|**GET**
|✅ Yes
|✅ Yes
|Retrieve resource, query data

|**POST**
|❌ No
|❌ No
|Create resource, submit form, non-idempotent action

|**PUT**
|❌ No
|✅ Yes
|Replace entire resource with new representation

|**DELETE**
|❌ No
|✅ Yes
|Remove resource

|**PATCH**
|❌ No
|❌ No
|Partial update, apply delta

|**HEAD**
|✅ Yes
|✅ Yes
|Check resource existence, get metadata

|**OPTIONS**
|✅ Yes
|✅ Yes
|Query supported methods, CORS preflight
|===

=== Why Public?

**Design Decision:** `HttpMethod` is public for transparency and debugging:

1. **Method-Specific API:** While users typically call `adapter.get()`, `adapter.post()`, etc. (more type-safe than `adapter.execute(HttpMethod.GET)`), the enum is public for:
   - Logging and debugging purposes
   - Error messages that reference the method type
   - Advanced use cases requiring method introspection

2. **Internal Classification:** Used by adapter implementations for:
   - Retry decisions (idempotent methods safe to retry)
   - Request body validation (GET/HEAD don't have bodies)
   - Logging and metrics

3. **Transparency:** Users can understand method semantics (safe, idempotent, cacheable properties)

4. **Debugging:** Error messages and logs can reference `HttpMethod` enum values clearly

5. **Consistency:** Matches pattern of method-specific API while maintaining visibility for debugging

=== Usage in Adapter Implementation

[source,java]
----
// Internal adapter implementation (example)
class ETagAwareHttpAdapter<T> implements HttpAdapter<T> {

    private final HttpHandler httpHandler;
    private final HttpClient httpClient;  // Created once in constructor for thread-safe reuse
    private final HttpResponseConverter<T> responseConverter;
    // ... other fields ...

    public ETagAwareHttpAdapter(HttpHandler httpHandler,
                                HttpResponseConverter<T> responseConverter) {
        this.httpHandler = httpHandler;
        // IMPORTANT: Create HttpClient once in constructor and store as final field
        // This ensures thread-safe reuse across all requests
        this.httpClient = httpHandler.createHttpClient();
        this.responseConverter = responseConverter;
    }

    @Override
    public CompletableFuture<HttpResult<T>> get(Map<String, String> headers) {
        return execute(HttpMethod.GET, null, headers);
    }

    @Override
    public CompletableFuture<HttpResult<T>> post(@Nullable T body, Map<String, String> headers) {
        return execute(HttpMethod.POST, body, headers);
    }

    private CompletableFuture<HttpResult<T>> execute(
        HttpMethod method,
        @Nullable T body,
        Map<String, String> headers
    ) {
        // Validate safe methods don't have bodies (RFC 7231)
        if (method.isSafe() && body != null) {
            throw new IllegalArgumentException(
                method.methodName() + " is safe and cannot have a body"
            );
        }

        // Validate body methods have request converter
        if (!method.isSafe() && body != null && requestConverter == null) {
            throw new IllegalStateException(
                method.methodName() + " with body requires request converter"
            );
        }

        // ========== ETag Caching (GET only) ==========

        // Only cache GET requests
        boolean shouldCache = etagCachingEnabled && method == HttpMethod.GET;

        // Check cache for GET requests
        CacheEntry cachedEntry = null;
        if (shouldCache) {
            String cacheKey = buildCacheKey(uri, headers);
            cachedEntry = cache.get(cacheKey);
        }

        // Build request
        HttpRequest.Builder builder = httpHandler.requestBuilder()
            .method(method.methodName(), buildBodyPublisher(body));

        // Add custom headers
        headers.forEach(builder::header);

        // Add If-None-Match for GET if cache entry exists
        if (cachedEntry != null) {
            builder.header("If-None-Match", cachedEntry.etag());
        }

        // ========== Execute Request ==========

        return httpClient.sendAsync(builder.build(), responseConverter.getBodyHandler())
            .thenApply(response -> {
                int statusCode = response.statusCode();

                // Handle 304 Not Modified (GET only)
                if (statusCode == 304 && cachedEntry != null) {
                    // Return cached content (safe: we hold local reference)
                    return HttpResult.success(cachedEntry.content(), cachedEntry.etag(), 304);
                }

                // Extract ETag from ALL responses (POST, PUT, DELETE, GET)
                String etag = response.headers().firstValue("ETag").orElse(null);

                // Convert response body
                Optional<T> content = responseConverter.convert(response.body());

                // Cache successful GET responses with ETag
                if (shouldCache && statusCode == 200 && etag != null && content.isPresent()) {
                    cache.put(cacheKey, new CacheEntry(content.get(), etag));
                }

                // Return result with ETag (all methods return ETag if present)
                return HttpResult.success(content.orElse(null), etag, statusCode);
            })
            .exceptionally(ex -> {
                return HttpResult.failure("Request failed: " + ex.getMessage(), ex, null);
            });
    }
}
----

=== Usage in Retry Logic

[source,java]
----
// Internal retry logic (example)
class ResilientHttpAdapter<T> implements HttpAdapter<T> {

    private boolean shouldRetry(HttpMethod method, HttpResult<T> result) {
        if (result.isSuccess()) {
            return false;
        }

        // Check idempotency configuration (v1.0)
        if (config.idempotentOnly() && !method.isIdempotent()) {
            LOGGER.warn("Skipping retry for non-idempotent method: {}", method.methodName());
            return false;
        }

        HttpErrorCategory category = result.category();
        return category.isRetryable();
    }
}
----

=== Future Enhancements

**Planned for future versions:**

* Emit metrics per HTTP method
* Add method-specific logging (enhanced observability)

**Not Planned:**

* Adding TRACE, CONNECT methods (rarely used)
* Custom method support (violates HTTP semantics)

=== RFC References

* **RFC 7231** - HTTP/1.1 Semantics (GET, POST, PUT, DELETE, HEAD, OPTIONS)
* **RFC 5789** - PATCH Method for HTTP
* **RFC 7231 Section 4.2.1** - Safe Methods
* **RFC 7231 Section 4.2.2** - Idempotent Methods

== ContentType Enum

*Package:* `de.cuioss.http.client`

*Purpose:* Type-safe MIME type representation with charset support.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Optional;

/**
 * Type-safe content types (MIME types) with charset support.
 *
 * @since 1.0
 */
public enum ContentType {
    APPLICATION_JSON("application/json", StandardCharsets.UTF_8),
    APPLICATION_XML("application/xml", StandardCharsets.UTF_8),
    TEXT_PLAIN("text/plain", StandardCharsets.UTF_8),
    TEXT_HTML("text/html", StandardCharsets.UTF_8),
    TEXT_XML("text/xml", StandardCharsets.UTF_8),
    TEXT_CSV("text/csv", StandardCharsets.UTF_8),
    APPLICATION_FORM_URLENCODED("application/x-www-form-urlencoded", StandardCharsets.UTF_8),
    MULTIPART_FORM_DATA("multipart/form-data", null),
    APPLICATION_OCTET_STREAM("application/octet-stream", null),
    APPLICATION_PDF("application/pdf", null),
    APPLICATION_ZIP("application/zip", null),
    IMAGE_PNG("image/png", null),
    IMAGE_JPEG("image/jpeg", null),
    IMAGE_GIF("image/gif", null),
    IMAGE_SVG("image/svg+xml", StandardCharsets.UTF_8);

    private final String mediaType;
    private final Charset defaultCharset;

    ContentType(String mediaType, Charset defaultCharset) {
        this.mediaType = mediaType;
        this.defaultCharset = defaultCharset;
    }

    /**
     * Returns the media type (e.g., "application/json").
     */
    public String mediaType() {
        return mediaType;
    }

    /**
     * Returns the default charset for this content type.
     */
    public Optional<Charset> defaultCharset() {
        return Optional.ofNullable(defaultCharset);
    }

    /**
     * Returns the complete Content-Type header value with charset if applicable.
     * Example: "application/json; charset=UTF-8"
     */
    public String toHeaderValue() {
        if (defaultCharset != null) {
            return mediaType + "; charset=" + defaultCharset.name();
        }
        return mediaType;
    }
}
----

=== Supported Types

* **JSON**: `APPLICATION_JSON`
* **Text**: `TEXT_PLAIN`, `TEXT_HTML`, `TEXT_CSV`
* **XML**: `APPLICATION_XML`, `TEXT_XML`
* **Form**: `APPLICATION_FORM_URLENCODED`, `MULTIPART_FORM_DATA`
* **Binary**: `APPLICATION_OCTET_STREAM`, `APPLICATION_PDF`, `APPLICATION_ZIP`
* **Images**: `IMAGE_PNG`, `IMAGE_JPEG`, `IMAGE_GIF`, `IMAGE_SVG`

=== Key Methods

[source,java]
----
String mediaType();              // "application/json"
Optional<Charset> defaultCharset(); // UTF_8
String toHeaderValue();          // "application/json; charset=UTF-8"
----

== HttpAdapter Interface

*Package:* `de.cuioss.http.client.adapter`

*Purpose:* Common interface for all HTTP adapters providing method-specific operations.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client.adapter;

import de.cuioss.http.client.result.HttpResult;
import de.cuioss.http.client.converter.HttpRequestConverter;
import org.jspecify.annotations.Nullable;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * Adapter for sending HTTP requests and receiving structured results.
 * Provides method-specific operations following HTTP semantics.
 *
 * <p><b>Async-First Design:</b> All methods return {@code CompletableFuture<HttpResult<T>>}
 * for non-blocking operation. Use {@code .join()} or blocking convenience methods for
 * synchronous usage.
 *
 * <p>The adapter is configured with a HttpResponseConverter<T> for responses.
 * Request bodies can be sent using:
 * <ul>
 *   <li>Same type T (if adapter has request converter configured)</li>
 *   <li>Different type R with explicit HttpRequestConverter<R></li>
 * </ul>
 *
 * @param <T> Response body type
 * @since 1.0
 */
public interface HttpAdapter<T> {

    // ========== NO-BODY METHODS (ASYNC) ==========

    /**
     * Sends GET request to retrieve resource (async).
     * GET requests do not have a body (RFC 7231).
     *
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with response or error information
     */
    CompletableFuture<HttpResult<T>> get(Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> get() { return get(Map.of()); }

    /**
     * Sends HEAD request to retrieve headers only (async, no body in response).
     *
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with response metadata
     */
    CompletableFuture<HttpResult<T>> head(Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> head() { return head(Map.of()); }

    /**
     * Sends OPTIONS request to query supported methods (async).
     *
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with server capabilities
     */
    CompletableFuture<HttpResult<T>> options(Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> options() { return options(Map.of()); }

    /**
     * Sends DELETE request to remove resource (async, no body).
     * Most DELETE requests don't have a body.
     *
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with response or error information
     */
    CompletableFuture<HttpResult<T>> delete(Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> delete() { return delete(Map.of()); }

    // ========== BODY METHODS (T → T, uses configured request converter) ==========

    /**
     * Sends POST request with body of type T (async).
     * Requires adapter to have a request converter configured for type T.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with created resource or error
     * @throws IllegalStateException if no request converter configured for type T
     */
    CompletableFuture<HttpResult<T>> post(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> post(@Nullable T requestBody) { return post(requestBody, Map.of()); }

    /**
     * Sends PUT request with body of type T (async).
     * Requires adapter to have a request converter configured for type T.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with updated resource or error
     * @throws IllegalStateException if no request converter configured for type T
     */
    CompletableFuture<HttpResult<T>> put(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> put(@Nullable T requestBody) { return put(requestBody, Map.of()); }

    /**
     * Sends PATCH request with body of type T (async).
     * Requires adapter to have a request converter configured for type T.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with updated resource or error
     * @throws IllegalStateException if no request converter configured for type T
     */
    CompletableFuture<HttpResult<T>> patch(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> patch(@Nullable T requestBody) { return patch(requestBody, Map.of()); }

    /**
     * Sends DELETE request with body of type T (async).
     * Requires adapter to have a request converter configured for type T.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with response or error
     * @throws IllegalStateException if no request converter configured for type T
     */
    CompletableFuture<HttpResult<T>> delete(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> delete(@Nullable T requestBody) {
        return delete(requestBody, Map.of());
    }

    // ========== BODY METHODS (R → T, explicit request converter) ==========

    /**
     * Sends POST request with explicit request converter for different type (async).
     * Use when request type differs from response type.
     *
     * @param <R> Request body type
     * @param requestConverter Converter for request body serialization
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with created resource (type T) or error
     */
    <R> CompletableFuture<HttpResult<T>> post(HttpRequestConverter<R> requestConverter,
                           @Nullable R requestBody,
                           Map<String, String> additionalHeaders);
    default <R> CompletableFuture<HttpResult<T>> post(HttpRequestConverter<R> requestConverter,
                                   @Nullable R requestBody) {
        return post(requestConverter, requestBody, Map.of());
    }

    /**
     * Sends PUT request with explicit request converter for different type (async).
     *
     * @param <R> Request body type
     * @param requestConverter Converter for request body serialization
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with updated resource (type T) or error
     */
    <R> CompletableFuture<HttpResult<T>> put(HttpRequestConverter<R> requestConverter,
                          @Nullable R requestBody,
                          Map<String, String> additionalHeaders);
    default <R> CompletableFuture<HttpResult<T>> put(HttpRequestConverter<R> requestConverter,
                                  @Nullable R requestBody) {
        return put(requestConverter, requestBody, Map.of());
    }

    /**
     * Sends PATCH request with explicit request converter for different type (async).
     *
     * @param <R> Request body type
     * @param requestConverter Converter for request body serialization
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with updated resource (type T) or error
     */
    <R> CompletableFuture<HttpResult<T>> patch(HttpRequestConverter<R> requestConverter,
                            @Nullable R requestBody,
                            Map<String, String> additionalHeaders);
    default <R> CompletableFuture<HttpResult<T>> patch(HttpRequestConverter<R> requestConverter,
                                    @Nullable R requestBody) {
        return patch(requestConverter, requestBody, Map.of());
    }

    /**
     * Sends DELETE request with explicit request converter for different type (async).
     *
     * @param <R> Request body type
     * @param requestConverter Converter for request body serialization
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with response or error
     */
    <R> CompletableFuture<HttpResult<T>> delete(HttpRequestConverter<R> requestConverter,
                            @Nullable R requestBody,
                            Map<String, String> additionalHeaders);
    default <R> CompletableFuture<HttpResult<T>> delete(HttpRequestConverter<R> requestConverter,
                                    @Nullable R requestBody) {
        return delete(requestConverter, requestBody, Map.of());
    }

    // ========== BLOCKING CONVENIENCE METHODS ==========

    /**
     * Blocking convenience method for GET.
     * Equivalent to {@code get().join()}.
     *
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing response or error information
     */
    default HttpResult<T> getBlocking(Map<String, String> additionalHeaders) {
        return get(additionalHeaders).join();
    }
    default HttpResult<T> getBlocking() { return get().join(); }

    /**
     * Blocking convenience method for POST.
     * Equivalent to {@code post(requestBody).join()}.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing created resource or error
     */
    default HttpResult<T> postBlocking(@Nullable T requestBody, Map<String, String> additionalHeaders) {
        return post(requestBody, additionalHeaders).join();
    }
    default HttpResult<T> postBlocking(@Nullable T requestBody) { return post(requestBody).join(); }

    /**
     * Blocking convenience method for PUT.
     * Equivalent to {@code put(requestBody).join()}.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing updated resource or error
     */
    default HttpResult<T> putBlocking(@Nullable T requestBody, Map<String, String> additionalHeaders) {
        return put(requestBody, additionalHeaders).join();
    }
    default HttpResult<T> putBlocking(@Nullable T requestBody) { return put(requestBody).join(); }

    /**
     * Blocking convenience method for DELETE.
     * Equivalent to {@code delete().join()}.
     *
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing response or error information
     */
    default HttpResult<T> deleteBlocking(Map<String, String> additionalHeaders) {
        return delete(additionalHeaders).join();
    }
    default HttpResult<T> deleteBlocking() { return delete().join(); }
}
----

=== Method Naming Convention

**Why async methods don't have an `Async` suffix:**

This API uses an **async-first design philosophy** where non-blocking operation is the default, primary behavior. The naming convention reflects this priority:

* **Primary methods** (`get()`, `post()`, etc.) return `CompletableFuture<HttpResult<T>>` - non-blocking by default
* **Convenience methods** (`getBlocking()`, `postBlocking()`, etc.) add the `Blocking` suffix to indicate deviation from the default

**Design Rationale:**

[cols="2,3"]
|===
|Consideration |Decision

|Modern HTTP clients are inherently async
|`java.net.http.HttpClient` uses `sendAsync()` as the foundation

|Most use cases benefit from async
|Reduces thread blocking, improves scalability, better resource utilization

|Blocking is the exception, not the rule
|Mark the less-common pattern (blocking) with a suffix

|Consistency with reactive patterns
|Reactive frameworks (Project Reactor, RxJava) use blocking suffix: `.block()`, `.toBlocking()`

|API guidance
|Method names guide developers toward better practices (async-first)

|Cognitive clarity
|If you see `adapter.get()` you MUST check the return type - this is intentional

|CompletableFuture is explicit
|Return type `CompletableFuture<T>` makes async nature unmistakable
|===

**Comparison with `java.net.http.HttpClient`:**

Java's `HttpClient` uses `sendAsync()` for async and `send()` for blocking because:

* It was designed as a blocking-first API (compatibility with traditional Java I/O)
* `send()` existed first (blocking was the "default" in Java 11)
* Async was added as an alternative, hence `sendAsync()`

Our adapter inverts this:

* Async-first architecture from day one
* Blocking methods are convenience wrappers (`.join()` on CompletableFuture)
* Guidance toward modern, scalable patterns

**Usage Pattern:**

[source,java]
----
// Primary async pattern (recommended)
CompletableFuture<HttpResult<User>> future = adapter.get();
future.thenAccept(result -> {
    if (result.isSuccess()) {
        processUser(result.getContent().orElseThrow());
    }
});

// Blocking convenience (simple synchronous cases)
HttpResult<User> result = adapter.getBlocking();
if (result.isSuccess()) {
    processUser(result.getContent().orElseThrow());
}
----

**Important:** Always check return types. If you see `CompletableFuture<T>`, you're working with async code and must handle it appropriately (`.thenAccept()`, `.thenApply()`, `.exceptionally()`, etc.). Never call `.get()` or `.join()` on a CompletableFuture unless you specifically need blocking behavior.

=== Adapter Builder Configuration

[source,java]
----
// Response converter required
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userResponseConverter)  // Required
    .build();

// Response + request converters (for POST/PUT/PATCH with same type)
JsonConverter<User> converter = new JsonConverter<>(User.class);

HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(converter)  // Required
    .requestConverter(converter)    // Optional - same instance for same type
    .build();

// Or separate converters (different types)
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userResponseConverter)      // User
    .requestConverter(createUserRequestConverter)  // CreateUserRequest
    .build();

// Void adapter (status code only) - built-in convenience
HttpAdapter<Void> voidAdapter = ETagAwareHttpAdapter.statusCodeOnly(handler);
// Equivalent to:
// ETagAwareHttpAdapter.<Void>builder()
//     .httpHandler(handler)
//     .responseConverter(VoidResponseConverter.INSTANCE)
//     .build();
----

=== Convenience Factory Methods

[source,java]
----
package de.cuioss.http.client.adapter;

/**
 * Adapter builder and factory methods.
 */
public interface ETagAwareHttpAdapter<T> {

    /**
     * Creates builder for typed responses.
     */
    static <T> Builder<T> builder() {
        return new Builder<>();
    }

    /**
     * Convenience factory for status-code-only adapters.
     * Uses built-in VoidResponseConverter - no body parsing.
     *
     * <p>Use for DELETE, HEAD, health checks, webhooks, etc.
     *
     * @param httpHandler HTTP handler configuration
     * @return Adapter that only returns HTTP status codes
     */
    static HttpAdapter<Void> statusCodeOnly(HttpHandler httpHandler) {
        return ETagAwareHttpAdapter.<Void>builder()
            .httpHandler(httpHandler)
            .responseConverter(VoidResponseConverter.INSTANCE)
            .etagCachingEnabled(false)  // No caching for Void responses
            .build();
    }

    // ... other methods
}
----

**Usage:**

[source,java]
----
// DELETE endpoint - only care about status
HttpAdapter<Void> deleteAdapter = ETagAwareHttpAdapter.statusCodeOnly(
    HttpHandler.builder()
        .uri("https://api.example.com/users/123")
        .build()
);

HttpResult<Void> result = deleteAdapter.delete();
if (result.isSuccess()) {
    LOGGER.info("User deleted successfully");
}

// Health check endpoint
HttpAdapter<Void> healthCheck = ETagAwareHttpAdapter.statusCodeOnly(
    HttpHandler.builder()
        .uri("https://api.example.com/health")
        .build()
);

boolean isHealthy = healthCheck.head().isSuccess();

// Webhook POST (fire and forget)
HttpAdapter<Void> webhook = ETagAwareHttpAdapter.statusCodeOnly(
    HttpHandler.builder()
        .uri("https://webhook.example.com/events")
        .build()
);

WebhookEvent event = new WebhookEvent("user.created", data);
HttpResult<Void> sent = webhook.post(
    new JsonRequestConverter<>(WebhookEvent.class),
    event
);
----

=== Design Rationale

* **Separate concerns** - Request and response conversion are independent responsibilities
* **Single responsibility** - Each converter does one thing well
* **Composable** - Mix different request/response converters as needed
* **Type flexibility** - POST `CreateUserRequest` → returns `User` cleanly supported
* **Optional implementations** - Only implement what you need (GET-only? Just response converter)
* **Same type support** - Use same instance for both converters when request/response share type
* **Method-specific APIs** - Clear intent, follows HTTP semantics
* **RFC compliant** - GET/HEAD/OPTIONS have no body methods
* **Type-safe** - Compiler enforces correct usage
* **Enables composition** - Can wrap adapters for retry, auth, metrics
* **Self-documenting** - Method signatures clearly show what's needed

== HttpErrorCategory

*Package:* `de.cuioss.http.client.result`

*Purpose:* Classify failures for retry decisions.

=== Enum Definition

[source,java]
----
public enum HttpErrorCategory {
    NETWORK_ERROR,      // IOException - RETRYABLE
    SERVER_ERROR,       // 5xx - RETRYABLE
    CLIENT_ERROR,       // 4xx - NOT retryable
    INVALID_CONTENT,    // Parsing failed - NOT retryable
    CONFIGURATION_ERROR; // SSL, URI configuration issues - NOT retryable

    public boolean isRetryable() {
        return this == NETWORK_ERROR || this == SERVER_ERROR;
    }
}
----

*Note on 3xx Redirects:*

* Most 3xx are followed automatically by `HttpClient`
* 304 Not Modified is handled as application-level success by `ETagAwareHttpAdapter`
* No separate REDIRECTION category needed

== HttpStatusFamily

*Package:* `de.cuioss.http.client.handler`

*Purpose:* HTTP protocol-level status classification.

=== Error Category Conversion

[source,java]
----
/**
 * Converts HTTP status family to error category for retry decisions.
 * Note: REDIRECTION is handled specially by ETagAwareHttpAdapter.
 */
public HttpErrorCategory toErrorCategory() {
    return switch (this) {
        case CLIENT_ERROR -> HttpErrorCategory.CLIENT_ERROR;
        case SERVER_ERROR -> HttpErrorCategory.SERVER_ERROR;
        case SUCCESS -> throw new IllegalStateException(
            "SUCCESS is not an error");
        case REDIRECTION -> HttpErrorCategory.INVALID_CONTENT;  // Rare, handled by adapter
        case INFORMATIONAL, UNKNOWN -> HttpErrorCategory.INVALID_CONTENT;
    };
}
----

*Notes:*

* Most 3xx redirects are followed automatically by `HttpClient`
* 304 Not Modified is intercepted by `ETagAwareHttpAdapter` (never reaches error categorization)
* Other 3xx are rare in modern HTTP and mapped to `INVALID_CONTENT`

== Converter Interfaces (Redesigned)

*Package:* `de.cuioss.http.client.converter`

*Purpose:* Separate, composable converters for requests and responses with optional convenience interface.

=== HttpResponseConverter Interface

Handles HTTP response → typed object conversion.

[source,java]
----
package de.cuioss.http.client.converter;

import de.cuioss.http.client.ContentType;
import java.net.http.HttpResponse;
import java.util.Optional;

/**
 * Converts HTTP response bodies to typed objects.
 *
 * @param <T> Response body type
 * @since 1.0
 */
public interface HttpResponseConverter<T> {

    /**
     * Converts HTTP response body to typed object.
     *
     * <p><strong>Error Handling Contract:</strong>
     * <ul>
     *   <li>On success: Return {@code Optional.of(parsedObject)}</li>
     *   <li>On parsing failure: Return {@code Optional.empty()} - adapter will create
     *       {@code HttpResult.failure()} with {@code HttpErrorCategory.INVALID_CONTENT}</li>
     *   <li>Never throw exceptions - return {@code Optional.empty()} instead</li>
     * </ul>
     *
     * @param rawContent Raw response content from HTTP response
     * @return Converted object, or {@code Optional.empty()} if conversion failed
     */
    Optional<T> convert(Object rawContent);

    /**
     * Returns body handler for HTTP response processing.
     *
     * @return BodyHandler appropriate for this content type
     */
    HttpResponse.BodyHandler<?> getBodyHandler();

    /**
     * Returns the expected content type for responses.
     *
     * @return Content type (e.g., APPLICATION_JSON, TEXT_XML)
     */
    ContentType contentType();
}
----

=== HttpRequestConverter Interface

Handles typed object → HTTP request body conversion.

[source,java]
----
package de.cuioss.http.client.converter;

import de.cuioss.http.client.ContentType;
import java.net.http.HttpRequest;
import org.jspecify.annotations.Nullable;

/**
 * Converts typed objects to HTTP request bodies.
 *
 * @param <R> Request body type
 * @since 1.0
 */
public interface HttpRequestConverter<R> {

    /**
     * Converts typed object to HTTP request body publisher.
     *
     * <p><strong>Null Handling Contract:</strong> If content is null, implementations
     * MUST return {@code HttpRequest.BodyPublishers.noBody()}. This is used for
     * requests that don't require a body (e.g., GET, DELETE).
     *
     * <p><strong>Error Handling Contract:</strong>
     * <ul>
     *   <li>On null content: Return {@code HttpRequest.BodyPublishers.noBody()}</li>
     *   <li>On serialization failure: Throw {@code IllegalArgumentException} with cause -
     *       adapter will create {@code HttpResult.failure()} with {@code HttpErrorCategory.INVALID_CONTENT}</li>
     *   <li>Never return {@code noBody()} for serialization failures - throw instead</li>
     * </ul>
     *
     * @param content The content to serialize, may be null
     * @return BodyPublisher for the HTTP request. Never null.
     *         Returns {@code HttpRequest.BodyPublishers.noBody()} for null content only.
     * @throws IllegalArgumentException if serialization fails
     */
    HttpRequest.BodyPublisher toBodyPublisher(@Nullable R content);

    /**
     * Returns the content type for requests.
     *
     * @return Content type (e.g., APPLICATION_JSON, TEXT_XML)
     */
    ContentType contentType();
}
----


=== Implementation Examples

==== Same Type Request and Response (CRUD)

When request and response use the same type - implement both interfaces in one class:

[source,java]
----
public class JsonConverter<T> extends StringContentConverter<T>
        implements HttpResponseConverter<T>, HttpRequestConverter<T> {

    private final ObjectMapper objectMapper;
    private final Class<T> type;

    public JsonConverter(Class<T> type) {
        this.objectMapper = new ObjectMapper();
        this.type = type;
    }

    // Response direction: HTTP JSON → T
    @Override
    protected Optional<T> convertString(String rawContent) {
        try {
            T value = objectMapper.readValue(rawContent, type);
            return Optional.ofNullable(value);
        } catch (JsonProcessingException e) {
            LOGGER.warn("JSON deserialization failed", e);
            return Optional.empty();
        }
    }

    // Request direction: T → HTTP JSON
    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable T content) {
        if (content == null) {
            return HttpRequest.BodyPublishers.noBody();
        }
        try {
            String json = objectMapper.writeValueAsString(content);
            return HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8);
        } catch (JsonProcessingException e) {
            LOGGER.warn("JSON serialization failed", e);
            throw new IllegalArgumentException("Failed to serialize request body to JSON", e);
        }
    }

    // Shared metadata - both interfaces require contentType()
    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }
}

// Usage:
JsonConverter<User> converter = new JsonConverter<>(User.class);

HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(converter)  // Set response
    .requestConverter(converter)    // Set request (same instance)
    .build();
----

==== Response-Only Converter (GET-only APIs)

When you only need to read responses:

[source,java]
----
public class UserResponseConverter extends StringContentConverter<User>
        implements HttpResponseConverter<User> {  // Only response interface

    @Override
    protected Optional<User> convertString(String rawContent) {
        return Optional.ofNullable(parseJsonToUser(rawContent));
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }

    // No toBodyPublisher method needed!
}

// Usage:
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(new UserResponseConverter())  // Only response
    .build();

// Can only use GET/HEAD/OPTIONS/DELETE (no body methods)
HttpResult<User> result = adapter.get();
// adapter.post(user);  // ❌ Compile error - no request converter configured
----

==== Request-Only Converter (Fire-and-Forget POST)

When you only send requests and ignore responses:

[source,java]
----
public class CreateUserRequestConverter implements HttpRequestConverter<CreateUserRequest> {

    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable CreateUserRequest content) {
        if (content == null) return HttpRequest.BodyPublishers.noBody();
        String json = toJson(content);
        return HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8);
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }
}

// Usage with explicit request converter
HttpAdapter<Void> adapter = ETagAwareHttpAdapter.<Void>builder()
    .httpHandler(handler)
    .responseConverter(VoidResponseConverter.INSTANCE)  // Discard response
    .build();

CreateUserRequest request = new CreateUserRequest("john@example.com");
HttpResult<Void> result = adapter.post(
    new CreateUserRequestConverter(),
    request
);
----

==== Mixed Types (Different Request/Response)

POST CreateUserRequest → returns User:

[source,java]
----
// Separate converters
public class UserResponseConverter implements HttpResponseConverter<User> {
    @Override
    protected Optional<User> convertString(String json) {
        return Optional.ofNullable(parseJsonToUser(json));
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }
}

public class CreateUserRequestConverter implements HttpRequestConverter<CreateUserRequest> {
    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable CreateUserRequest content) {
        if (content == null) return HttpRequest.BodyPublishers.noBody();
        return HttpRequest.BodyPublishers.ofString(toJson(content), StandardCharsets.UTF_8);
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }
}

// Adapter configured for User responses
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(new UserResponseConverter())
    .build();

// POST with different request type
CreateUserRequest request = new CreateUserRequest("john@example.com");
HttpResult<User> result = adapter.post(
    new CreateUserRequestConverter(),
    request
);

if (result.isSuccess()) {
    User createdUser = result.getContent().orElseThrow();
    LOGGER.info("Created user with ID: {}", createdUser.getId());
}
----

=== Built-in Converters

==== VoidResponseConverter (Status Code Only)

For operations where you only care about HTTP status code, not the response body:

[source,java]
----
package de.cuioss.http.client.converter;

/**
 * Built-in converter for Void responses (status code only).
 * Use when response body is ignored - only HTTP status matters.
 *
 * <p>Common use cases:
 * <ul>
 *   <li>DELETE /resource/123 → 204 No Content</li>
 *   <li>HEAD /health → 200 OK</li>
 *   <li>POST /webhooks → 200 OK (fire and forget)</li>
 * </ul>
 */
public final class VoidResponseConverter implements HttpResponseConverter<Void> {

    /** Singleton instance - no need to create multiple */
    public static final VoidResponseConverter INSTANCE = new VoidResponseConverter();

    private VoidResponseConverter() {} // Use INSTANCE

    @Override
    public Optional<Void> convert(Object rawContent) {
        return Optional.empty();  // Always empty - body is discarded
    }

    @Override
    public HttpResponse.BodyHandler<?> getBodyHandler() {
        return HttpResponse.BodyHandlers.discarding();  // Efficient - don't read body
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;  // Doesn't matter, body discarded
    }
}
----

**Usage:**

[source,java]
----
// Status-code-only adapter using built-in converter
HttpAdapter<Void> adapter = ETagAwareHttpAdapter.<Void>builder()
    .httpHandler(handler)
    .responseConverter(VoidResponseConverter.INSTANCE)  // Built-in!
    .build();

// DELETE - only care about success/failure
HttpResult<Void> result = adapter.delete();
if (result.isSuccess()) {
    LOGGER.info("Resource deleted (status: {})", result.getHttpStatus().orElse(0));
}

// HEAD - only care about status
HttpResult<Void> healthCheck = adapter.head();
boolean isHealthy = healthCheck.isSuccess();
----

**Note:** Methods without request bodies (GET, HEAD, OPTIONS) do not require a request converter. The adapter will use `HttpRequest.BodyPublishers.noBody()` directly for these methods.

== Module Exports

*File:* `src/main/java/module-info.java`

[source,java]
----
module de.cuioss.http {
    // ... requires

    // Exports
    exports de.cuioss.http.client;
    exports de.cuioss.http.client.handler;
    exports de.cuioss.http.client.converter;
    exports de.cuioss.http.client.result;
    exports de.cuioss.http.client.retry;
    exports de.cuioss.http.client.adapter;

    // ... security exports
}
----

== Summary

All core components follow CUI standards:

* ✅ Immutable, thread-safe design
* ✅ Builder patterns where appropriate
* ✅ @Nullable/@NonNull annotations from JSpecify
* ✅ Lombok for boilerplate reduction
* ✅ Comprehensive Javadoc with examples
* ✅ Optional return types instead of null
* ✅ Fail-secure error handling
