= ETagAwareHttpAdapter
:toc: left
:toc-title: Table of Contents
:toclevels: 3
:sectnums:
:source-highlighter: highlight.js

Base HTTP adapter with built-in, configurable ETag caching.

== 304 Not Modified Handling Pattern

Safe 304 handling achieved through request flow design rather than defensive null checks:

[source,java]
----
// Internal implementation (called by get(), post(), etc.)
private CompletableFuture<HttpResult<T>> send(HttpMethod method, ...) {
    // 1. Retrieve cache entry BEFORE sending request
    CacheEntry cachedEntry = cache.get(cacheKey);

    // 2. Build request with conditional header IF cache exists
    HttpRequest.Builder builder = httpHandler.requestBuilder()
        .method(method.methodName(), ...);

    if (cachedEntry != null) {
        builder.header("If-None-Match", cachedEntry.etag());
    }

    // 3. Send request asynchronously
    return httpClient.sendAsync(builder.build(), responseConverter.getBodyHandler())
        .thenApply(response -> {
            // 4. Handle 304
            if (response.statusCode() == 304) {
                // cachedEntry MUST be non-null here!
                // We only sent If-None-Match if cachedEntry existed.
                // Server only sends 304 if If-None-Match was present.
                // Therefore: cachedEntry cannot be null.
                return HttpResult.success(cachedEntry.content(), cachedEntry.etag(), 304);
            }
            // ... handle other status codes
        });
}
----

**Guarantees:**

* Local reference held throughout request
* Cannot receive 304 without having sent If-None-Match
* Cannot send If-None-Match without cached entry
* Therefore: 304 handling has guaranteed non-null cache entry
* Thread-safe: local reference immune to concurrent cache clearing

**Reliability:** This is a structural design guarantee enforced by program logic. While Java's type system cannot statically verify this at compile time, the implementation ensures 304 can only occur when a cache entry exists. The guarantee is maintained through:

* Sequential flow: cache lookup → If-None-Match decision → request → 304 handling
* Local reference: cache entry captured before request, held throughout
* Logical impossibility: server cannot send 304 without receiving If-None-Match
* Extensive test coverage: unit and integration tests verify this behavior

This approach is more reliable than runtime null checks, which can mask bugs.

== Responsibilities

. Execute requests via HttpHandler
. Convert responses via HttpResponseConverter
. Preserve HTTP metadata (ETag, status)
. ETag caching (when enabled):
** Add If-None-Match for GET requests
** Handle 304 Not Modified
** Return cached content for 304
** Update cache on successful responses
. Error categorization

== ETag Extraction from All Responses

ETags are extracted from **all** HTTP responses (GET, POST, PUT, DELETE) and preserved in `HttpResult`, but only GET responses are **cached** for 304 Not Modified handling. This distinction is important:

* **Extraction** - ETag header read from response and stored in HttpResult (all methods)
  - Primary focus: 2xx successful responses
  - 4xx/5xx error responses: ETags are also extracted if present (enables conditional updates after errors)
  - ETags from error responses are NOT cached
* **Caching** - Response body stored for 304 reuse (GET with 2xx status only)

This enables **optimistic locking patterns** for subsequent updates:

[source,java]
----
// POST creates resource, returns ETag
HttpResult<User> created = adapter.post(user);
String etag = created.getETag().orElseThrow();

// Later: PUT with If-Match for optimistic locking
Map<String, String> headers = Map.of("If-Match", etag);
HttpResult<User> updated = adapter.put(updatedUser, headers);
// Server returns 412 Precondition Failed if resource changed
----

**Use cases:** Conditional updates (If-Match), resource versioning, conflict detection, audit trails.

== 304 Not Modified Flow

[source]
----
1. send() called for GET request

2. send():
   → Retrieve cache entry at START (holds reference)
      CacheEntry cachedEntry = cache.get(cacheKey);
   → If cachedEntry exists with ETag:
      → Add If-None-Match: cachedEntry.etag to request
   → If no cachedEntry:
      → Don't add If-None-Match (normal GET)

3. Server responds: 304 Not Modified, ETag: "cached-etag"

4. send():
   → Detects status == 304
   → Use cachedEntry reference (structurally guaranteed non-null)
   → return HttpResult.success(cachedEntry.content, cachedEntry.etag, 304)
   → Logs at DEBUG level

5. Client receives Success(cachedContent, "cached-etag", 304)
----

**Design:** 304 returned as Success with cached content. Status preserved for metrics/debugging.

=== Why Preserve 304 Status Code?

The 304 status code is preserved in `HttpResult` for:

* **Metrics and Monitoring** - Track cache hit rate, bandwidth savings
* **Debugging** - Distinguish between fresh (200) and cached (304) responses in logs
* **Performance Analysis** - Measure ETag effectiveness
* **Client Logging** - Visibility into caching behavior

**Important:** Client code typically does NOT need to handle 304 differently from 200. Both are Success with content. The status is informational, not actionable:

[source,java]
----
HttpResult<User> result = adapter.get();

// ✅ GOOD - Treat all Success the same
if (result.isSuccess()) {
    result.getContent().ifPresent(this::processUser);
}

// ❌ BAD - Don't special-case 304 in business logic
if (result.getHttpStatus().orElse(0) == 304) {
    // No need for special handling
}
----

== Builder API

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .etagCachingEnabled(true)         // Default: true
    .cacheKeyHeaderFilter(CacheKeyHeaderFilter.ALL)  // Default: ALL (include all headers)
    .maxCacheSize(1000)               // Default: 1000 (timestamp-based eviction)
    .build();
----

=== Builder Parameters

[cols="2,2,3"]
|===
|Parameter |Default |Purpose

|`httpHandler`
|Required
|HTTP client configuration (URI, SSL, timeouts)

|`responseConverter`
|Required
|Response body type conversion (required)

|`requestConverter`
|Optional
|Request body type conversion (for POST/PUT/PATCH)

|`etagCachingEnabled`
|`true`
|Enable/disable ETag caching entirely

|`cacheKeyHeaderFilter`
|`CacheKeyHeaderFilter.ALL`
|Predicate determining which headers to include in cache key (ALL, NONE, or custom filter)

|`maxCacheSize`
|`1000`
|Maximum number of cache entries. When exceeded, 10% oldest entries (by timestamp) are removed
|===

== Cache Key Generation

=== Algorithm

The cache key is generated based on the `cacheKeyHeaderFilter`:

[source,java]
----
String cacheKey = generateCacheKey(uri, additionalHeaders, cacheKeyHeaderFilter);

private String generateCacheKey(URI uri,
                                 Map<String, String> headers,
                                 CacheKeyHeaderFilter filter) {
    StringBuilder key = new StringBuilder(uri.toString());

    if (!headers.isEmpty()) {
        // Sort headers by key for consistency
        List<String> sortedKeys = new ArrayList<>(headers.keySet());
        Collections.sort(sortedKeys);

        for (String headerName : sortedKeys) {
            // Apply filter predicate to each header
            if (filter.includeInCacheKey(headerName)) {
                key.append('|').append(headerName)
                   .append('=').append(headers.get(headerName));
            }
        }
    }

    return key.toString();
}
----

=== Key Components

* **URI**: From HttpHandler (fixed per adapter instance) - always included
* **Filtered headers**: Only headers where `filter.includeInCacheKey(name)` returns true
* **Separator**: `|` character separates URI from headers
* **Sorting**: Headers sorted alphabetically for consistency

=== Examples with CacheKeyHeaderFilter.ALL (Default)

[source]
----
// Simple GET (no additional headers)
"https://api.example.com/users"

// GET with Authorization header (included by ALL)
"https://api.example.com/users|Authorization=Bearer token123"

// GET with multiple headers (sorted alphabetically, all included)
"https://api.example.com/users|Authorization=Bearer token123|X-Request-ID=abc-123"
----

=== Examples with CacheKeyHeaderFilter.NONE

[source]
----
// All requests to same URI use same cache key, regardless of headers:

// User A with Authorization: Bearer token-A
"https://api.example.com/users"

// User B with Authorization: Bearer token-B (same cache key!)
"https://api.example.com/users"

// Different request ID (same cache key)
"https://api.example.com/users"
----

=== Examples with CacheKeyHeaderFilter.excluding("Authorization")

[source]
----
// Solves token refresh cache bloat while keeping content-affecting headers

// Request with Authorization + Accept-Language
.get(Map.of(
    "Authorization", "Bearer token-A",
    "Accept-Language", "en-US"
))
→ "https://api.example.com/users|Accept-Language=en-US"
// Authorization excluded, Accept-Language included

// Same user after token refresh
.get(Map.of(
    "Authorization", "Bearer token-B",  // Changed!
    "Accept-Language", "en-US"
))
→ "https://api.example.com/users|Accept-Language=en-US"
// Same cache key! No bloat despite token change
----

=== Important Notes

* HTTP method is **not** part of cache key (only GET requests are cached)
* Headers are sorted to ensure `{A, B}` and `{B, A}` produce the same key
* Request body is **not** part of cache key (POST/PUT/DELETE never cached)
* Filter is evaluated once per header during cache key generation (low overhead)

**⚠️ Cache Key Filter Trade-offs:**

The `cacheKeyHeaderFilter` setting affects efficiency and memory usage:

**⚠️ IMPORTANT - Token Refresh Scenario:**
If your application uses authentication tokens (e.g., `Authorization: Bearer <token>`) that refresh periodically, the default `CacheKeyHeaderFilter.ALL` will create cache bloat because each new token creates a new cache entry for the same resource. **For single-user clients with token refresh, use `CacheKeyHeaderFilter.excluding("Authorization")` instead.** See solutions below.

=== CacheKeyHeaderFilter.ALL (Default)

**Why ALL is the default:** This is the most secure approach. It prevents cross-user cache pollution in shared adapter instances and provides defense-in-depth against server ETag implementation bugs.

**Pros:**

* ✅ **Security-first:** Prevents cross-user cache pollution in multi-tenant scenarios
* ✅ Efficient in multi-user scenarios: Separate cache per user avoids wasted If-None-Match requests
* ✅ Defense-in-depth: Protects against buggy server ETags (e.g., user-agnostic ETags)
* ✅ Safe for shared adapter instances

**Cons:**

* ❌ Token refresh cache bloat: Each token creates new cache entry for same resource
* ❌ Cache churn: Frequent token refreshes can cause LRU eviction of still-valid entries

**Solutions for token refresh cache bloat:**

. **Use `CacheKeyHeaderFilter.excluding("Authorization")`** - **Recommended!** Keeps content-affecting headers, excludes auth
. **Use `CacheKeyHeaderFilter.NONE`** - For single-user scenarios only
. **Disable caching** - Set `etagCachingEnabled(false)`
. **Separate adapter per token** - Create new adapter on token refresh

**Note:** Manual cache clearing on token refresh is NOT recommended. The automatic eviction will handle memory, and manual clearing loses all cached responses unnecessarily.

=== CacheKeyHeaderFilter.NONE (URI Only)

**Pros:**

* ✅ No token refresh cache bloat: Same URI = same cache entry
* ✅ Higher cache hit rate
* ✅ Better memory efficiency

**Cons:**

* ❌ Multi-user inefficiency: Different users' ETags won't match → server sends full 200 responses
* ❌ Ignores ALL headers including content-affecting ones (Accept-Language, etc.)
* ❌ Relies on server implementing user-aware ETags correctly

**Safe for:**

* Single-user mobile/desktop apps
* Service accounts (one token)
* Per-user adapter instances

**Unsafe for:**

* Shared adapter instances across multiple users
* Multi-tenant web servers

**Better alternative:** Use `CacheKeyHeaderFilter.excluding("Authorization")` to avoid losing content-affecting headers

== Usage Examples

=== Default (ETag Caching Enabled)

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .build();  // caching ON by default
----

=== Disable ETag Caching

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .etagCachingEnabled(false)
    .build();
----

=== URI-Only Cache Keys (Single-User Client)

For mobile apps, desktop apps, or service accounts where token refresh causes cache bloat:

[source,java]
----
// Mobile app - single user, token refreshes frequently
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .cacheKeyHeaderFilter(CacheKeyHeaderFilter.NONE)  // URI only, ignore all headers
    .build();

// Token refresh doesn't create duplicate cache entries
Map<String, String> headers1 = Map.of("Authorization", "Bearer old-token");
HttpResult<User> result1 = adapter.get(headers1);
// Cache key: "https://api.example.com/users"

// After token refresh
Map<String, String> headers2 = Map.of("Authorization", "Bearer new-token");
HttpResult<User> result2 = adapter.get(headers2);
// Same cache key: "https://api.example.com/users"
// → 304 Not Modified (cache hit!)
----

=== Per-User Adapter with URI-Only Keys

Combine per-user adapter instances with URI-only cache keys for optimal efficiency:

[source,java]
----
public class UserSession {
    private final HttpAdapter<User> userAdapter;

    public UserSession(HttpHandler handler, HttpResponseConverter<User> converter) {
        // Each user gets their own adapter instance
        this.userAdapter = ETagAwareHttpAdapter.<User>builder()
            .httpHandler(handler)
            .responseConverter(converter)
            .cacheKeyHeaderFilter(CacheKeyHeaderFilter.NONE)  // Safe: adapter not shared
            .build();
    }

    // No need to include Authorization in cache key - already isolated per user
}
----

== Cache Management

=== Cache Lifecycle

The ETag cache management:

* **No TTL (Time-To-Live)** - Entries never expire based on time
* **Timestamp-based eviction** - When cache exceeds maxCacheSize, remove 10% oldest entries
* **Configurable size limit** - Use `.maxCacheSize(n)` builder parameter (default: 1000)
* **Manual clearing** - Call `clearETagCache()` to remove all entries immediately
* **Thread-safe** - Uses `ConcurrentHashMap` for true concurrent access (no locks)

=== When to Clear Cache

[source,java]
----
ETagAwareHttpAdapter<User> adapter = ...;

// Clear cache manually (rarely needed with automatic eviction)
adapter.clearETagCache();
----

**When to use manual clearing:**

* **User logout** - Clear user-specific cached data
* **Configuration change** - Application settings changed (e.g., switching servers)
* **Token refresh with CacheKeyHeaderFilter.ALL** - Prevent cache key bloat (but prefer using `CacheKeyHeaderFilter.NONE` or `.excluding("Authorization")` instead)

**Not needed for:**

* ❌ Memory pressure - Automatic eviction handles this
* ❌ Periodic maintenance - Cache self-manages at maxCacheSize

**Thread-safe:** In-flight requests hold local cache references. Clearing cache doesn't affect them.

=== Cache Implementation

The cache uses `ConcurrentHashMap` for true concurrent access:

[source,java]
----
// Cache entry record
public record CacheEntry<T>(
    T content,              // Already converted response
    String etag,            // ETag from server
    long timestamp          // System.currentTimeMillis() when added
) {}

// Cache implementation
private final ConcurrentHashMap<String, CacheEntry<T>> cache;
private final int maxCacheSize;

public ETagAwareHttpAdapter(..., int maxCacheSize) {
    this.maxCacheSize = maxCacheSize;
    this.cache = new ConcurrentHashMap<>();
}
----

**Implementation Details:**

* **Data structure**: `ConcurrentHashMap<String, CacheEntry<T>>`
* **Thread-safety**: Fully concurrent - no synchronized blocks needed
* **Cache entry**: Record with `{T content, String etag, long timestamp}`
* **Eviction**: Timestamp-based (stored in CacheEntry), not insertion-order based
* **Zero dependencies**: Uses only Java standard library
* **Performance**: Better concurrency than `Collections.synchronizedMap()`

=== Adding to Cache with Automatic Eviction

Single method handles both adding entries and eviction:

[source,java]
----
/**
 * Add entry to cache and check for eviction.
 * Called every time a successful GET response with ETag is cached.
 */
private void putInCache(String cacheKey, CacheEntry<T> entry) {
    // Add to cache
    cache.put(cacheKey, entry);

    // Check if eviction needed
    checkAndEvict();
}

/**
 * Check cache size and evict oldest 10% if limit exceeded.
 */
private void checkAndEvict() {
    if (cache.size() > maxCacheSize) {
        int entriesToRemove = (int) (maxCacheSize * 0.1);  // Remove 10%

        // Sort by timestamp, remove oldest
        // ConcurrentHashMap's iterator is weakly consistent - safe for concurrent modification
        cache.entrySet().stream()
            .sorted(Map.Entry.comparingByValue((e1, e2) ->
                Long.compare(e1.timestamp(), e2.timestamp())))
            .limit(entriesToRemove)
            .map(Map.Entry::getKey)
            .collect(Collectors.toList())
            .forEach(cache::remove);
    }
}
----

**Usage in adapter:**

[source,java]
----
// In execute() method after successful GET response with ETag:
if (statusCode == 200 && etag != null && content.isPresent()) {
    CacheEntry<T> entry = new CacheEntry<>(
        content.get(),
        etag,
        System.currentTimeMillis()
    );
    putInCache(cacheKey, entry);  // Add + automatic eviction check
}
----

**Eviction Behavior:**

* **Trigger**: EVERY time `putInCache()` is called (every successful GET with ETag)
* **Threshold**: Eviction happens when cache size > `maxCacheSize` (100%)
* **Batch removal**: Remove 10% of maxCacheSize oldest entries (by timestamp)
* **Result**: Cache goes from ~101% → ~90% of maxCacheSize
* **Timestamp-based**: Oldest = earliest timestamp, not access-based
* **Simple**: No complex tracking needed
* **Thread-safe**: ConcurrentHashMap with weakly-consistent iterators - no locks needed
* **Automatic**: No manual eviction calls needed

**Performance Note for High-Throughput Scenarios:**
For applications with very high request rates (>1000 requests/sec), the eviction check on every putInCache() call may introduce overhead. In such cases, consider:
- Increasing `maxCacheSize` to reduce eviction frequency
- Disabling caching entirely if hit rate is low
- Using a dedicated cache layer (Redis, etc.) for shared multi-instance deployments

**Example:** maxCacheSize = 1000
- Cache has 1001 entries → remove 100 oldest → cache = 901 entries
- Next 99 additions can happen without eviction
- At 1001 again → evict 100 → back to 901

**Choosing cache size:**

* **Default (1000)** - Good for most applications (typical web app with ~100-300 unique URIs)
* **Small (100-500)** - Mobile apps, embedded systems, memory-constrained environments
* **Large (5000+)** - High-traffic servers with many unique endpoints
* **Disable size limit** - Use `.maxCacheSize(Integer.MAX_VALUE)` for unbounded cache (not recommended)

=== Cache Management Strategies

==== Strategy 1: URI-Only Cache Keys (Recommended for Single-User)

Best for mobile apps, desktop apps, or service accounts with token refresh:

[source,java]
----
// Use URI-only cache keys - token changes don't create new cache entries
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .cacheKeyHeaderFilter(CacheKeyHeaderFilter.NONE)  // URI only
    .build();

// Token refresh doesn't affect cache
public void refreshAccessToken() {
    String newToken = authService.refreshToken();
    this.currentToken = newToken;
    // No cache clearing needed!
}
----

==== Strategy 1b: Clear on Token Refresh (If Using CacheKeyHeaderFilter.ALL)

**⚠️ Not Recommended** - Prefer Strategy 1 (URI-only cache keys) instead.

If you must use `CacheKeyHeaderFilter.ALL` and token changes frequently:

[source,java]
----
public void refreshAccessToken() {
    String newToken = authService.refreshToken();

    // Clear ETag cache to prevent cache key bloat from old token
    // Downside: Loses all cached responses, increases server load
    userAdapter.clearETagCache();

    this.currentToken = newToken;
}
----

**Why this is suboptimal:** Automatic eviction already manages memory. Manual clearing throws away valid cached responses, forcing server to resend all data. Better to use `CacheKeyHeaderFilter.NONE` or `.excluding("Authorization")`.

==== Strategy 2: Disable Caching for High-Churn Endpoints

For APIs with frequently-changing headers:

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .etagCachingEnabled(false)  // Disable caching
    .build();
----

==== Strategy 3: Separate Adapter Per User (Recommended for Multi-User)

For multi-user scenarios, create one adapter instance per user/session:

[source,java]
----
// Create new adapter per user session
public HttpAdapter<User> createAdapterForUser(String userId) {
    return ETagAwareHttpAdapter.<User>builder()
        .httpHandler(handler)
        .responseConverter(userConverter)
        .cacheKeyHeaderFilter(CacheKeyHeaderFilter.NONE)  // Safe: not shared across users
        .build();
}

// When user logs out, adapter (and its cache) is garbage collected
----

**Benefits:**

* No cross-user cache pollution (each user has own adapter)
* Can use `CacheKeyHeaderFilter.NONE` safely
* Automatic cache cleanup on logout
* Better than shared adapter with `CacheKeyHeaderFilter.ALL`

== Thread Safety

* Builder: NOT thread-safe
* Built adapter: Fully thread-safe (immutable fields, ConcurrentHashMap cache, local references)

== Test Coverage

* ETag caching on/off, If-None-Match conditional sending
* 304 handling, cache hits/misses, ETag preservation
* POST/PUT/DELETE bypass caching
* Network errors, thread safety, concurrent cache clearing
