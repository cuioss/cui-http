= ETagAwareHttpAdapter
:toc: left
:toc-title: Table of Contents
:toclevels: 3
:sectnums:
:source-highlighter: highlight.js

Base HTTP adapter with built-in, configurable ETag caching.

== 304 Not Modified Handling Pattern

Safe 304 handling achieved through request flow design rather than defensive null checks:

[source,java]
----
public HttpResult<T> send(...) {
    // 1. Retrieve cache entry BEFORE sending request
    CacheEntry cachedEntry = cache.get(cacheKey);

    // 2. Build request with conditional header IF cache exists
    HttpRequest.Builder builder = handler.requestBuilder();
    if (cachedEntry != null) {
        builder.header("If-None-Match", cachedEntry.etag());
    }

    // 3. Send request
    HttpResponse<?> response = httpClient.send(builder.build(), ...);

    // 4. Handle 304
    if (response.statusCode() == 304) {
        // cachedEntry MUST be non-null here!
        // We only sent If-None-Match if cachedEntry existed.
        // Server only sends 304 if If-None-Match was present.
        // Therefore: cachedEntry cannot be null.
        return HttpResult.success(cachedEntry.content(), cachedEntry.etag(), 304);
    }
}
----

**Guarantees:**

* Local reference held throughout request
* Cannot receive 304 without having sent If-None-Match
* Cannot send If-None-Match without cached entry
* Therefore: 304 handling has guaranteed non-null cache entry
* Thread-safe: local reference immune to concurrent cache clearing

**Reliability:** This is a structural design guarantee enforced by program logic. While Java's type system cannot statically verify this at compile time, the implementation ensures 304 can only occur when a cache entry exists. The guarantee is maintained through:

* Sequential flow: cache lookup → If-None-Match decision → request → 304 handling
* Local reference: cache entry captured before request, held throughout
* Logical impossibility: server cannot send 304 without receiving If-None-Match
* Extensive test coverage: unit and integration tests verify this behavior

This approach is more reliable than runtime null checks, which can mask bugs.

== Responsibilities

. Execute requests via HttpHandler
. Convert responses via HttpResponseConverter
. Preserve HTTP metadata (ETag, status)
. ETag caching (when enabled):
** Add If-None-Match for GET requests
** Handle 304 Not Modified
** Return cached content for 304
** Update cache on successful responses
. Error categorization

== ETag Extraction from All Responses

ETags are extracted from **all** HTTP responses (GET, POST, PUT, DELETE) and preserved in `HttpResult`, but only GET responses are **cached** for 304 Not Modified handling. This distinction is important:

* **Extraction** - ETag header read from response and stored in HttpResult (all methods)
* **Caching** - Response body stored for 304 reuse (GET only)

This enables **optimistic locking patterns** for subsequent updates:

[source,java]
----
// POST creates resource, returns ETag
HttpResult<User> created = adapter.post(user);
String etag = created.getETag().orElseThrow();

// Later: PUT with If-Match for optimistic locking
Map<String, String> headers = Map.of("If-Match", etag);
HttpResult<User> updated = adapter.put(updatedUser, headers);
// Server returns 412 Precondition Failed if resource changed
----

**Use cases:** Conditional updates (If-Match), resource versioning, conflict detection, audit trails.

== 304 Not Modified Flow

[source]
----
1. send() called for GET request

2. send():
   → Retrieve cache entry at START (holds reference)
      CacheEntry cachedEntry = cache.get(cacheKey);
   → If cachedEntry exists with ETag:
      → Add If-None-Match: cachedEntry.etag to request
   → If no cachedEntry:
      → Don't add If-None-Match (normal GET)

3. Server responds: 304 Not Modified, ETag: "cached-etag"

4. send():
   → Detects status == 304
   → Use cachedEntry reference (structurally guaranteed non-null)
   → return HttpResult.success(cachedEntry.content, cachedEntry.etag, 304)
   → Logs at DEBUG level

5. Client receives Success(cachedContent, "cached-etag", 304)
----

**Design:** 304 returned as Success with cached content. Status preserved for metrics/debugging.

=== Why Preserve 304 Status Code?

The 304 status code is preserved in `HttpResult` for:

* **Metrics and Monitoring** - Track cache hit rate, bandwidth savings
* **Debugging** - Distinguish between fresh (200) and cached (304) responses in logs
* **Performance Analysis** - Measure ETag effectiveness
* **Client Logging** - Visibility into caching behavior

**Important:** Client code typically does NOT need to handle 304 differently from 200. Both are Success with content. The status is informational, not actionable:

[source,java]
----
HttpResult<User> result = adapter.get();

// ✅ GOOD - Treat all Success the same
if (result.isSuccess()) {
    result.getContent().ifPresent(this::processUser);
}

// ❌ BAD - Don't special-case 304 in business logic
if (result.getHttpStatus().orElse(0) == 304) {
    // No need for special handling
}
----

== Builder API

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .etagCachingEnabled(true)         // Default: true
    .cacheKeyHeaderFilter(CacheKeyHeaderFilter.ALL)  // Default: ALL (include all headers)
    .maxCacheSize(1000)               // Default: 1000 (LRU eviction when exceeded)
    .build();
----

=== Builder Parameters

[cols="2,2,3"]
|===
|Parameter |Default |Purpose

|`httpHandler`
|Required
|HTTP client configuration (URI, SSL, timeouts)

|`responseConverter`
|Required
|Response body type conversion (required)

|`requestConverter`
|Optional
|Request body type conversion (for POST/PUT/PATCH)

|`etagCachingEnabled`
|`true`
|Enable/disable ETag caching entirely

|`cacheKeyHeaderFilter`
|`CacheKeyHeaderFilter.ALL`
|Predicate determining which headers to include in cache key (ALL, NONE, or custom filter)

|`maxCacheSize`
|`1000`
|Maximum number of cache entries. When exceeded, least recently used (LRU) entries are evicted automatically
|===

== Cache Key Generation

=== Algorithm

The cache key is generated based on the `cacheKeyHeaderFilter`:

[source,java]
----
String cacheKey = generateCacheKey(uri, additionalHeaders, cacheKeyHeaderFilter);

private String generateCacheKey(URI uri,
                                 Map<String, String> headers,
                                 CacheKeyHeaderFilter filter) {
    StringBuilder key = new StringBuilder(uri.toString());

    if (!headers.isEmpty()) {
        // Sort headers by key for consistency
        List<String> sortedKeys = new ArrayList<>(headers.keySet());
        Collections.sort(sortedKeys);

        for (String headerName : sortedKeys) {
            // Apply filter predicate to each header
            if (filter.includeInCacheKey(headerName)) {
                key.append('|').append(headerName)
                   .append('=').append(headers.get(headerName));
            }
        }
    }

    return key.toString();
}
----

=== Key Components

* **URI**: From HttpHandler (fixed per adapter instance) - always included
* **Filtered headers**: Only headers where `filter.includeInCacheKey(name)` returns true
* **Separator**: `|` character separates URI from headers
* **Sorting**: Headers sorted alphabetically for consistency

=== Examples with CacheKeyHeaderFilter.ALL (Default)

[source]
----
// Simple GET (no additional headers)
"https://api.example.com/users"

// GET with Authorization header (included by ALL)
"https://api.example.com/users|Authorization=Bearer token123"

// GET with multiple headers (sorted alphabetically, all included)
"https://api.example.com/users|Authorization=Bearer token123|X-Request-ID=abc-123"
----

=== Examples with CacheKeyHeaderFilter.NONE

[source]
----
// All requests to same URI use same cache key, regardless of headers:

// User A with Authorization: Bearer token-A
"https://api.example.com/users"

// User B with Authorization: Bearer token-B (same cache key!)
"https://api.example.com/users"

// Different request ID (same cache key)
"https://api.example.com/users"
----

=== Examples with CacheKeyHeaderFilter.excluding("Authorization")

[source]
----
// Solves token refresh cache bloat while keeping content-affecting headers

// Request with Authorization + Accept-Language
.get(Map.of(
    "Authorization", "Bearer token-A",
    "Accept-Language", "en-US"
))
→ "https://api.example.com/users|Accept-Language=en-US"
// Authorization excluded, Accept-Language included

// Same user after token refresh
.get(Map.of(
    "Authorization", "Bearer token-B",  // Changed!
    "Accept-Language", "en-US"
))
→ "https://api.example.com/users|Accept-Language=en-US"
// Same cache key! No bloat despite token change
----

=== Important Notes

* HTTP method is **not** part of cache key (only GET requests are cached)
* Headers are sorted to ensure `{A, B}` and `{B, A}` produce the same key
* Request body is **not** part of cache key (POST/PUT/DELETE never cached)
* Filter is evaluated once per header during cache key generation (low overhead)

**⚠️ Cache Key Filter Trade-offs:**

The `cacheKeyHeaderFilter` setting affects efficiency and memory usage:

=== CacheKeyHeaderFilter.ALL (Default)

**Why ALL is the default:** This is the most secure approach. It prevents cross-user cache pollution in shared adapter instances and provides defense-in-depth against server ETag implementation bugs.

**Pros:**

* ✅ **Security-first:** Prevents cross-user cache pollution in multi-tenant scenarios
* ✅ Efficient in multi-user scenarios: Separate cache per user avoids wasted If-None-Match requests
* ✅ Defense-in-depth: Protects against buggy server ETags (e.g., user-agnostic ETags)
* ✅ Safe for shared adapter instances

**Cons:**

* ❌ Token refresh cache bloat: Each token creates new cache entry for same resource
* ❌ Cache churn: Frequent token refreshes can cause LRU eviction of still-valid entries

**Solutions for token refresh cache bloat:**

. **Use `CacheKeyHeaderFilter.excluding("Authorization")`** - **Recommended!** Keeps content-affecting headers, excludes auth
. **Use `CacheKeyHeaderFilter.NONE`** - For single-user scenarios only
. **Periodic cache clearing** - Call `adapter.clearETagCache()` after token refresh (less ideal)
. **Disable caching** - Set `etagCachingEnabled(false)`
. **Separate adapter per token** - Create new adapter on token refresh

=== CacheKeyHeaderFilter.NONE (URI Only)

**Pros:**

* ✅ No token refresh cache bloat: Same URI = same cache entry
* ✅ Higher cache hit rate
* ✅ Better memory efficiency

**Cons:**

* ❌ Multi-user inefficiency: Different users' ETags won't match → server sends full 200 responses
* ❌ Ignores ALL headers including content-affecting ones (Accept-Language, etc.)
* ❌ Relies on server implementing user-aware ETags correctly

**Safe for:**

* Single-user mobile/desktop apps
* Service accounts (one token)
* Per-user adapter instances

**Unsafe for:**

* Shared adapter instances across multiple users
* Multi-tenant web servers

**Better alternative:** Use `CacheKeyHeaderFilter.excluding("Authorization")` to avoid losing content-affecting headers

== Usage Examples

=== Default (ETag Caching Enabled)

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .build();  // caching ON by default
----

=== Disable ETag Caching

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .etagCachingEnabled(false)
    .build();
----

=== URI-Only Cache Keys (Single-User Client)

For mobile apps, desktop apps, or service accounts where token refresh causes cache bloat:

[source,java]
----
// Mobile app - single user, token refreshes frequently
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .cacheKeyHeaderFilter(CacheKeyHeaderFilter.NONE)  // URI only, ignore all headers
    .build();

// Token refresh doesn't create duplicate cache entries
Map<String, String> headers1 = Map.of("Authorization", "Bearer old-token");
HttpResult<User> result1 = adapter.get(headers1);
// Cache key: "https://api.example.com/users"

// After token refresh
Map<String, String> headers2 = Map.of("Authorization", "Bearer new-token");
HttpResult<User> result2 = adapter.get(headers2);
// Same cache key: "https://api.example.com/users"
// → 304 Not Modified (cache hit!)
----

=== Per-User Adapter with URI-Only Keys

Combine per-user adapter instances with URI-only cache keys for optimal efficiency:

[source,java]
----
public class UserSession {
    private final HttpAdapter<User> userAdapter;

    public UserSession(HttpHandler handler, HttpResponseConverter<User> converter) {
        // Each user gets their own adapter instance
        this.userAdapter = ETagAwareHttpAdapter.<User>builder()
            .httpHandler(handler)
            .responseConverter(converter)
            .cacheKeyHeaderFilter(CacheKeyHeaderFilter.NONE)  // Safe: adapter not shared
            .build();
    }

    // No need to include Authorization in cache key - already isolated per user
}
----

== Cache Management

=== Cache Lifecycle

The ETag cache management:

* **No TTL (Time-To-Live)** - Entries never expire based on time
* **Size-based LRU eviction** - Default max 1000 entries. When exceeded, least recently used entries are evicted automatically
* **Configurable size limit** - Use `.maxCacheSize(n)` builder parameter to adjust (default: 1000)
* **Manual clearing** - Call `clearETagCache()` to remove all entries immediately
* **Thread-safe** - All cache operations are concurrent-safe

=== When to Clear Cache

[source,java]
----
ETagAwareHttpAdapter<User> adapter = ...;

// Clear cache manually
adapter.clearETagCache();
----

**Clear on:** User logout, token refresh, periodic maintenance, configuration change, memory pressure.

**Thread-safe:** In-flight requests hold local cache references. Clearing cache doesn't affect them.

=== Automatic LRU Eviction

The cache automatically evicts least recently used (LRU) entries when `maxCacheSize` is exceeded:

[source,java]
----
// Configure custom cache size
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .maxCacheSize(500)  // Limit to 500 entries instead of default 1000
    .build();

// Cache grows to 500 entries...
// On 501st entry: oldest (least recently accessed) entry is evicted
// Cache size remains at 500
----

**LRU Behavior:**

* **Access order tracking** - Each cache hit (304 response) updates the entry's access time
* **Automatic eviction** - When size exceeds `maxCacheSize`, oldest entry removed
* **No manual intervention** - Eviction happens transparently during cache writes
* **Thread-safe** - Concurrent evictions don't affect in-flight requests

**Choosing cache size:**

* **Default (1000)** - Good for most applications (typical web app with ~100-300 unique URIs)
* **Small (100-500)** - Mobile apps, embedded systems, memory-constrained environments
* **Large (5000+)** - High-traffic servers with many unique endpoints
* **Disable size limit** - Use `.maxCacheSize(Integer.MAX_VALUE)` for unbounded cache (not recommended)

=== Cache Management Strategies

==== Strategy 1: URI-Only Cache Keys (Recommended for Single-User)

Best for mobile apps, desktop apps, or service accounts with token refresh:

[source,java]
----
// Use URI-only cache keys - token changes don't create new cache entries
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .cacheKeyHeaderFilter(CacheKeyHeaderFilter.NONE)  // URI only
    .build();

// Token refresh doesn't affect cache
public void refreshAccessToken() {
    String newToken = authService.refreshToken();
    this.currentToken = newToken;
    // No cache clearing needed!
}
----

==== Strategy 1b: Clear on Token Refresh (If Using CacheKeyHeaderFilter.ALL)

Alternative if you must use `CacheKeyHeaderFilter.ALL` (e.g., multi-user server with no better option):

[source,java]
----
public void refreshAccessToken() {
    String newToken = authService.refreshToken();

    // Clear ETag cache to prevent bloat from old token cache keys
    userAdapter.clearETagCache();

    this.currentToken = newToken;
}
----

==== Strategy 2: Periodic Clearing

For long-running applications:

[source,java]
----
// Schedule periodic cache clearing (e.g., every 1 hour)
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
scheduler.scheduleAtFixedRate(
    () -> adapter.clearETagCache(),
    1, 1, TimeUnit.HOURS
);
----

==== Strategy 3: Disable Caching for High-Churn Endpoints

For APIs with frequently-changing headers:

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .etagCachingEnabled(false)  // Disable caching
    .build();
----

==== Strategy 4: Separate Adapter Per User (Recommended for Multi-User)

For multi-user scenarios, create one adapter instance per user/session:

[source,java]
----
// Create new adapter per user session
public HttpAdapter<User> createAdapterForUser(String userId) {
    return ETagAwareHttpAdapter.<User>builder()
        .httpHandler(handler)
        .responseConverter(userConverter)
        .cacheKeyHeaderFilter(CacheKeyHeaderFilter.NONE)  // Safe: not shared across users
        .build();
}

// When user logs out, adapter (and its cache) is garbage collected
----

**Benefits:**

* No cross-user cache pollution (each user has own adapter)
* Can use `CacheKeyHeaderFilter.NONE` safely
* Automatic cache cleanup on logout
* Better than shared adapter with `CacheKeyHeaderFilter.ALL`

==== Memory Monitoring

Monitor cache size in production:

[source,java]
----
// Log cache statistics periodically
LOGGER.debug("ETag cache entries: {}", adapter.getCacheSize());

// Alert if cache grows too large
if (adapter.getCacheSize() > 10000) {
    LOGGER.warn("ETag cache size exceeded threshold, clearing");
    adapter.clearETagCache();
}
----

**Note:** `getCacheSize()` method should be added to `ETagAwareHttpAdapter` for monitoring.

== Thread Safety

* Builder: NOT thread-safe
* Built adapter: Fully thread-safe (immutable fields, ConcurrentHashMap cache, local references)

== Test Coverage

* ETag caching on/off, If-None-Match conditional sending
* 304 handling, cache hits/misses, ETag preservation
* POST/PUT/DELETE bypass caching
* Network errors, thread safety, concurrent cache clearing
