= HTTP Client Handlers
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

toc::[]

== Maven Coordinates

[source,xml]
----
<dependency>
    <groupId>de.cuioss</groupId>
    <artifactId>cui-http</artifactId>
</dependency>
----

== Overview

HTTP client utilities for request execution, SSL/TLS context management, and HTTP status classification.

== Components

=== Core HTTP Handlers

==== xref:../src/main/java/de/cuioss/http/client/handler/HttpHandler.java[HttpHandler]

Builder-based HTTP client wrapper with automatic SSL context creation for HTTPS.

* Uses `@Builder` pattern for configuration
* Auto-creates secure SSL context via SecureSSLContextProvider when not provided
* Configurable connection and read timeouts (default: 10 seconds)
* Thread-safe after construction

==== xref:../src/main/java/de/cuioss/http/client/ResilientHttpHandler.java[ResilientHttpHandler]

HTTP handler with retry logic and ETag-based caching.

* Retry with configurable strategies
* ETag-based HTTP caching (304 Not Modified support)
* Content conversion via converters
* Thread-safe concurrency handling
* Error categorization and recovery

==== xref:../src/main/java/de/cuioss/http/client/HttpHandlerProvider.java[HttpHandlerProvider]

Interface for providing HTTP handlers with retry strategies.

* Configuration-based handler creation
* Combines HTTP handler with retry strategy
* Used by ResilientHttpHandler for initialization

=== SSL/TLS Support

==== xref:../src/main/java/de/cuioss/http/client/handler/SecureSSLContextProvider.java[SecureSSLContextProvider]

Utility for creating TLS 1.2+ SSL contexts.

=== HTTP Status Classification

==== xref:../src/main/java/de/cuioss/http/client/handler/HttpStatusFamily.java[HttpStatusFamily]

Enum for RFC 7231 HTTP status code classification with static helper methods.

=== Content Conversion

==== xref:../src/main/java/de/cuioss/http/client/converter/HttpContentConverter.java[HttpContentConverter]

Interface for converting HTTP response bodies to domain objects.

* Generic type-safe conversion
* Configurable body handlers
* Empty value support for null/empty responses

==== xref:../src/main/java/de/cuioss/http/client/converter/StringContentConverter.java[StringContentConverter]

Built-in content converter for String responses.

* Identity conversion (no transformation)
* Useful for raw text/JSON responses
* Factory method: `StringContentConverter.identity()`

=== Result Handling

==== xref:../src/main/java/de/cuioss/http/client/result/HttpResult.java[HttpResult]

Sealed interface for HTTP operation results with type-safe pattern matching.

* Success/Failure record types
* ETag support for cache optimization
* HTTP status code tracking
* Error categorization via HttpErrorCategory
* Factory methods for common scenarios

==== xref:../src/main/java/de/cuioss/http/client/result/HttpErrorCategory.java[HttpErrorCategory]

Error categorization for HTTP operations.

* `NETWORK_ERROR` - Connection failures, timeouts
* `SERVER_ERROR` - 5xx responses
* `CLIENT_ERROR` - 4xx responses
* `INVALID_CONTENT` - Content conversion failures
* Retry eligibility determination

==== xref:../src/main/java/de/cuioss/http/client/result/HttpResultState.java[HttpResultState]

HTTP-specific result states extending CUI result framework.

=== Retry Strategies

==== xref:../src/main/java/de/cuioss/http/client/retry/RetryStrategy.java[RetryStrategy]

Interface for HTTP retry strategies with built-in implementations.

* `RetryStrategy.none()` - No retry
* `RetryStrategies.exponentialBackoff()` - Exponential backoff with jitter
* Custom strategies via ExponentialBackoffRetryStrategy builder
* Configurable max attempts and delays

==== xref:../src/main/java/de/cuioss/http/client/retry/ExponentialBackoffRetryStrategy.java[ExponentialBackoffRetryStrategy]

Exponential backoff implementation with jitter.

* Default: 3 attempts, 1s initial delay, 2x multiplier
* Random jitter to distribute retry timing
* Maximum delay capped at 30 seconds

==== xref:../src/main/java/de/cuioss/http/client/retry/RetryContext.java[RetryContext]

Context information passed to retry strategies.

* Tracks attempt count
* Provides last exception
* HTTP response details when available

==== xref:../src/main/java/de/cuioss/http/client/retry/RetryMetrics.java[RetryMetrics]

Metrics collection for retry operations.

* Total attempts
* Successful/failed counts
* Timing information
* Success rate calculation

=== Loading Status

==== xref:../src/main/java/de/cuioss/http/client/LoadingStatusProvider.java[LoadingStatusProvider]

Interface for components providing loading status.

==== xref:../src/main/java/de/cuioss/http/client/LoaderStatus.java[LoaderStatus]

Enum representing loader states.

* `UNDEFINED` - Initial state
* `IN_PROGRESS` - Currently loading
* `ERROR` - Load failed
* `OK` - Successfully loaded

=== Logging

==== xref:../src/main/java/de/cuioss/http/client/HttpLogMessages.java[HttpLogMessages]

Centralized log messages for HTTP operations.

* Structured logging with CuiLogger
* Consistent error codes
* Debug, info, warning, and error levels

== Usage Examples

=== Basic HTTP Handler

[source,java]
----
HttpHandler handler = HttpHandler.builder()
    .uri("https://api.example.com/data")
    .connectionTimeoutSeconds(10)
    .readTimeoutSeconds(30)
    .build();

HttpClient client = handler.createHttpClient();
HttpRequest request = handler.requestBuilder()
    .GET()
    .build();
HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

if (HttpStatusFamily.isSuccess(response.statusCode())) {
    processData(response.body());
}
----

=== Resilient HTTP Handler with Retry and Caching

This example demonstrates the typical resilience pattern using `ResilientHttpHandler` with ETag-based caching, retry logic, and synchronous access.

[source,java]
----
// Create handler provider with retry strategy
HttpHandlerProvider provider = new HttpHandlerProvider() {
    @Override
    public HttpHandler getHttpHandler() {
        return HttpHandler.builder()
            .uri("https://api.example.com/data")
            .connectionTimeoutSeconds(10)
            .readTimeoutSeconds(30)
            .build();
    }

    @Override
    public RetryStrategy getRetryStrategy() {
        // 3 attempts with exponential backoff (1s, 2s, 4s)
        return RetryStrategies.exponentialBackoff();
    }
};

// Create resilient handler with string conversion
ResilientHttpHandler<String> resilientHandler = new ResilientHttpHandler<>(
    provider.getHttpHandler(),
    provider.getRetryStrategy(),
    StringContentConverter.identity()
);

// Load with automatic retry and caching
HttpResult<String> result = resilientHandler.load();

if (result.isSuccess()) {
    result.getContent().ifPresent(content -> {
        processContent(content);
        // ETag available for cache optimization
        result.getETag().ifPresent(etag -> logger.debug("Cached with ETag: {}", etag));
    });
    // Next load() call may return 304 Not Modified with cached content
} else {
    // Handle error with detailed information
    result.getErrorMessage().ifPresent(msg -> logger.error("Load failed: {}", msg));
    HttpErrorCategory category = result.getErrorCategory();

    if (result.isRetryable()) {
        logger.info("Retryable error ({}), will retry", category);
    } else {
        logger.error("Non-retryable error ({}), giving up", category);
    }
}
----

=== Async Initialization with Resilient Handler and Background Refresh

This comprehensive example demonstrates the typical async resilience pattern used in production scenarios. It shows `CompletableFuture`-based initialization, status tracking, and background refresh - the preferred approach for resilient systems.

[source,java]
----
/**
 * Example loader component showing async initialization pattern with ResilientHttpHandler.
 * This pattern is commonly used when:
 * - Initial load may be slow (network latency, discovery, retries)
 * - Application startup should not block on data loading
 * - Background refresh is needed to keep data current
 * - Status monitoring is required for health checks
 */
public class AsyncDataLoader implements LoadingStatusProvider, AutoCloseable {

    private static final CuiLogger LOGGER = new CuiLogger(AsyncDataLoader.class);

    private final HttpHandlerProvider handlerProvider;
    private final ScheduledExecutorService scheduler;
    private final AtomicReference<LoaderStatus> status = new AtomicReference<>(LoaderStatus.UNDEFINED);
    private final AtomicReference<ResilientHttpHandler<String>> httpHandler = new AtomicReference<>();
    private final AtomicReference<String> currentData = new AtomicReference<>();
    private final AtomicReference<ScheduledFuture<?>> refreshTask = new AtomicReference<>();
    private final int refreshIntervalSeconds;

    public AsyncDataLoader(HttpHandlerProvider handlerProvider,
                          ScheduledExecutorService scheduler,
                          int refreshIntervalSeconds) {
        this.handlerProvider = handlerProvider;
        this.scheduler = scheduler;
        this.refreshIntervalSeconds = refreshIntervalSeconds;
    }

    /**
     * Asynchronous initialization - does not block caller.
     * Returns CompletableFuture to allow non-blocking startup and status tracking.
     */
    public CompletableFuture<LoaderStatus> initialize() {
        // Execute initialization asynchronously to avoid blocking application startup
        return CompletableFuture.supplyAsync(() -> {
            status.set(LoaderStatus.IN_PROGRESS);

            // Create resilient handler with retry strategy
            ResilientHttpHandler<String> handler = new ResilientHttpHandler<>(
                handlerProvider.getHttpHandler(),
                handlerProvider.getRetryStrategy(),
                StringContentConverter.identity()
            );
            httpHandler.set(handler);

            // Perform initial load with automatic retry
            HttpResult<String> result = handler.load();

            // Start background refresh regardless of initial load status
            // This enables automatic recovery from transient failures
            startBackgroundRefresh();

            if (result.isSuccess()) {
                result.getContent().ifPresent(content -> {
                    currentData.set(content);
                    LOGGER.info("Data loaded successfully");
                    result.getETag().ifPresent(etag ->
                        LOGGER.debug("Initial ETag: {}", etag));
                });

                status.set(LoaderStatus.OK);
                return LoaderStatus.OK;
            } else {
                // Log error but don't fail completely - background refresh will retry
                result.getErrorMessage().ifPresent(msg ->
                    LOGGER.warn("Initial load failed: {}", msg));

                // Keep status as IN_PROGRESS to allow background refresh to recover
                status.set(LoaderStatus.IN_PROGRESS);
                return LoaderStatus.IN_PROGRESS;
            }
        });
    }

    /**
     * Get current data - safe to call from any thread.
     */
    public Optional<String> getCurrentData() {
        return Optional.ofNullable(currentData.get());
    }

    @Override
    public LoaderStatus getLoaderStatus() {
        return status.get(); // Atomic read, thread-safe
    }

    /**
     * Start background refresh using ResilientHttpHandler's ETag-based caching.
     * Handler automatically sends If-None-Match header on subsequent requests.
     */
    private void startBackgroundRefresh() {
        refreshTask.set(scheduler.scheduleAtFixedRate(() -> {
            try {
                ResilientHttpHandler<String> handler = httpHandler.get();
                if (handler == null) {
                    LOGGER.warn("Handler not initialized, skipping refresh");
                    return;
                }

                // Load with ETag-based caching - may return 304 Not Modified
                HttpResult<String> result = handler.load();

                if (result.isSuccess()) {
                    // Check HTTP status to distinguish between 200 (new data) and 304 (cached)
                    Optional<Integer> httpStatus = result.getHttpStatus();

                    if (httpStatus.isPresent() && httpStatus.get() == 200) {
                        // New data received (200 OK)
                        result.getContent().ifPresent(content -> {
                            currentData.set(content);
                            LOGGER.info("Background refresh: data updated");
                            result.getETag().ifPresent(etag ->
                                LOGGER.debug("New ETag: {}", etag));
                        });
                        status.set(LoaderStatus.OK);
                    } else if (httpStatus.isPresent() && httpStatus.get() == 304) {
                        // Data unchanged (304 Not Modified) - use cached content
                        result.getContent().ifPresent(content -> {
                            LOGGER.debug("Background refresh: data unchanged (304)");
                        });
                        status.set(LoaderStatus.OK);
                    }
                } else {
                    // Handle refresh failure
                    String errorMsg = result.getErrorMessage().orElse("Unknown error");
                    LOGGER.warn("Background refresh failed: {}", errorMsg);

                    // Only set ERROR if we have no cached data at all
                    if (currentData.get() == null) {
                        status.set(LoaderStatus.ERROR);
                    }
                    // Otherwise keep OK status - stale data is better than no data
                }
            } catch (Exception e) {
                LOGGER.error("Background refresh exception", e);
                if (currentData.get() == null) {
                    status.set(LoaderStatus.ERROR);
                }
            }
        }, refreshIntervalSeconds, refreshIntervalSeconds, TimeUnit.SECONDS));

        LOGGER.info("Background refresh started (interval: {}s)", refreshIntervalSeconds);
    }

    @Override
    public void close() {
        ScheduledFuture<?> task = refreshTask.get();
        if (task != null) {
            task.cancel(false);
        }
        httpHandler.set(null);
        currentData.set(null);
        status.set(LoaderStatus.UNDEFINED);
    }
}

// Usage in application
public class Application {
    public static void main(String[] args) {
        // Configure handler provider
        HttpHandlerProvider provider = new HttpHandlerProvider() {
            @Override
            public HttpHandler getHttpHandler() {
                return HttpHandler.builder()
                    .uri("https://api.example.com/data")
                    .connectionTimeoutSeconds(10)
                    .readTimeoutSeconds(30)
                    .build();
            }

            @Override
            public RetryStrategy getRetryStrategy() {
                return ExponentialBackoffRetryStrategy.builder()
                    .maxAttempts(3)
                    .initialDelayMillis(1000)
                    .maxDelayMillis(10000)
                    .multiplier(2.0)
                    .build();
            }
        };

        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        AsyncDataLoader loader = new AsyncDataLoader(provider, scheduler, 300); // 5 min refresh

        // Non-blocking initialization
        CompletableFuture<LoaderStatus> initFuture = loader.initialize();

        // Application continues startup while loader initializes asynchronously
        LOGGER.info("Application starting, loader initializing in background...");

        // Optional: wait for initial load or handle async
        initFuture.thenAccept(status -> {
            LOGGER.info("Loader initialization completed with status: {}", status);

            // Start serving requests - data will be available via getCurrentData()
            startServer(loader);
        }).exceptionally(ex -> {
            LOGGER.error("Loader initialization failed", ex);
            return null;
        });

        // Health check endpoint can monitor loader status
        // GET /health -> loader.getLoaderStatus()
    }

    private static void startServer(AsyncDataLoader loader) {
        // Server can safely access current data
        // loader.getCurrentData() returns Optional<String>
        // loader.getLoaderStatus() returns current status for health checks
    }
}
----

Key aspects of this async pattern:

1. **Non-blocking Initialization**: `CompletableFuture.supplyAsync()` prevents blocking application startup
2. **ETag-based Caching**: `ResilientHttpHandler` automatically handles If-None-Match headers
3. **Status Tracking**: `AtomicReference<LoaderStatus>` for thread-safe status monitoring
4. **Background Refresh**: Scheduled task keeps data current with automatic retry
5. **Graceful Degradation**: Continues with cached data if refresh fails
6. **HTTP 304 Optimization**: Distinguishes between new data (200) and unchanged (304)
7. **Thread Safety**: All state access via atomic references, no synchronization needed

=== Custom Content Converter

[source,java]
----
// Custom converter for JSON to domain object
HttpContentConverter<User> userConverter = new HttpContentConverter<User>() {
    @Override
    public Optional<User> convert(Object rawContent) {
        if (rawContent instanceof String json) {
            try {
                return Optional.of(objectMapper.readValue(json, User.class));
            } catch (Exception e) {
                return Optional.empty();
            }
        }
        return Optional.empty();
    }

    @Override
    public HttpResponse.BodyHandler<?> getBodyHandler() {
        return HttpResponse.BodyHandlers.ofString();
    }

    @Override
    public User emptyValue() {
        return new User(); // Default empty user
    }
};

// Use with resilient handler
ResilientHttpHandler<User> userHandler = new ResilientHttpHandler<>(
    httpHandlerProvider.getHttpHandler(),
    httpHandlerProvider.getRetryStrategy(),
    userConverter
);
----

=== Retry Strategy Configuration

[source,java]
----
// No retry
RetryStrategy noRetry = RetryStrategy.none();

// Exponential backoff with defaults
RetryStrategy exponential = RetryStrategies.exponentialBackoff();

// Custom exponential backoff
RetryStrategy customExponential = ExponentialBackoffRetryStrategy.builder()
    .maxAttempts(5)
    .initialDelayMillis(500)
    .maxDelayMillis(10000)
    .multiplier(1.5)
    .build();
----


== Related Documentation

* xref:../doc/http-security/README.adoc[HTTP Security Validation Framework]
* https://tools.ietf.org/html/rfc7231[RFC 7231 - HTTP/1.1 Semantics]