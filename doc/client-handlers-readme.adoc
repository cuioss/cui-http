= HTTP Client Handlers
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

toc::[]

== Maven Coordinates

[source,xml]
----
<dependency>
    <groupId>de.cuioss</groupId>
    <artifactId>cui-http</artifactId>
</dependency>
----

== Overview

HTTP client utilities for request execution, SSL/TLS context management, and HTTP status classification.

== Components

=== Core HTTP Handlers

==== xref:../src/main/java/de/cuioss/http/client/handler/HttpHandler.java[HttpHandler]

Builder-based HTTP client wrapper with automatic SSL context creation for HTTPS.

* Uses `@Builder` pattern for configuration
* Auto-creates secure SSL context via SecureSSLContextProvider when not provided
* Configurable connection and read timeouts (default: 10 seconds)
* Thread-safe after construction

==== xref:../src/main/java/de/cuioss/http/client/adapter/package-info.java[HTTP Adapters (New Architecture)]

Async-first HTTP client adapters with composable retry and caching.

* **ETagAwareHttpAdapter**: ETag-based HTTP caching with 304 Not Modified support
* **ResilientHttpAdapter**: Non-blocking retry with exponential backoff
* **HttpAdapter**: Method-specific API (get(), post(), put(), delete(), etc.)
* Composition pattern: Wrap adapters for retry + caching
* Thread-safe async execution with CompletableFuture
* Error categorization and idempotency-aware retry

See xref:../src/main/java/de/cuioss/http/client/adapter/package-info.java[package documentation] for complete usage examples.

=== SSL/TLS Support

==== xref:../src/main/java/de/cuioss/http/client/handler/SecureSSLContextProvider.java[SecureSSLContextProvider]

Utility for creating TLS 1.2+ SSL contexts.

=== HTTP Status Classification

==== xref:../src/main/java/de/cuioss/http/client/handler/HttpStatusFamily.java[HttpStatusFamily]

Enum for RFC 7231 HTTP status code classification with static helper methods.

=== Content Conversion

==== xref:../src/main/java/de/cuioss/http/client/converter/HttpContentConverter.java[HttpContentConverter]

Interface for converting HTTP response bodies to domain objects.

* Generic type-safe conversion
* Configurable body handlers
* Empty value support for null/empty responses

==== xref:../src/main/java/de/cuioss/http/client/converter/StringContentConverter.java[StringContentConverter]

Built-in content converter for String responses.

* Identity conversion (no transformation)
* Useful for raw text/JSON responses
* Factory method: `StringContentConverter.identity()`

=== Result Handling

==== xref:../src/main/java/de/cuioss/http/client/result/HttpResult.java[HttpResult]

Sealed interface for HTTP operation results with type-safe pattern matching.

* Success/Failure record types
* ETag support for cache optimization
* HTTP status code tracking
* Error categorization via HttpErrorCategory
* Factory methods for common scenarios

==== xref:../src/main/java/de/cuioss/http/client/result/HttpErrorCategory.java[HttpErrorCategory]

Error categorization for HTTP operations.

* `NETWORK_ERROR` - Connection failures, timeouts
* `SERVER_ERROR` - 5xx responses
* `CLIENT_ERROR` - 4xx responses
* `INVALID_CONTENT` - Content conversion failures
* Retry eligibility determination

==== xref:../src/main/java/de/cuioss/http/client/result/HttpResultState.java[HttpResultState]

HTTP-specific result states extending CUI result framework.

=== Logging

==== xref:../src/main/java/de/cuioss/http/client/HttpLogMessages.java[HttpLogMessages]

Centralized log messages for HTTP operations.

* Structured logging with CuiLogger
* Consistent error codes
* Debug, info, warning, and error levels

== Usage Examples

=== Basic HTTP Handler

[source,java]
----
HttpHandler handler = HttpHandler.builder()
    .uri("https://api.example.com/data")
    .connectionTimeoutSeconds(10)
    .readTimeoutSeconds(30)
    .build();

HttpClient client = handler.createHttpClient();
HttpRequest request = handler.requestBuilder()
    .GET()
    .build();
HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

if (HttpStatusFamily.isSuccess(response.statusCode())) {
    processData(response.body());
}
----

=== HTTP Adapter with Retry and Caching

This example demonstrates the async-first pattern using `HttpAdapter` with ETag-based caching and retry logic.

[source,java]
----
// Create HTTP handler
HttpHandler httpHandler = HttpHandler.builder()
    .uri("https://api.example.com/data")
    .connectionTimeoutSeconds(10)
    .readTimeoutSeconds(30)
    .build();

// Create adapter with ETag caching and retry
HttpAdapter<String> adapter = ResilientHttpAdapter.wrap(
    ETagAwareHttpAdapter.<String>builder()
        .httpHandler(httpHandler)
        .responseConverter(StringContentConverter.identity())
        .build(),
    RetryConfig.defaults() // 5 attempts, exponential backoff
);

// Execute async-first (returns CompletableFuture)
adapter.get(Map.of("Accept", "application/json"))
    .thenAccept(result -> {
        if (result.isSuccess()) {
            result.getContent().ifPresent(content -> {
                processContent(content);
                // ETag available for cache optimization
        result.getETag().ifPresent(etag -> logger.debug("Cached with ETag: {}", etag));
    });
    // Next load() call may return 304 Not Modified with cached content
} else {
    // Handle error with detailed information
    result.getErrorMessage().ifPresent(msg -> logger.error("Load failed: {}", msg));
    HttpErrorCategory category = result.getErrorCategory();

    if (result.isRetryable()) {
        logger.info("Retryable error ({}), will retry", category);
    } else {
        logger.error("Non-retryable error ({}), giving up", category);
    }
}
----

=== Custom Response Converter

[source,java]
----
// Custom converter for JSON to domain object
HttpResponseConverter<User> userConverter = new HttpResponseConverter<User>() {
    @Override
    public Optional<User> convert(Object rawContent) {
        if (rawContent instanceof String json) {
            try {
                return Optional.of(objectMapper.readValue(json, User.class));
            } catch (Exception e) {
                return Optional.empty();
            }
        }
        return Optional.empty();
    }

    @Override
    public HttpResponse.BodyHandler<?> getBodyHandler() {
        return HttpResponse.BodyHandlers.ofString();
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }
};

// Use with adapter
HttpAdapter<User> userAdapter = ResilientHttpAdapter.wrap(
    ETagAwareHttpAdapter.<User>builder()
        .httpHandler(httpHandler)
        .responseConverter(userConverter)
        .build(),
    RetryConfig.defaults()
);

// Execute async-first
userAdapter.get(Map.of("Accept", "application/json"))
    .thenAccept(result -> {
        if (result.isSuccess()) {
            result.getContent().ifPresent(user -> processUser(user));
        }
    });
----

=== Retry Configuration

[source,java]
----
// Default retry: 5 attempts, exponential backoff
RetryConfig defaults = RetryConfig.defaults();

// Custom retry configuration
RetryConfig custom = RetryConfig.builder()
    .maxAttempts(3)
    .initialDelay(Duration.ofMillis(500))
    .multiplier(1.5)
    .maxDelay(Duration.ofSeconds(10))
    .jitter(0.2)  // 20% jitter
    .idempotentOnly(true)  // Only retry GET, PUT, DELETE
    .build();

// Wrap any adapter with retry
HttpAdapter<String> resilientAdapter = ResilientHttpAdapter.wrap(baseAdapter, custom);
----


== Related Documentation

* xref:../doc/http-security/README.adoc[HTTP Security Validation Framework]
* https://tools.ietf.org/html/rfc7231[RFC 7231 - HTTP/1.1 Semantics]