= Core Components Specification
:toc: left
:toclevels: 3
:sectnums:

== Overview

This document provides complete specifications for all core components introduced in the HTTP method extension.

== CacheKeyHeaders Enum

*Package:* `de.cuioss.http.client.adapter`

*Purpose:* Configure which headers are included in ETag cache keys.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client.adapter;

/**
 * Strategy for including HTTP headers in ETag cache keys.
 *
 * <p>Cache keys uniquely identify cached responses. Including headers
 * creates separate cache entries per header combination, excluding
 * headers shares cache entries across different header values.
 *
 * @since 1.0
 */
public enum CacheKeyHeaders {
    /**
     * Include all additional headers in cache key (default).
     *
     * <p><b>Use when:</b>
     * <ul>
     *   <li>Adapter is shared across multiple users</li>
     *   <li>Headers affect response content (Authorization, Accept-Language)</li>
     *   <li>You want defense-in-depth against buggy server ETags</li>
     * </ul>
     *
     * <p><b>Benefits:</b>
     * <ul>
     *   <li>Safe for multi-user scenarios (no cross-user cache pollution)</li>
     *   <li>Efficient: Avoids wasted If-None-Match requests when ETags won't match</li>
     *   <li>Defense against server ETag bugs (user-agnostic ETags)</li>
     * </ul>
     *
     * <p><b>Drawback:</b>
     * <ul>
     *   <li>Token refresh creates duplicate cache entries (cache bloat)</li>
     * </ul>
     */
    ALL,

    /**
     * Exclude all headers from cache key (URI only).
     *
     * <p><b>Use ONLY when:</b>
     * <ul>
     *   <li>Adapter is NOT shared across users (single-user client)</li>
     *   <li>Server implements user-aware ETags correctly</li>
     *   <li>Headers don't affect response content (or server includes in ETag)</li>
     * </ul>
     *
     * <p><b>Benefits:</b>
     * <ul>
     *   <li>No cache bloat from token refresh</li>
     *   <li>Higher cache hit rate for same resource with varying headers</li>
     * </ul>
     *
     * <p><b>Risks:</b>
     * <ul>
     *   <li>In multi-user scenarios: Wasted bandwidth (ETag mismatches)</li>
     *   <li>Relies on server implementing user-aware ETags correctly</li>
     *   <li>May cache wrong content if server doesn't include header-dependent
     *       data in ETag (e.g., Accept-Language)</li>
     * </ul>
     *
     * <p><b>Example - Single User Client:</b>
     * <pre>{@code
     * // Mobile app, desktop app, or service account
     * HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
     *     .httpHandler(handler)
     *     .responseConverter(userConverter)
     *     .cacheKeyHeaders(CacheKeyHeaders.NONE)  // Safe: single user
     *     .build();
     * }</pre>
     *
     * <p><b>Example - Multi-User Server (UNSAFE):</b>
     * <pre>{@code
     * // Web API endpoint (BAD - don't do this!)
     * HttpAdapter<User> sharedAdapter = ETagAwareHttpAdapter.<User>builder()
     *     .httpHandler(handler)
     *     .responseConverter(userConverter)
     *     .cacheKeyHeaders(CacheKeyHeaders.NONE)  // ⚠️ UNSAFE: shared across users
     *     .build();
     *
     * // User A: GET /api/users/me → caches with key "/api/users/me"
     * // User B: GET /api/users/me → sends If-None-Match with User A's ETag
     * // Result: Server sends 200 (ETag mismatch) → wasted bandwidth
     * }</pre>
     */
    NONE;
}
----

=== Decision Guide

[cols="2,2,2"]
|===
|Scenario |Recommended Setting |Rationale

|Multi-user web server
|`CacheKeyHeaders.ALL`
|Separate cache per user, efficient If-None-Match

|Single-user mobile app
|`CacheKeyHeaders.NONE`
|No token refresh cache bloat

|Service account (one token)
|`CacheKeyHeaders.NONE`
|Token rarely changes

|Desktop application
|`CacheKeyHeaders.NONE`
|One user per app instance

|Multi-tenant SaaS
|`CacheKeyHeaders.ALL`
|Defense against cross-tenant leakage

|Per-user adapter instances
|`CacheKeyHeaders.NONE`
|Already isolated per user
|===

== ContentType Enum

*Package:* `de.cuioss.http.client`

*Purpose:* Type-safe MIME type representation with charset support.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Optional;

/**
 * Type-safe content types (MIME types) with charset support.
 *
 * @since 1.0
 */
public enum ContentType {
    APPLICATION_JSON("application/json", StandardCharsets.UTF_8),
    APPLICATION_XML("application/xml", StandardCharsets.UTF_8),
    TEXT_PLAIN("text/plain", StandardCharsets.UTF_8),
    TEXT_HTML("text/html", StandardCharsets.UTF_8),
    TEXT_XML("text/xml", StandardCharsets.UTF_8),
    TEXT_CSV("text/csv", StandardCharsets.UTF_8),
    APPLICATION_FORM_URLENCODED("application/x-www-form-urlencoded", StandardCharsets.UTF_8),
    MULTIPART_FORM_DATA("multipart/form-data", null),
    APPLICATION_OCTET_STREAM("application/octet-stream", null),
    APPLICATION_PDF("application/pdf", null),
    APPLICATION_ZIP("application/zip", null),
    IMAGE_PNG("image/png", null),
    IMAGE_JPEG("image/jpeg", null),
    IMAGE_GIF("image/gif", null),
    IMAGE_SVG("image/svg+xml", StandardCharsets.UTF_8);

    private final String mediaType;
    private final Charset defaultCharset;

    ContentType(String mediaType, Charset defaultCharset) {
        this.mediaType = mediaType;
        this.defaultCharset = defaultCharset;
    }

    /**
     * Returns the media type (e.g., "application/json").
     */
    public String mediaType() {
        return mediaType;
    }

    /**
     * Returns the default charset for this content type.
     */
    public Optional<Charset> defaultCharset() {
        return Optional.ofNullable(defaultCharset);
    }

    /**
     * Returns the complete Content-Type header value with charset if applicable.
     * Example: "application/json; charset=UTF-8"
     */
    public String toHeaderValue() {
        if (defaultCharset != null) {
            return mediaType + "; charset=" + defaultCharset.name();
        }
        return mediaType;
    }
}
----

=== Supported Types

* **JSON**: `APPLICATION_JSON`
* **Text**: `TEXT_PLAIN`, `TEXT_HTML`, `TEXT_CSV`
* **XML**: `APPLICATION_XML`, `TEXT_XML`
* **Form**: `APPLICATION_FORM_URLENCODED`, `MULTIPART_FORM_DATA`
* **Binary**: `APPLICATION_OCTET_STREAM`, `APPLICATION_PDF`, `APPLICATION_ZIP`
* **Images**: `IMAGE_PNG`, `IMAGE_JPEG`, `IMAGE_GIF`, `IMAGE_SVG`

=== Key Methods

[source,java]
----
String mediaType();              // "application/json"
Optional<Charset> defaultCharset(); // UTF_8
String toHeaderValue();          // "application/json; charset=UTF-8"
----

== HttpAdapter Interface

*Package:* `de.cuioss.http.client.adapter`

*Purpose:* Common interface for all HTTP adapters providing method-specific operations.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client.adapter;

import de.cuioss.http.client.result.HttpResult;
import de.cuioss.http.client.converter.HttpRequestConverter;
import org.jspecify.annotations.Nullable;
import java.util.Map;

/**
 * Adapter for sending HTTP requests and receiving structured results.
 * Provides method-specific operations following HTTP semantics.
 *
 * <p>The adapter is configured with a HttpResponseConverter<T> for responses.
 * Request bodies can be sent using:
 * <ul>
 *   <li>Same type T (if adapter has request converter configured)</li>
 *   <li>Different type R with explicit HttpRequestConverter<R></li>
 * </ul>
 *
 * @param <T> Response body type
 * @since 1.0
 */
public interface HttpAdapter<T> {

    // ========== NO-BODY METHODS ==========

    /**
     * Sends GET request to retrieve resource.
     * GET requests do not have a body (RFC 7231).
     *
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing response or error information
     */
    HttpResult<T> get(Map<String, String> additionalHeaders);
    default HttpResult<T> get() { return get(Map.of()); }

    /**
     * Sends HEAD request to retrieve headers only (no body in response).
     *
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing response metadata
     */
    HttpResult<T> head(Map<String, String> additionalHeaders);
    default HttpResult<T> head() { return head(Map.of()); }

    /**
     * Sends OPTIONS request to query supported methods.
     *
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing server capabilities
     */
    HttpResult<T> options(Map<String, String> additionalHeaders);
    default HttpResult<T> options() { return options(Map.of()); }

    /**
     * Sends DELETE request to remove resource.
     * Most DELETE requests don't have a body.
     *
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing response or error information
     */
    HttpResult<T> delete(Map<String, String> additionalHeaders);
    default HttpResult<T> delete() { return delete(Map.of()); }

    // ========== BODY METHODS (T → T, uses configured request converter) ==========

    /**
     * Sends POST request with body of type T.
     * Requires adapter to have a request converter configured for type T.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing created resource or error
     * @throws IllegalStateException if no request converter configured for type T
     */
    HttpResult<T> post(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default HttpResult<T> post(@Nullable T requestBody) { return post(requestBody, Map.of()); }

    /**
     * Sends PUT request with body of type T.
     * Requires adapter to have a request converter configured for type T.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing updated resource or error
     * @throws IllegalStateException if no request converter configured for type T
     */
    HttpResult<T> put(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default HttpResult<T> put(@Nullable T requestBody) { return put(requestBody, Map.of()); }

    /**
     * Sends PATCH request with body of type T.
     * Requires adapter to have a request converter configured for type T.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing updated resource or error
     * @throws IllegalStateException if no request converter configured for type T
     */
    HttpResult<T> patch(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default HttpResult<T> patch(@Nullable T requestBody) { return patch(requestBody, Map.of()); }

    /**
     * Sends DELETE request with body of type T.
     * Requires adapter to have a request converter configured for type T.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing response or error
     * @throws IllegalStateException if no request converter configured for type T
     */
    HttpResult<T> delete(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default HttpResult<T> delete(@Nullable T requestBody) {
        return delete(requestBody, Map.of());
    }

    // ========== BODY METHODS (R → T, explicit request converter) ==========

    /**
     * Sends POST request with explicit request converter for different type.
     * Use when request type differs from response type.
     *
     * @param <R> Request body type
     * @param requestConverter Converter for request body serialization
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing created resource (type T) or error
     */
    <R> HttpResult<T> post(HttpRequestConverter<R> requestConverter,
                           @Nullable R requestBody,
                           Map<String, String> additionalHeaders);
    default <R> HttpResult<T> post(HttpRequestConverter<R> requestConverter,
                                   @Nullable R requestBody) {
        return post(requestConverter, requestBody, Map.of());
    }

    /**
     * Sends PUT request with explicit request converter for different type.
     *
     * @param <R> Request body type
     * @param requestConverter Converter for request body serialization
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing updated resource (type T) or error
     */
    <R> HttpResult<T> put(HttpRequestConverter<R> requestConverter,
                          @Nullable R requestBody,
                          Map<String, String> additionalHeaders);
    default <R> HttpResult<T> put(HttpRequestConverter<R> requestConverter,
                                  @Nullable R requestBody) {
        return put(requestConverter, requestBody, Map.of());
    }

    /**
     * Sends PATCH request with explicit request converter for different type.
     *
     * @param <R> Request body type
     * @param requestConverter Converter for request body serialization
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing updated resource (type T) or error
     */
    <R> HttpResult<T> patch(HttpRequestConverter<R> requestConverter,
                            @Nullable R requestBody,
                            Map<String, String> additionalHeaders);
    default <R> HttpResult<T> patch(HttpRequestConverter<R> requestConverter,
                                    @Nullable R requestBody) {
        return patch(requestConverter, requestBody, Map.of());
    }

    /**
     * Sends DELETE request with explicit request converter for different type.
     *
     * @param <R> Request body type
     * @param requestConverter Converter for request body serialization
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing response or error
     */
    <R> HttpResult<T> delete(HttpRequestConverter<R> requestConverter,
                            @Nullable R requestBody,
                            Map<String, String> additionalHeaders);
    default <R> HttpResult<T> delete(HttpRequestConverter<R> requestConverter,
                                    @Nullable R requestBody) {
        return delete(requestConverter, requestBody, Map.of());
    }
}
----

=== Adapter Builder Configuration

[source,java]
----
// Response converter required
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userResponseConverter)  // Required
    .build();

// Response + request converters (for POST/PUT/PATCH with same type)
JsonConverter<User> converter = new JsonConverter<>(User.class);

HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(converter)  // Required
    .requestConverter(converter)    // Optional - same instance for same type
    .build();

// Or separate converters (different types)
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userResponseConverter)      // User
    .requestConverter(createUserRequestConverter)  // CreateUserRequest
    .build();

// Void adapter (status code only) - built-in convenience
HttpAdapter<Void> voidAdapter = ETagAwareHttpAdapter.statusCodeOnly(handler);
// Equivalent to:
// ETagAwareHttpAdapter.<Void>builder()
//     .httpHandler(handler)
//     .responseConverter(VoidResponseConverter.INSTANCE)
//     .build();
----

=== Convenience Factory Methods

[source,java]
----
package de.cuioss.http.client.adapter;

/**
 * Adapter builder and factory methods.
 */
public interface ETagAwareHttpAdapter<T> {

    /**
     * Creates builder for typed responses.
     */
    static <T> Builder<T> builder() {
        return new Builder<>();
    }

    /**
     * Convenience factory for status-code-only adapters.
     * Uses built-in VoidResponseConverter - no body parsing.
     *
     * <p>Use for DELETE, HEAD, health checks, webhooks, etc.
     *
     * @param httpHandler HTTP handler configuration
     * @return Adapter that only returns HTTP status codes
     */
    static HttpAdapter<Void> statusCodeOnly(HttpHandler httpHandler) {
        return ETagAwareHttpAdapter.<Void>builder()
            .httpHandler(httpHandler)
            .responseConverter(VoidResponseConverter.INSTANCE)
            .etagCachingEnabled(false)  // No caching for Void responses
            .build();
    }

    // ... other methods
}
----

**Usage:**

[source,java]
----
// DELETE endpoint - only care about status
HttpAdapter<Void> deleteAdapter = ETagAwareHttpAdapter.statusCodeOnly(
    HttpHandler.builder()
        .uri("https://api.example.com/users/123")
        .build()
);

HttpResult<Void> result = deleteAdapter.delete();
if (result.isSuccess()) {
    LOGGER.info("User deleted successfully");
}

// Health check endpoint
HttpAdapter<Void> healthCheck = ETagAwareHttpAdapter.statusCodeOnly(
    HttpHandler.builder()
        .uri("https://api.example.com/health")
        .build()
);

boolean isHealthy = healthCheck.head().isSuccess();

// Webhook POST (fire and forget)
HttpAdapter<Void> webhook = ETagAwareHttpAdapter.statusCodeOnly(
    HttpHandler.builder()
        .uri("https://webhook.example.com/events")
        .build()
);

WebhookEvent event = new WebhookEvent("user.created", data);
HttpResult<Void> sent = webhook.post(
    new JsonRequestConverter<>(WebhookEvent.class),
    event
);
----

=== Design Rationale

* **Separate concerns** - Request and response conversion are independent responsibilities
* **Single responsibility** - Each converter does one thing well
* **Composable** - Mix different request/response converters as needed
* **Type flexibility** - POST `CreateUserRequest` → returns `User` cleanly supported
* **Optional implementations** - Only implement what you need (GET-only? Just response converter)
* **Same type support** - Use same instance for both converters when request/response share type
* **Method-specific APIs** - Clear intent, follows HTTP semantics
* **RFC compliant** - GET/HEAD/OPTIONS have no body methods
* **Type-safe** - Compiler enforces correct usage
* **Enables composition** - Can wrap adapters for retry, auth, metrics
* **Self-documenting** - Method signatures clearly show what's needed

== HttpErrorCategory

*Package:* `de.cuioss.http.client.result`

*Purpose:* Classify failures for retry decisions.

=== Enum Definition

[source,java]
----
public enum HttpErrorCategory {
    NETWORK_ERROR,      // IOException - RETRYABLE
    SERVER_ERROR,       // 5xx - RETRYABLE
    CLIENT_ERROR,       // 4xx - NOT retryable
    INVALID_CONTENT,    // Parsing failed - NOT retryable
    CONFIGURATION_ERROR; // SSL, URI configuration issues - NOT retryable

    public boolean isRetryable() {
        return this == NETWORK_ERROR || this == SERVER_ERROR;
    }
}
----

*Note on 3xx Redirects:*

* Most 3xx are followed automatically by `HttpClient`
* 304 Not Modified is handled as application-level success by `ETagAwareHttpAdapter`
* No separate REDIRECTION category needed

== HttpStatusFamily

*Package:* `de.cuioss.http.client.handler`

*Purpose:* HTTP protocol-level status classification.

=== Error Category Conversion

[source,java]
----
/**
 * Converts HTTP status family to error category for retry decisions.
 * Note: REDIRECTION is handled specially by ETagAwareHttpAdapter.
 */
public HttpErrorCategory toErrorCategory() {
    return switch (this) {
        case CLIENT_ERROR -> HttpErrorCategory.CLIENT_ERROR;
        case SERVER_ERROR -> HttpErrorCategory.SERVER_ERROR;
        case SUCCESS -> throw new IllegalStateException(
            "SUCCESS is not an error");
        case REDIRECTION -> HttpErrorCategory.INVALID_CONTENT;  // Rare, handled by adapter
        case INFORMATIONAL, UNKNOWN -> HttpErrorCategory.INVALID_CONTENT;
    };
}
----

*Notes:*

* Most 3xx redirects are followed automatically by `HttpClient`
* 304 Not Modified is intercepted by `ETagAwareHttpAdapter` (never reaches error categorization)
* Other 3xx are rare in modern HTTP and mapped to `INVALID_CONTENT`

== Converter Interfaces (Redesigned)

*Package:* `de.cuioss.http.client.converter`

*Purpose:* Separate, composable converters for requests and responses with optional convenience interface.

=== HttpResponseConverter Interface

Handles HTTP response → typed object conversion.

[source,java]
----
package de.cuioss.http.client.converter;

import de.cuioss.http.client.ContentType;
import java.net.http.HttpResponse;
import java.util.Optional;

/**
 * Converts HTTP response bodies to typed objects.
 *
 * @param <T> Response body type
 * @since 1.0
 */
public interface HttpResponseConverter<T> {

    /**
     * Converts HTTP response body to typed object.
     *
     * @param rawContent Raw response content from HTTP response
     * @return Converted object, or empty if conversion failed
     */
    Optional<T> convert(Object rawContent);

    /**
     * Returns body handler for HTTP response processing.
     *
     * @return BodyHandler appropriate for this content type
     */
    HttpResponse.BodyHandler<?> getBodyHandler();

    /**
     * Returns the expected content type for responses.
     *
     * @return Content type (e.g., APPLICATION_JSON, TEXT_XML)
     */
    ContentType contentType();
}
----

=== HttpRequestConverter Interface

Handles typed object → HTTP request body conversion.

[source,java]
----
package de.cuioss.http.client.converter;

import de.cuioss.http.client.ContentType;
import java.net.http.HttpRequest;
import org.jspecify.annotations.Nullable;

/**
 * Converts typed objects to HTTP request bodies.
 *
 * @param <R> Request body type
 * @since 1.0
 */
public interface HttpRequestConverter<R> {

    /**
     * Converts typed object to HTTP request body publisher.
     *
     * <p>If content is null, implementations should return a no-body publisher.
     *
     * @param content The content to serialize, may be null
     * @return BodyPublisher for the HTTP request
     */
    HttpRequest.BodyPublisher toBodyPublisher(@Nullable R content);

    /**
     * Returns the content type for requests.
     *
     * @return Content type (e.g., APPLICATION_JSON, TEXT_XML)
     */
    ContentType contentType();
}
----


=== Implementation Examples

==== Same Type Request and Response (CRUD)

When request and response use the same type - implement both interfaces in one class:

[source,java]
----
public class JsonConverter<T> extends StringContentConverter<T>
        implements HttpResponseConverter<T>, HttpRequestConverter<T> {

    private final ObjectMapper objectMapper;
    private final Class<T> type;

    public JsonConverter(Class<T> type) {
        this.objectMapper = new ObjectMapper();
        this.type = type;
    }

    // Response direction: HTTP JSON → T
    @Override
    protected Optional<T> convertString(String rawContent) {
        try {
            T value = objectMapper.readValue(rawContent, type);
            return Optional.ofNullable(value);
        } catch (JsonProcessingException e) {
            LOGGER.error("JSON deserialization failed", e);
            return Optional.empty();
        }
    }

    // Request direction: T → HTTP JSON
    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable T content) {
        if (content == null) {
            return HttpRequest.BodyPublishers.noBody();
        }
        try {
            String json = objectMapper.writeValueAsString(content);
            return HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8);
        } catch (JsonProcessingException e) {
            LOGGER.error("JSON serialization failed", e);
            return HttpRequest.BodyPublishers.noBody();
        }
    }

    // Shared metadata - both interfaces require contentType()
    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }
}

// Usage:
JsonConverter<User> converter = new JsonConverter<>(User.class);

HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(converter)  // Set response
    .requestConverter(converter)    // Set request (same instance)
    .build();
----

==== Response-Only Converter (GET-only APIs)

When you only need to read responses:

[source,java]
----
public class UserResponseConverter extends StringContentConverter<User>
        implements HttpResponseConverter<User> {  // Only response interface

    @Override
    protected Optional<User> convertString(String rawContent) {
        return Optional.ofNullable(parseJsonToUser(rawContent));
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }

    // No toBodyPublisher method needed!
}

// Usage:
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(new UserResponseConverter())  // Only response
    .build();

// Can only use GET/HEAD/OPTIONS/DELETE (no body methods)
HttpResult<User> result = adapter.get();
// adapter.post(user);  // ❌ Compile error - no request converter configured
----

==== Request-Only Converter (Fire-and-Forget POST)

When you only send requests and ignore responses:

[source,java]
----
public class CreateUserRequestConverter implements HttpRequestConverter<CreateUserRequest> {

    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable CreateUserRequest content) {
        if (content == null) return HttpRequest.BodyPublishers.noBody();
        String json = toJson(content);
        return HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8);
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }
}

// Usage with explicit request converter
HttpAdapter<Void> adapter = ETagAwareHttpAdapter.<Void>builder()
    .httpHandler(handler)
    .responseConverter(new VoidConverter())  // Discard response
    .build();

CreateUserRequest request = new CreateUserRequest("john@example.com");
HttpResult<Void> result = adapter.post(
    new CreateUserRequestConverter(),
    request
);
----

==== Mixed Types (Different Request/Response)

POST CreateUserRequest → returns User:

[source,java]
----
// Separate converters
public class UserResponseConverter implements HttpResponseConverter<User> {
    @Override
    protected Optional<User> convertString(String json) {
        return Optional.ofNullable(parseJsonToUser(json));
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }
}

public class CreateUserRequestConverter implements HttpRequestConverter<CreateUserRequest> {
    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable CreateUserRequest content) {
        if (content == null) return HttpRequest.BodyPublishers.noBody();
        return HttpRequest.BodyPublishers.ofString(toJson(content), StandardCharsets.UTF_8);
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }
}

// Adapter configured for User responses
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(new UserResponseConverter())
    .build();

// POST with different request type
CreateUserRequest request = new CreateUserRequest("john@example.com");
HttpResult<User> result = adapter.post(
    new CreateUserRequestConverter(),
    request
);

if (result.isSuccess()) {
    User createdUser = result.getValue().orElseThrow();
    LOGGER.info("Created user with ID: {}", createdUser.getId());
}
----

=== Built-in Converters

==== VoidResponseConverter (Status Code Only)

For operations where you only care about HTTP status code, not the response body:

[source,java]
----
package de.cuioss.http.client.converter;

/**
 * Built-in converter for Void responses (status code only).
 * Use when response body is ignored - only HTTP status matters.
 *
 * <p>Common use cases:
 * <ul>
 *   <li>DELETE /resource/123 → 204 No Content</li>
 *   <li>HEAD /health → 200 OK</li>
 *   <li>POST /webhooks → 200 OK (fire and forget)</li>
 * </ul>
 */
public final class VoidResponseConverter implements HttpResponseConverter<Void> {

    /** Singleton instance - no need to create multiple */
    public static final VoidResponseConverter INSTANCE = new VoidResponseConverter();

    private VoidResponseConverter() {} // Use INSTANCE

    @Override
    public Optional<Void> convert(Object rawContent) {
        return Optional.empty();  // Always empty - body is discarded
    }

    @Override
    public HttpResponse.BodyHandler<?> getBodyHandler() {
        return HttpResponse.BodyHandlers.discarding();  // Efficient - don't read body
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;  // Doesn't matter, body discarded
    }
}
----

**Usage:**

[source,java]
----
// Status-code-only adapter using built-in converter
HttpAdapter<Void> adapter = ETagAwareHttpAdapter.<Void>builder()
    .httpHandler(handler)
    .responseConverter(VoidResponseConverter.INSTANCE)  // Built-in!
    .build();

// DELETE - only care about success/failure
HttpResult<Void> result = adapter.delete();
if (result.isSuccess()) {
    LOGGER.info("Resource deleted (status: {})", result.getHttpStatus().orElse(0));
}

// HEAD - only care about status
HttpResult<Void> healthCheck = adapter.head();
boolean isHealthy = healthCheck.isSuccess();
----

==== VoidRequestConverter (No Body Requests)

For operations where request has no body:

[source,java]
----
package de.cuioss.http.client.converter;

/**
 * Built-in converter for requests with no body.
 * Returns no-body publisher for any input.
 */
public final class VoidRequestConverter implements HttpRequestConverter<Void> {

    /** Singleton instance */
    public static final VoidRequestConverter INSTANCE = new VoidRequestConverter();

    private VoidRequestConverter() {} // Use INSTANCE

    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable Void content) {
        return HttpRequest.BodyPublishers.noBody();
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;  // Doesn't matter
    }
}
----

== Module Exports

*File:* `src/main/java/module-info.java`

[source,java]
----
module de.cuioss.http {
    // ... requires

    // Exports
    exports de.cuioss.http.client;
    exports de.cuioss.http.client.handler;
    exports de.cuioss.http.client.converter;
    exports de.cuioss.http.client.result;
    exports de.cuioss.http.client.retry;
    exports de.cuioss.http.client.adapter;

    // ... security exports
}
----

== Summary

All core components follow CUI standards:

* ✅ Immutable, thread-safe design
* ✅ Builder patterns where appropriate
* ✅ @Nullable/@NonNull annotations from JSpecify
* ✅ Lombok for boilerplate reduction
* ✅ Comprehensive Javadoc with examples
* ✅ Optional return types instead of null
* ✅ Fail-secure error handling
