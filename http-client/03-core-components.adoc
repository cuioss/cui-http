= Core Components Specification
:toc: left
:toclevels: 3
:sectnums:

== Overview

This document provides complete specifications for all core components introduced in the HTTP method extension.

== HttpMethod Enum

*Package:* `de.cuioss.http.client`

*Purpose:* Type-safe HTTP method representation with integrated request building.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client;

/**
 * HTTP methods with type-safe request building and sending.
 *
 * @since 1.0
 */
public enum HttpMethod {
    GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS;

    /**
     * Returns the HTTP method name (uppercase).
     */
    public String methodName() {
        return name();
    }

    /**
     * Sends request without body using the provided adapter.
     */
    public <T> HttpResult<T> send(HttpAdapter<T> adapter) {
        return send(adapter, Map.of());
    }

    /**
     * Sends request without body with additional headers.
     */
    public <T> HttpResult<T> send(HttpAdapter<T> adapter,
                                   Map<String, String> additionalHeaders) {
        return adapter.send(this, HttpRequestBodyPublisher.noBody(), null, additionalHeaders);
    }

    /**
     * Sends request with body using the provided adapter.
     */
    public <T, R> HttpResult<T> send(HttpAdapter<T> adapter,
                                      HttpRequestBodyPublisher<R> bodyPublisher,
                                      @Nullable R requestBody) {
        return adapter.send(this, bodyPublisher, requestBody, Map.of());
    }

    /**
     * Sends request with body and additional headers.
     */
    public <T, R> HttpResult<T> send(HttpAdapter<T> adapter,
                                      HttpRequestBodyPublisher<R> bodyPublisher,
                                      @Nullable R requestBody,
                                      Map<String, String> additionalHeaders) {
        return adapter.send(this, bodyPublisher, requestBody, additionalHeaders);
    }
}
----

=== Key Features

* Type-safe enum (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS)
* Convenience `send()` methods for fluent API (delegates to HttpAdapter)
* Support for additional headers (If-None-Match, Authorization, etc.)
* No direct HttpRequest.Builder exposure (adapters handle that internally)

**Design Note:** HttpMethod does NOT provide `buildRequest()` methods. Request building is handled internally by HttpAdapter implementations. This encapsulation:

* Prevents misuse of raw HttpRequest.Builder
* Ensures consistent header handling (Content-Type, If-None-Match)
* Maintains adapter abstraction
* Simplifies client code

=== Usage Patterns

[source,java]
----
// Direct send (no body)
HttpResult<User> result = HttpMethod.GET.send(adapter);

// Send with body
HttpResult<User> result = HttpMethod.POST.send(
    adapter,
    HttpRequestBodyPublisher.json(),
    jsonBody
);

// With custom headers
HttpResult<User> result = HttpMethod.GET.send(
    adapter,
    Map.of("Authorization", "Bearer " + token)
);
----

== CacheKeyHeaders Enum

*Package:* `de.cuioss.http.client.adapter`

*Purpose:* Configure which headers are included in ETag cache keys.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client.adapter;

/**
 * Strategy for including HTTP headers in ETag cache keys.
 *
 * <p>Cache keys uniquely identify cached responses. Including headers
 * creates separate cache entries per header combination, excluding
 * headers shares cache entries across different header values.
 *
 * @since 1.0
 */
public enum CacheKeyHeaders {
    /**
     * Include all additional headers in cache key (default).
     *
     * <p><b>Use when:</b>
     * <ul>
     *   <li>Adapter is shared across multiple users</li>
     *   <li>Headers affect response content (Authorization, Accept-Language)</li>
     *   <li>You want defense-in-depth against buggy server ETags</li>
     * </ul>
     *
     * <p><b>Benefits:</b>
     * <ul>
     *   <li>Safe for multi-user scenarios (no cross-user cache pollution)</li>
     *   <li>Efficient: Avoids wasted If-None-Match requests when ETags won't match</li>
     *   <li>Defense against server ETag bugs (user-agnostic ETags)</li>
     * </ul>
     *
     * <p><b>Drawback:</b>
     * <ul>
     *   <li>Token refresh creates duplicate cache entries (cache bloat)</li>
     * </ul>
     */
    ALL,

    /**
     * Exclude all headers from cache key (URI only).
     *
     * <p><b>Use ONLY when:</b>
     * <ul>
     *   <li>Adapter is NOT shared across users (single-user client)</li>
     *   <li>Server implements user-aware ETags correctly</li>
     *   <li>Headers don't affect response content (or server includes in ETag)</li>
     * </ul>
     *
     * <p><b>Benefits:</b>
     * <ul>
     *   <li>No cache bloat from token refresh</li>
     *   <li>Higher cache hit rate for same resource with varying headers</li>
     * </ul>
     *
     * <p><b>Risks:</b>
     * <ul>
     *   <li>In multi-user scenarios: Wasted bandwidth (ETag mismatches)</li>
     *   <li>Relies on server implementing user-aware ETags correctly</li>
     *   <li>May cache wrong content if server doesn't include header-dependent
     *       data in ETag (e.g., Accept-Language)</li>
     * </ul>
     *
     * <p><b>Example - Single User Client:</b>
     * <pre>{@code
     * // Mobile app, desktop app, or service account
     * HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
     *     .httpHandler(handler)
     *     .contentConverter(userConverter)
     *     .cacheKeyHeaders(CacheKeyHeaders.NONE)  // Safe: single user
     *     .build();
     * }</pre>
     *
     * <p><b>Example - Multi-User Server (UNSAFE):</b>
     * <pre>{@code
     * // Web API endpoint (BAD - don't do this!)
     * HttpAdapter<User> sharedAdapter = ETagAwareHttpAdapter.<User>builder()
     *     .httpHandler(handler)
     *     .contentConverter(userConverter)
     *     .cacheKeyHeaders(CacheKeyHeaders.NONE)  // ⚠️ UNSAFE: shared across users
     *     .build();
     *
     * // User A: GET /api/users/me → caches with key "/api/users/me"
     * // User B: GET /api/users/me → sends If-None-Match with User A's ETag
     * // Result: Server sends 200 (ETag mismatch) → wasted bandwidth
     * }</pre>
     */
    NONE;
}
----

=== Decision Guide

[cols="2,2,2"]
|===
|Scenario |Recommended Setting |Rationale

|Multi-user web server
|`CacheKeyHeaders.ALL`
|Separate cache per user, efficient If-None-Match

|Single-user mobile app
|`CacheKeyHeaders.NONE`
|No token refresh cache bloat

|Service account (one token)
|`CacheKeyHeaders.NONE`
|Token rarely changes

|Desktop application
|`CacheKeyHeaders.NONE`
|One user per app instance

|Multi-tenant SaaS
|`CacheKeyHeaders.ALL`
|Defense against cross-tenant leakage

|Per-user adapter instances
|`CacheKeyHeaders.NONE`
|Already isolated per user
|===

== ContentType Enum

*Package:* `de.cuioss.http.client`

*Purpose:* Type-safe MIME type representation with charset support.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Optional;

/**
 * Type-safe content types (MIME types) with charset support.
 *
 * @since 1.0
 */
public enum ContentType {
    APPLICATION_JSON("application/json", StandardCharsets.UTF_8),
    APPLICATION_XML("application/xml", StandardCharsets.UTF_8),
    TEXT_PLAIN("text/plain", StandardCharsets.UTF_8),
    TEXT_HTML("text/html", StandardCharsets.UTF_8),
    TEXT_XML("text/xml", StandardCharsets.UTF_8),
    TEXT_CSV("text/csv", StandardCharsets.UTF_8),
    APPLICATION_FORM_URLENCODED("application/x-www-form-urlencoded", StandardCharsets.UTF_8),
    MULTIPART_FORM_DATA("multipart/form-data", null),
    APPLICATION_OCTET_STREAM("application/octet-stream", null),
    APPLICATION_PDF("application/pdf", null),
    APPLICATION_ZIP("application/zip", null),
    IMAGE_PNG("image/png", null),
    IMAGE_JPEG("image/jpeg", null),
    IMAGE_GIF("image/gif", null),
    IMAGE_SVG("image/svg+xml", StandardCharsets.UTF_8);

    private final String mediaType;
    private final Charset defaultCharset;

    ContentType(String mediaType, Charset defaultCharset) {
        this.mediaType = mediaType;
        this.defaultCharset = defaultCharset;
    }

    /**
     * Returns the media type (e.g., "application/json").
     */
    public String mediaType() {
        return mediaType;
    }

    /**
     * Returns the default charset for this content type.
     */
    public Optional<Charset> defaultCharset() {
        return Optional.ofNullable(defaultCharset);
    }

    /**
     * Returns the complete Content-Type header value with charset if applicable.
     * Example: "application/json; charset=UTF-8"
     */
    public String toHeaderValue() {
        if (defaultCharset != null) {
            return mediaType + "; charset=" + defaultCharset.name();
        }
        return mediaType;
    }
}
----

=== Supported Types

* **JSON**: `APPLICATION_JSON`
* **Text**: `TEXT_PLAIN`, `TEXT_HTML`, `TEXT_CSV`
* **XML**: `APPLICATION_XML`, `TEXT_XML`
* **Form**: `APPLICATION_FORM_URLENCODED`, `MULTIPART_FORM_DATA`
* **Binary**: `APPLICATION_OCTET_STREAM`, `APPLICATION_PDF`, `APPLICATION_ZIP`
* **Images**: `IMAGE_PNG`, `IMAGE_JPEG`, `IMAGE_GIF`, `IMAGE_SVG`

=== Key Methods

[source,java]
----
String mediaType();              // "application/json"
Optional<Charset> defaultCharset(); // UTF_8
String toHeaderValue();          // "application/json; charset=UTF-8"
----

== HttpAdapter Interface

*Package:* `de.cuioss.http.client.adapter`

*Purpose:* Common interface for all HTTP adapters.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client.adapter;

/**
 * Adapter for sending HTTP requests and receiving structured results.
 * Enables composition of cross-cutting concerns (retry, authentication).
 *
 * @param <T> Response body type (defined by HttpContentConverter)
 * @since 1.0
 */
@FunctionalInterface
public interface HttpAdapter<T> {
    /**
     * Sends HTTP request with specified method, body, and headers.
     *
     * @param <R> Request body type (defined by HttpRequestBodyPublisher)
     * @param method HTTP method to use
     * @param bodyPublisher Publisher for request body
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing response or error information
     */
    <R> HttpResult<T> send(HttpMethod method,
                           HttpRequestBodyPublisher<R> bodyPublisher,
                           @Nullable R requestBody,
                           Map<String, String> additionalHeaders);

    /**
     * Convenience: Send without additional headers.
     */
    default <R> HttpResult<T> send(HttpMethod method,
                                   HttpRequestBodyPublisher<R> bodyPublisher,
                                   @Nullable R requestBody) {
        return send(method, bodyPublisher, requestBody, Map.of());
    }
}
----

=== Design Rationale

* Enables composition (retry, auth, metrics)
* Extensible through composition
* Easy to mock for testing
* Consistent contract across implementations

== HttpRequestBodyPublisher

*Package:* `de.cuioss.http.client.request`

*Purpose:* Convert typed objects to HTTP request bodies (mirrors `HttpContentConverter`).

=== Interface Definition

[source,java]
----
package de.cuioss.http.client.request;

import de.cuioss.http.client.ContentType;
import java.net.http.HttpRequest;
import org.jspecify.annotations.Nullable;

/**
 * Converts typed request objects to HTTP request body publishers.
 * Mirrors {@link HttpContentConverter} for request bodies.
 *
 * @param <T> The type of request body content
 * @since 1.0
 */
public interface HttpRequestBodyPublisher<T> {
    /**
     * Converts typed content to HttpRequest.BodyPublisher.
     *
     * @param content The content to publish, may be null for no-body requests
     * @return BodyPublisher for the HTTP request
     */
    HttpRequest.BodyPublisher toBodyPublisher(@Nullable T content);

    /**
     * Returns the content type for this publisher.
     */
    ContentType contentType();

    /**
     * Creates a no-body publisher (for GET, DELETE, HEAD).
     */
    static HttpRequestBodyPublisher<Void> noBody() {
        return NoBodyPublisher.INSTANCE;
    }

    /**
     * Creates a JSON body publisher with UTF-8 encoding.
     */
    static HttpRequestBodyPublisher<String> json() {
        return new StringBodyPublisher(ContentType.APPLICATION_JSON);
    }

    /**
     * Creates a plain text body publisher with UTF-8 encoding.
     */
    static HttpRequestBodyPublisher<String> plainText() {
        return new StringBodyPublisher(ContentType.TEXT_PLAIN);
    }

    /**
     * Creates an XML body publisher with UTF-8 encoding.
     */
    static HttpRequestBodyPublisher<String> xml() {
        return new StringBodyPublisher(ContentType.APPLICATION_XML);
    }

    /**
     * Creates a string body publisher with specified content type.
     */
    static HttpRequestBodyPublisher<String> ofString(ContentType contentType) {
        return new StringBodyPublisher(contentType);
    }

    /**
     * Creates a byte array body publisher with specified content type.
     */
    static HttpRequestBodyPublisher<byte[]> ofByteArray(ContentType contentType) {
        return new ByteArrayBodyPublisher(contentType);
    }
}
----

=== Implementations

==== NoBodyPublisher

[source,java]
----
final class NoBodyPublisher implements HttpRequestBodyPublisher<Void> {
    static final NoBodyPublisher INSTANCE = new NoBodyPublisher();

    private NoBodyPublisher() {}

    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable Void content) {
        return HttpRequest.BodyPublishers.noBody();
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_OCTET_STREAM; // Not used for no-body
    }
}
----

==== StringBodyPublisher

[source,java]
----
final class StringBodyPublisher implements HttpRequestBodyPublisher<String> {
    private final ContentType contentType;

    StringBodyPublisher(ContentType contentType) {
        this.contentType = Objects.requireNonNull(contentType, "contentType");
    }

    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable String content) {
        if (content == null || content.isEmpty()) {
            return HttpRequest.BodyPublishers.noBody();
        }
        Charset charset = contentType.defaultCharset().orElse(StandardCharsets.UTF_8);
        return HttpRequest.BodyPublishers.ofString(content, charset);
    }

    @Override
    public ContentType contentType() {
        return contentType;
    }
}
----

==== ByteArrayBodyPublisher

[source,java]
----
final class ByteArrayBodyPublisher implements HttpRequestBodyPublisher<byte[]> {
    private final ContentType contentType;

    ByteArrayBodyPublisher(ContentType contentType) {
        this.contentType = Objects.requireNonNull(contentType, "contentType");
    }

    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable byte[] content) {
        if (content == null || content.length == 0) {
            return HttpRequest.BodyPublishers.noBody();
        }
        return HttpRequest.BodyPublishers.ofByteArray(content);
    }

    @Override
    public ContentType contentType() {
        return contentType;
    }
}
----

=== Factory Methods

[source,java]
----
HttpRequestBodyPublisher.noBody()              // GET, DELETE
HttpRequestBodyPublisher.json()                // JSON with UTF-8
HttpRequestBodyPublisher.plainText()           // Plain text
HttpRequestBodyPublisher.xml()                 // XML
HttpRequestBodyPublisher.ofString(ContentType) // Custom text type
HttpRequestBodyPublisher.ofByteArray(ContentType) // Binary data
----

== HttpErrorCategory (Updated)

*Package:* `de.cuioss.http.client.result`

*Purpose:* Classify failures for retry decisions.

=== Updated Enum

[source,java]
----
public enum HttpErrorCategory {
    NETWORK_ERROR,      // IOException - RETRYABLE
    SERVER_ERROR,       // 5xx - RETRYABLE
    CLIENT_ERROR,       // 4xx - NOT retryable
    INVALID_CONTENT,    // Parsing failed - NOT retryable
    CONFIGURATION_ERROR; // SSL, URI configuration issues - NOT retryable

    public boolean isRetryable() {
        return this == NETWORK_ERROR || this == SERVER_ERROR;
    }
}
----

*Note on 3xx Redirects:*

* Most 3xx are followed automatically by `HttpClient`
* 304 Not Modified is handled as application-level success by `ETagAwareHttpAdapter`
* No separate REDIRECTION category needed

== HttpStatusFamily (Updated)

*Package:* `de.cuioss.http.client.handler`

*Purpose:* HTTP protocol-level status classification.

=== New Method: toErrorCategory()

[source,java]
----
/**
 * Converts HTTP status family to error category for retry decisions.
 * Note: REDIRECTION is handled specially by ETagAwareHttpAdapter.
 */
public HttpErrorCategory toErrorCategory() {
    return switch (this) {
        case CLIENT_ERROR -> HttpErrorCategory.CLIENT_ERROR;
        case SERVER_ERROR -> HttpErrorCategory.SERVER_ERROR;
        case SUCCESS -> throw new IllegalStateException(
            "SUCCESS is not an error");
        case REDIRECTION -> HttpErrorCategory.INVALID_CONTENT;  // Rare, handled by adapter
        case INFORMATIONAL, UNKNOWN -> HttpErrorCategory.INVALID_CONTENT;
    };
}
----

*Notes:*

* Most 3xx redirects are followed automatically by `HttpClient`
* 304 Not Modified is intercepted by `ETagAwareHttpAdapter` (never reaches error categorization)
* Other 3xx are rare in modern HTTP and mapped to `INVALID_CONTENT`

== HttpContentConverter (Updated)

*Package:* `de.cuioss.http.client.converter`

*Purpose:* Convert HTTP response bodies to typed objects.

=== Breaking Changes

[source,java]
----
public interface HttpContentConverter<T> {
    Optional<T> convert(Object rawContent);
    HttpResponse.BodyHandler<?> getBodyHandler();

    // REMOVED: T emptyValue();
    // ADDED:
    ContentType expectedContentType();
}
----

=== Migration

[source,java]
----
// OLD
@Override
public User emptyValue() {
    return new User();  // Remove this
}

// NEW
@Override
public ContentType expectedContentType() {
    return ContentType.APPLICATION_JSON;  // Add this
}
----

== Module Exports

*File:* `src/main/java/module-info.java`

=== New Exports

[source,java]
----
module de.cuioss.http {
    // ... existing requires

    // Existing exports
    exports de.cuioss.http.client;
    exports de.cuioss.http.client.handler;
    exports de.cuioss.http.client.converter;
    exports de.cuioss.http.client.result;
    exports de.cuioss.http.client.retry;

    // NEW exports
    exports de.cuioss.http.client.adapter;
    exports de.cuioss.http.client.request;

    // ... security exports
}
----

== Summary

All core components follow CUI standards:

* ✅ Immutable, thread-safe design
* ✅ Builder patterns where appropriate
* ✅ @Nullable/@NonNull annotations from JSpecify
* ✅ Lombok for boilerplate reduction
* ✅ Comprehensive Javadoc with examples
* ✅ Optional return types instead of null
* ✅ Fail-secure error handling
