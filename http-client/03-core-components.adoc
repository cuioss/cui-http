= Core Components Specification
:toc: left
:toc-title: Table of Contents
:toclevels: 3
:sectnums:
:source-highlighter: highlight.js

== Overview

This document provides complete specifications for all core components introduced in the HTTP method extension.

== CacheKeyHeaderFilter Interface

*Package:* `de.cuioss.http.client.adapter`

*Purpose:* Fine-grained control over which HTTP headers are included in ETag cache keys using functional predicates.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client.adapter;

import java.util.Set;
import java.util.function.Predicate;

/**
 * Strategy for determining which HTTP headers should be included in cache keys.
 *
 * <p>Headers included in cache keys create separate cache entries per header
 * combination. Headers excluded from cache keys allow cache sharing across
 * different header values.
 *
 * <p>This functional interface allows fine-grained control beyond simple all-or-nothing
 * choices, solving the token refresh cache bloat problem while maintaining security.
 *
 * @since 1.0
 */
@FunctionalInterface
public interface CacheKeyHeaderFilter {

    /**
     * Determines if the given header should be included in the cache key.
     *
     * @param headerName The HTTP header name (case-insensitive)
     * @return true if header should be included in cache key, false otherwise
     */
    boolean includeInCacheKey(String headerName);

    // ========== PRESET FILTERS ==========

    /**
     * Include all headers in cache key (default, safest).
     *
     * <p><b>Use when:</b>
     * <ul>
     *   <li>Adapter is shared across multiple users</li>
     *   <li>Headers affect response content</li>
     *   <li>Defense-in-depth against server ETag bugs</li>
     * </ul>
     *
     * <p><b>Trade-off:</b> Token refresh creates cache bloat
     */
    CacheKeyHeaderFilter ALL = header -> true;

    /**
     * Exclude all headers from cache key (URI only).
     *
     * <p><b>Use ONLY when:</b>
     * <ul>
     *   <li>Single-user client (not shared)</li>
     *   <li>Server implements user-aware ETags</li>
     * </ul>
     *
     * <p><b>Risk:</b> Multi-user scenarios may cache wrong content
     */
    CacheKeyHeaderFilter NONE = header -> false;

    // ========== FACTORY METHODS ==========

    /**
     * Exclude specific headers from cache key, include all others.
     *
     * <p><b>Solves token refresh cache bloat</b> by excluding Authorization
     * while keeping content-affecting headers like Accept-Language.
     *
     * <p>Example:
     * <pre>{@code
     * // Exclude frequently-changing headers, include others
     * .cacheKeyHeaderFilter(CacheKeyHeaderFilter.excluding(
     *     "Authorization", "X-Request-ID", "X-Trace-ID"
     * ))
     * }</pre>
     *
     * @param headerNames Case-insensitive header names to exclude
     * @return Filter that includes all headers except specified ones
     */
    static CacheKeyHeaderFilter excluding(String... headerNames) {
        Set<String> excluded = Set.of(headerNames).stream()
            .map(String::toLowerCase)
            .collect(java.util.stream.Collectors.toSet());
        return header -> !excluded.contains(header.toLowerCase());
    }

    /**
     * Include only specific headers in cache key, exclude all others.
     *
     * <p><b>Whitelist approach</b> for precise control over cache key composition.
     *
     * <p>Example:
     * <pre>{@code
     * // Include only content-affecting headers
     * .cacheKeyHeaderFilter(CacheKeyHeaderFilter.including(
     *     "Accept-Language", "Accept-Encoding"
     * ))
     * }</pre>
     *
     * @param headerNames Case-insensitive header names to include
     * @return Filter that includes only specified headers
     */
    static CacheKeyHeaderFilter including(String... headerNames) {
        Set<String> included = Set.of(headerNames).stream()
            .map(String::toLowerCase)
            .collect(java.util.stream.Collectors.toSet());
        return header -> included.contains(header.toLowerCase());
    }

    /**
     * Exclude headers matching a prefix (case-insensitive).
     *
     * <p>Example:
     * <pre>{@code
     * // Exclude all X- headers (trace IDs, custom headers)
     * .cacheKeyHeaderFilter(CacheKeyHeaderFilter.excludingPrefix("X-"))
     * }</pre>
     *
     * @param prefix Case-insensitive prefix to match
     * @return Filter that excludes headers starting with prefix
     */
    static CacheKeyHeaderFilter excludingPrefix(String prefix) {
        String lowerPrefix = prefix.toLowerCase();
        return header -> !header.toLowerCase().startsWith(lowerPrefix);
    }

    /**
     * Custom predicate-based filter for complex logic.
     *
     * <p>Example:
     * <pre>{@code
     * .cacheKeyHeaderFilter(CacheKeyHeaderFilter.matching(
     *     header -> !header.startsWith("X-") && !header.equals("Authorization")
     * ))
     * }</pre>
     *
     * @param predicate Custom header inclusion logic
     * @return Filter using the predicate
     */
    static CacheKeyHeaderFilter matching(Predicate<String> predicate) {
        return predicate::test;
    }

    // ========== COMPOSITION ==========

    /**
     * Combines this filter with another using logical AND.
     * Header is included only if both filters return true.
     *
     * <p>Example:
     * <pre>{@code
     * CacheKeyHeaderFilter filter = CacheKeyHeaderFilter
     *     .excluding("Authorization")
     *     .and(CacheKeyHeaderFilter.excludingPrefix("X-"));
     * }</pre>
     */
    default CacheKeyHeaderFilter and(CacheKeyHeaderFilter other) {
        return header -> this.includeInCacheKey(header) && other.includeInCacheKey(header);
    }

    /**
     * Combines this filter with another using logical OR.
     * Header is included if either filter returns true.
     */
    default CacheKeyHeaderFilter or(CacheKeyHeaderFilter other) {
        return header -> this.includeInCacheKey(header) || other.includeInCacheKey(header);
    }

    /**
     * Negates this filter.
     *
     * <p>Example:
     * <pre>{@code
     * // Include all EXCEPT Accept-Language
     * CacheKeyHeaderFilter.including("Accept-Language").negate()
     * }</pre>
     */
    default CacheKeyHeaderFilter negate() {
        return header -> !this.includeInCacheKey(header);
    }
}
----

=== Common Use Cases

[cols="2,3,2"]
|===
|Scenario |Filter Configuration |Rationale

|Multi-user web server (default)
|`CacheKeyHeaderFilter.ALL`
|Safe: separate cache per user

|Single-user mobile app
|`CacheKeyHeaderFilter.NONE`
|No token refresh cache bloat

|Token refresh cache bloat fix
|`CacheKeyHeaderFilter.excluding("Authorization")`
|**Best of both worlds**: keeps Accept-Language, excludes Auth

|Service account
|`CacheKeyHeaderFilter.NONE`
|Token rarely changes

|Content negotiation only
|`CacheKeyHeaderFilter.including("Accept-Language", "Accept-Encoding")`
|Precise control over cache keys

|Exclude debug/trace headers
|`CacheKeyHeaderFilter.excludingPrefix("X-")`
|Clean cache keys without noise

|Multi-tenant SaaS
|`CacheKeyHeaderFilter.ALL`
|Defense against cross-tenant leakage

|Complex requirements
|`CacheKeyHeaderFilter.matching(header -> ...)`
|Full custom logic
|===

=== Usage Examples

==== Example 1: Solve Token Refresh Cache Bloat

[source,java]
----
// Problem: ALL causes cache bloat on token refresh
// Solution: Exclude Authorization, keep content-affecting headers
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .cacheKeyHeaderFilter(CacheKeyHeaderFilter.excluding("Authorization"))
    .build();

// Now:
// - Accept-Language IS included → separate cache per language ✓
// - Authorization NOT included → token refresh doesn't bloat cache ✓
----

==== Example 2: Exclude All Trace Headers

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .cacheKeyHeaderFilter(
        CacheKeyHeaderFilter.excludingPrefix("X-")
            .and(CacheKeyHeaderFilter.excluding("Authorization"))
    )
    .build();
----

==== Example 3: Whitelist Content Headers Only

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .cacheKeyHeaderFilter(CacheKeyHeaderFilter.including(
        "Accept-Language",
        "Accept-Encoding",
        "Accept-Charset"
    ))
    .build();
----

==== Example 4: Custom Logic

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .cacheKeyHeaderFilter(CacheKeyHeaderFilter.matching(header -> {
        // Include Accept-* headers
        if (header.startsWith("Accept-")) return true;
        // Exclude auth and trace headers
        if (header.equals("Authorization")) return false;
        if (header.startsWith("X-")) return false;
        // Include everything else
        return true;
    }))
    .build();
----

=== Migration from Binary Choice

The old all-or-nothing approach had limitations:

[source,java]
----
// OLD: Binary choice (cache bloat OR potential mismatches)
// .cacheKeyHeaderFilter(CacheKeyHeaderFilter.ALL)   // Problem: token refresh bloat
// .cacheKeyHeaderFilter(CacheKeyHeaderFilter.NONE)  // Problem: multi-user risks

// NEW: Fine-grained control (best of both worlds)
.cacheKeyHeaderFilter(CacheKeyHeaderFilter.excluding("Authorization"))

// Or use presets for simple cases
.cacheKeyHeaderFilter(CacheKeyHeaderFilter.ALL)   // Same as old ALL
.cacheKeyHeaderFilter(CacheKeyHeaderFilter.NONE)  // Same as old NONE
----

== ContentType Enum

*Package:* `de.cuioss.http.client`

*Purpose:* Type-safe MIME type representation with charset support.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Optional;

/**
 * Type-safe content types (MIME types) with charset support.
 *
 * @since 1.0
 */
public enum ContentType {
    APPLICATION_JSON("application/json", StandardCharsets.UTF_8),
    APPLICATION_XML("application/xml", StandardCharsets.UTF_8),
    TEXT_PLAIN("text/plain", StandardCharsets.UTF_8),
    TEXT_HTML("text/html", StandardCharsets.UTF_8),
    TEXT_XML("text/xml", StandardCharsets.UTF_8),
    TEXT_CSV("text/csv", StandardCharsets.UTF_8),
    APPLICATION_FORM_URLENCODED("application/x-www-form-urlencoded", StandardCharsets.UTF_8),
    MULTIPART_FORM_DATA("multipart/form-data", null),
    APPLICATION_OCTET_STREAM("application/octet-stream", null),
    APPLICATION_PDF("application/pdf", null),
    APPLICATION_ZIP("application/zip", null),
    IMAGE_PNG("image/png", null),
    IMAGE_JPEG("image/jpeg", null),
    IMAGE_GIF("image/gif", null),
    IMAGE_SVG("image/svg+xml", StandardCharsets.UTF_8);

    private final String mediaType;
    private final Charset defaultCharset;

    ContentType(String mediaType, Charset defaultCharset) {
        this.mediaType = mediaType;
        this.defaultCharset = defaultCharset;
    }

    /**
     * Returns the media type (e.g., "application/json").
     */
    public String mediaType() {
        return mediaType;
    }

    /**
     * Returns the default charset for this content type.
     */
    public Optional<Charset> defaultCharset() {
        return Optional.ofNullable(defaultCharset);
    }

    /**
     * Returns the complete Content-Type header value with charset if applicable.
     * Example: "application/json; charset=UTF-8"
     */
    public String toHeaderValue() {
        if (defaultCharset != null) {
            return mediaType + "; charset=" + defaultCharset.name();
        }
        return mediaType;
    }
}
----

=== Supported Types

* **JSON**: `APPLICATION_JSON`
* **Text**: `TEXT_PLAIN`, `TEXT_HTML`, `TEXT_CSV`
* **XML**: `APPLICATION_XML`, `TEXT_XML`
* **Form**: `APPLICATION_FORM_URLENCODED`, `MULTIPART_FORM_DATA`
* **Binary**: `APPLICATION_OCTET_STREAM`, `APPLICATION_PDF`, `APPLICATION_ZIP`
* **Images**: `IMAGE_PNG`, `IMAGE_JPEG`, `IMAGE_GIF`, `IMAGE_SVG`

=== Key Methods

[source,java]
----
String mediaType();              // "application/json"
Optional<Charset> defaultCharset(); // UTF_8
String toHeaderValue();          // "application/json; charset=UTF-8"
----

== HttpAdapter Interface

*Package:* `de.cuioss.http.client.adapter`

*Purpose:* Common interface for all HTTP adapters providing method-specific operations.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client.adapter;

import de.cuioss.http.client.result.HttpResult;
import de.cuioss.http.client.converter.HttpRequestConverter;
import org.jspecify.annotations.Nullable;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * Adapter for sending HTTP requests and receiving structured results.
 * Provides method-specific operations following HTTP semantics.
 *
 * <p><b>Async-First Design:</b> All methods return {@code CompletableFuture<HttpResult<T>>}
 * for non-blocking operation. Use {@code .join()} or blocking convenience methods for
 * synchronous usage.
 *
 * <p>The adapter is configured with a HttpResponseConverter<T> for responses.
 * Request bodies can be sent using:
 * <ul>
 *   <li>Same type T (if adapter has request converter configured)</li>
 *   <li>Different type R with explicit HttpRequestConverter<R></li>
 * </ul>
 *
 * @param <T> Response body type
 * @since 1.0
 */
public interface HttpAdapter<T> {

    // ========== NO-BODY METHODS (ASYNC) ==========

    /**
     * Sends GET request to retrieve resource (async).
     * GET requests do not have a body (RFC 7231).
     *
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with response or error information
     */
    CompletableFuture<HttpResult<T>> get(Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> get() { return get(Map.of()); }

    /**
     * Sends HEAD request to retrieve headers only (async, no body in response).
     *
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with response metadata
     */
    CompletableFuture<HttpResult<T>> head(Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> head() { return head(Map.of()); }

    /**
     * Sends OPTIONS request to query supported methods (async).
     *
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with server capabilities
     */
    CompletableFuture<HttpResult<T>> options(Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> options() { return options(Map.of()); }

    /**
     * Sends DELETE request to remove resource (async, no body).
     * Most DELETE requests don't have a body.
     *
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with response or error information
     */
    CompletableFuture<HttpResult<T>> delete(Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> delete() { return delete(Map.of()); }

    // ========== BODY METHODS (T → T, uses configured request converter) ==========

    /**
     * Sends POST request with body of type T (async).
     * Requires adapter to have a request converter configured for type T.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with created resource or error
     * @throws IllegalStateException if no request converter configured for type T
     */
    CompletableFuture<HttpResult<T>> post(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> post(@Nullable T requestBody) { return post(requestBody, Map.of()); }

    /**
     * Sends PUT request with body of type T (async).
     * Requires adapter to have a request converter configured for type T.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with updated resource or error
     * @throws IllegalStateException if no request converter configured for type T
     */
    CompletableFuture<HttpResult<T>> put(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> put(@Nullable T requestBody) { return put(requestBody, Map.of()); }

    /**
     * Sends PATCH request with body of type T (async).
     * Requires adapter to have a request converter configured for type T.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with updated resource or error
     * @throws IllegalStateException if no request converter configured for type T
     */
    CompletableFuture<HttpResult<T>> patch(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> patch(@Nullable T requestBody) { return patch(requestBody, Map.of()); }

    /**
     * Sends DELETE request with body of type T (async).
     * Requires adapter to have a request converter configured for type T.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with response or error
     * @throws IllegalStateException if no request converter configured for type T
     */
    CompletableFuture<HttpResult<T>> delete(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default CompletableFuture<HttpResult<T>> delete(@Nullable T requestBody) {
        return delete(requestBody, Map.of());
    }

    // ========== BODY METHODS (R → T, explicit request converter) ==========

    /**
     * Sends POST request with explicit request converter for different type (async).
     * Use when request type differs from response type.
     *
     * @param <R> Request body type
     * @param requestConverter Converter for request body serialization
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with created resource (type T) or error
     */
    <R> CompletableFuture<HttpResult<T>> post(HttpRequestConverter<R> requestConverter,
                           @Nullable R requestBody,
                           Map<String, String> additionalHeaders);
    default <R> CompletableFuture<HttpResult<T>> post(HttpRequestConverter<R> requestConverter,
                                   @Nullable R requestBody) {
        return post(requestConverter, requestBody, Map.of());
    }

    /**
     * Sends PUT request with explicit request converter for different type (async).
     *
     * @param <R> Request body type
     * @param requestConverter Converter for request body serialization
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with updated resource (type T) or error
     */
    <R> CompletableFuture<HttpResult<T>> put(HttpRequestConverter<R> requestConverter,
                          @Nullable R requestBody,
                          Map<String, String> additionalHeaders);
    default <R> CompletableFuture<HttpResult<T>> put(HttpRequestConverter<R> requestConverter,
                                  @Nullable R requestBody) {
        return put(requestConverter, requestBody, Map.of());
    }

    /**
     * Sends PATCH request with explicit request converter for different type (async).
     *
     * @param <R> Request body type
     * @param requestConverter Converter for request body serialization
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with updated resource (type T) or error
     */
    <R> CompletableFuture<HttpResult<T>> patch(HttpRequestConverter<R> requestConverter,
                            @Nullable R requestBody,
                            Map<String, String> additionalHeaders);
    default <R> CompletableFuture<HttpResult<T>> patch(HttpRequestConverter<R> requestConverter,
                                    @Nullable R requestBody) {
        return patch(requestConverter, requestBody, Map.of());
    }

    /**
     * Sends DELETE request with explicit request converter for different type (async).
     *
     * @param <R> Request body type
     * @param requestConverter Converter for request body serialization
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return CompletableFuture containing result with response or error
     */
    <R> CompletableFuture<HttpResult<T>> delete(HttpRequestConverter<R> requestConverter,
                            @Nullable R requestBody,
                            Map<String, String> additionalHeaders);
    default <R> CompletableFuture<HttpResult<T>> delete(HttpRequestConverter<R> requestConverter,
                                    @Nullable R requestBody) {
        return delete(requestConverter, requestBody, Map.of());
    }

    // ========== BLOCKING CONVENIENCE METHODS ==========

    /**
     * Blocking convenience method for GET.
     * Equivalent to {@code get().join()}.
     *
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing response or error information
     */
    default HttpResult<T> getBlocking(Map<String, String> additionalHeaders) {
        return get(additionalHeaders).join();
    }
    default HttpResult<T> getBlocking() { return get().join(); }

    /**
     * Blocking convenience method for POST.
     * Equivalent to {@code post(requestBody).join()}.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing created resource or error
     */
    default HttpResult<T> postBlocking(@Nullable T requestBody, Map<String, String> additionalHeaders) {
        return post(requestBody, additionalHeaders).join();
    }
    default HttpResult<T> postBlocking(@Nullable T requestBody) { return post(requestBody).join(); }

    /**
     * Blocking convenience method for PUT.
     * Equivalent to {@code put(requestBody).join()}.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing updated resource or error
     */
    default HttpResult<T> putBlocking(@Nullable T requestBody, Map<String, String> additionalHeaders) {
        return put(requestBody, additionalHeaders).join();
    }
    default HttpResult<T> putBlocking(@Nullable T requestBody) { return put(requestBody).join(); }

    /**
     * Blocking convenience method for DELETE.
     * Equivalent to {@code delete().join()}.
     *
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing response or error information
     */
    default HttpResult<T> deleteBlocking(Map<String, String> additionalHeaders) {
        return delete(additionalHeaders).join();
    }
    default HttpResult<T> deleteBlocking() { return delete().join(); }
}
----

=== Adapter Builder Configuration

[source,java]
----
// Response converter required
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userResponseConverter)  // Required
    .build();

// Response + request converters (for POST/PUT/PATCH with same type)
JsonConverter<User> converter = new JsonConverter<>(User.class);

HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(converter)  // Required
    .requestConverter(converter)    // Optional - same instance for same type
    .build();

// Or separate converters (different types)
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userResponseConverter)      // User
    .requestConverter(createUserRequestConverter)  // CreateUserRequest
    .build();

// Void adapter (status code only) - built-in convenience
HttpAdapter<Void> voidAdapter = ETagAwareHttpAdapter.statusCodeOnly(handler);
// Equivalent to:
// ETagAwareHttpAdapter.<Void>builder()
//     .httpHandler(handler)
//     .responseConverter(VoidResponseConverter.INSTANCE)
//     .build();
----

=== Convenience Factory Methods

[source,java]
----
package de.cuioss.http.client.adapter;

/**
 * Adapter builder and factory methods.
 */
public interface ETagAwareHttpAdapter<T> {

    /**
     * Creates builder for typed responses.
     */
    static <T> Builder<T> builder() {
        return new Builder<>();
    }

    /**
     * Convenience factory for status-code-only adapters.
     * Uses built-in VoidResponseConverter - no body parsing.
     *
     * <p>Use for DELETE, HEAD, health checks, webhooks, etc.
     *
     * @param httpHandler HTTP handler configuration
     * @return Adapter that only returns HTTP status codes
     */
    static HttpAdapter<Void> statusCodeOnly(HttpHandler httpHandler) {
        return ETagAwareHttpAdapter.<Void>builder()
            .httpHandler(httpHandler)
            .responseConverter(VoidResponseConverter.INSTANCE)
            .etagCachingEnabled(false)  // No caching for Void responses
            .build();
    }

    // ... other methods
}
----

**Usage:**

[source,java]
----
// DELETE endpoint - only care about status
HttpAdapter<Void> deleteAdapter = ETagAwareHttpAdapter.statusCodeOnly(
    HttpHandler.builder()
        .uri("https://api.example.com/users/123")
        .build()
);

HttpResult<Void> result = deleteAdapter.delete();
if (result.isSuccess()) {
    LOGGER.info("User deleted successfully");
}

// Health check endpoint
HttpAdapter<Void> healthCheck = ETagAwareHttpAdapter.statusCodeOnly(
    HttpHandler.builder()
        .uri("https://api.example.com/health")
        .build()
);

boolean isHealthy = healthCheck.head().isSuccess();

// Webhook POST (fire and forget)
HttpAdapter<Void> webhook = ETagAwareHttpAdapter.statusCodeOnly(
    HttpHandler.builder()
        .uri("https://webhook.example.com/events")
        .build()
);

WebhookEvent event = new WebhookEvent("user.created", data);
HttpResult<Void> sent = webhook.post(
    new JsonRequestConverter<>(WebhookEvent.class),
    event
);
----

=== Design Rationale

* **Separate concerns** - Request and response conversion are independent responsibilities
* **Single responsibility** - Each converter does one thing well
* **Composable** - Mix different request/response converters as needed
* **Type flexibility** - POST `CreateUserRequest` → returns `User` cleanly supported
* **Optional implementations** - Only implement what you need (GET-only? Just response converter)
* **Same type support** - Use same instance for both converters when request/response share type
* **Method-specific APIs** - Clear intent, follows HTTP semantics
* **RFC compliant** - GET/HEAD/OPTIONS have no body methods
* **Type-safe** - Compiler enforces correct usage
* **Enables composition** - Can wrap adapters for retry, auth, metrics
* **Self-documenting** - Method signatures clearly show what's needed

== HttpErrorCategory

*Package:* `de.cuioss.http.client.result`

*Purpose:* Classify failures for retry decisions.

=== Enum Definition

[source,java]
----
public enum HttpErrorCategory {
    NETWORK_ERROR,      // IOException - RETRYABLE
    SERVER_ERROR,       // 5xx - RETRYABLE
    CLIENT_ERROR,       // 4xx - NOT retryable
    INVALID_CONTENT,    // Parsing failed - NOT retryable
    CONFIGURATION_ERROR; // SSL, URI configuration issues - NOT retryable

    public boolean isRetryable() {
        return this == NETWORK_ERROR || this == SERVER_ERROR;
    }
}
----

*Note on 3xx Redirects:*

* Most 3xx are followed automatically by `HttpClient`
* 304 Not Modified is handled as application-level success by `ETagAwareHttpAdapter`
* No separate REDIRECTION category needed

== HttpStatusFamily

*Package:* `de.cuioss.http.client.handler`

*Purpose:* HTTP protocol-level status classification.

=== Error Category Conversion

[source,java]
----
/**
 * Converts HTTP status family to error category for retry decisions.
 * Note: REDIRECTION is handled specially by ETagAwareHttpAdapter.
 */
public HttpErrorCategory toErrorCategory() {
    return switch (this) {
        case CLIENT_ERROR -> HttpErrorCategory.CLIENT_ERROR;
        case SERVER_ERROR -> HttpErrorCategory.SERVER_ERROR;
        case SUCCESS -> throw new IllegalStateException(
            "SUCCESS is not an error");
        case REDIRECTION -> HttpErrorCategory.INVALID_CONTENT;  // Rare, handled by adapter
        case INFORMATIONAL, UNKNOWN -> HttpErrorCategory.INVALID_CONTENT;
    };
}
----

*Notes:*

* Most 3xx redirects are followed automatically by `HttpClient`
* 304 Not Modified is intercepted by `ETagAwareHttpAdapter` (never reaches error categorization)
* Other 3xx are rare in modern HTTP and mapped to `INVALID_CONTENT`

== Converter Interfaces (Redesigned)

*Package:* `de.cuioss.http.client.converter`

*Purpose:* Separate, composable converters for requests and responses with optional convenience interface.

=== HttpResponseConverter Interface

Handles HTTP response → typed object conversion.

[source,java]
----
package de.cuioss.http.client.converter;

import de.cuioss.http.client.ContentType;
import java.net.http.HttpResponse;
import java.util.Optional;

/**
 * Converts HTTP response bodies to typed objects.
 *
 * @param <T> Response body type
 * @since 1.0
 */
public interface HttpResponseConverter<T> {

    /**
     * Converts HTTP response body to typed object.
     *
     * @param rawContent Raw response content from HTTP response
     * @return Converted object, or empty if conversion failed
     */
    Optional<T> convert(Object rawContent);

    /**
     * Returns body handler for HTTP response processing.
     *
     * @return BodyHandler appropriate for this content type
     */
    HttpResponse.BodyHandler<?> getBodyHandler();

    /**
     * Returns the expected content type for responses.
     *
     * @return Content type (e.g., APPLICATION_JSON, TEXT_XML)
     */
    ContentType contentType();
}
----

=== HttpRequestConverter Interface

Handles typed object → HTTP request body conversion.

[source,java]
----
package de.cuioss.http.client.converter;

import de.cuioss.http.client.ContentType;
import java.net.http.HttpRequest;
import org.jspecify.annotations.Nullable;

/**
 * Converts typed objects to HTTP request bodies.
 *
 * @param <R> Request body type
 * @since 1.0
 */
public interface HttpRequestConverter<R> {

    /**
     * Converts typed object to HTTP request body publisher.
     *
     * <p>If content is null, implementations should return a no-body publisher.
     *
     * @param content The content to serialize, may be null
     * @return BodyPublisher for the HTTP request
     */
    HttpRequest.BodyPublisher toBodyPublisher(@Nullable R content);

    /**
     * Returns the content type for requests.
     *
     * @return Content type (e.g., APPLICATION_JSON, TEXT_XML)
     */
    ContentType contentType();
}
----


=== Implementation Examples

==== Same Type Request and Response (CRUD)

When request and response use the same type - implement both interfaces in one class:

[source,java]
----
public class JsonConverter<T> extends StringContentConverter<T>
        implements HttpResponseConverter<T>, HttpRequestConverter<T> {

    private final ObjectMapper objectMapper;
    private final Class<T> type;

    public JsonConverter(Class<T> type) {
        this.objectMapper = new ObjectMapper();
        this.type = type;
    }

    // Response direction: HTTP JSON → T
    @Override
    protected Optional<T> convertString(String rawContent) {
        try {
            T value = objectMapper.readValue(rawContent, type);
            return Optional.ofNullable(value);
        } catch (JsonProcessingException e) {
            LOGGER.warn("JSON deserialization failed", e);
            return Optional.empty();
        }
    }

    // Request direction: T → HTTP JSON
    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable T content) {
        if (content == null) {
            return HttpRequest.BodyPublishers.noBody();
        }
        try {
            String json = objectMapper.writeValueAsString(content);
            return HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8);
        } catch (JsonProcessingException e) {
            LOGGER.warn("JSON serialization failed", e);
            return HttpRequest.BodyPublishers.noBody();
        }
    }

    // Shared metadata - both interfaces require contentType()
    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }
}

// Usage:
JsonConverter<User> converter = new JsonConverter<>(User.class);

HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(converter)  // Set response
    .requestConverter(converter)    // Set request (same instance)
    .build();
----

==== Response-Only Converter (GET-only APIs)

When you only need to read responses:

[source,java]
----
public class UserResponseConverter extends StringContentConverter<User>
        implements HttpResponseConverter<User> {  // Only response interface

    @Override
    protected Optional<User> convertString(String rawContent) {
        return Optional.ofNullable(parseJsonToUser(rawContent));
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }

    // No toBodyPublisher method needed!
}

// Usage:
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(new UserResponseConverter())  // Only response
    .build();

// Can only use GET/HEAD/OPTIONS/DELETE (no body methods)
HttpResult<User> result = adapter.get();
// adapter.post(user);  // ❌ Compile error - no request converter configured
----

==== Request-Only Converter (Fire-and-Forget POST)

When you only send requests and ignore responses:

[source,java]
----
public class CreateUserRequestConverter implements HttpRequestConverter<CreateUserRequest> {

    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable CreateUserRequest content) {
        if (content == null) return HttpRequest.BodyPublishers.noBody();
        String json = toJson(content);
        return HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8);
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }
}

// Usage with explicit request converter
HttpAdapter<Void> adapter = ETagAwareHttpAdapter.<Void>builder()
    .httpHandler(handler)
    .responseConverter(VoidResponseConverter.INSTANCE)  // Discard response
    .build();

CreateUserRequest request = new CreateUserRequest("john@example.com");
HttpResult<Void> result = adapter.post(
    new CreateUserRequestConverter(),
    request
);
----

==== Mixed Types (Different Request/Response)

POST CreateUserRequest → returns User:

[source,java]
----
// Separate converters
public class UserResponseConverter implements HttpResponseConverter<User> {
    @Override
    protected Optional<User> convertString(String json) {
        return Optional.ofNullable(parseJsonToUser(json));
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }
}

public class CreateUserRequestConverter implements HttpRequestConverter<CreateUserRequest> {
    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable CreateUserRequest content) {
        if (content == null) return HttpRequest.BodyPublishers.noBody();
        return HttpRequest.BodyPublishers.ofString(toJson(content), StandardCharsets.UTF_8);
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }
}

// Adapter configured for User responses
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(new UserResponseConverter())
    .build();

// POST with different request type
CreateUserRequest request = new CreateUserRequest("john@example.com");
HttpResult<User> result = adapter.post(
    new CreateUserRequestConverter(),
    request
);

if (result.isSuccess()) {
    User createdUser = result.getValue().orElseThrow();
    LOGGER.info("Created user with ID: {}", createdUser.getId());
}
----

=== Built-in Converters

==== VoidResponseConverter (Status Code Only)

For operations where you only care about HTTP status code, not the response body:

[source,java]
----
package de.cuioss.http.client.converter;

/**
 * Built-in converter for Void responses (status code only).
 * Use when response body is ignored - only HTTP status matters.
 *
 * <p>Common use cases:
 * <ul>
 *   <li>DELETE /resource/123 → 204 No Content</li>
 *   <li>HEAD /health → 200 OK</li>
 *   <li>POST /webhooks → 200 OK (fire and forget)</li>
 * </ul>
 */
public final class VoidResponseConverter implements HttpResponseConverter<Void> {

    /** Singleton instance - no need to create multiple */
    public static final VoidResponseConverter INSTANCE = new VoidResponseConverter();

    private VoidResponseConverter() {} // Use INSTANCE

    @Override
    public Optional<Void> convert(Object rawContent) {
        return Optional.empty();  // Always empty - body is discarded
    }

    @Override
    public HttpResponse.BodyHandler<?> getBodyHandler() {
        return HttpResponse.BodyHandlers.discarding();  // Efficient - don't read body
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;  // Doesn't matter, body discarded
    }
}
----

**Usage:**

[source,java]
----
// Status-code-only adapter using built-in converter
HttpAdapter<Void> adapter = ETagAwareHttpAdapter.<Void>builder()
    .httpHandler(handler)
    .responseConverter(VoidResponseConverter.INSTANCE)  // Built-in!
    .build();

// DELETE - only care about success/failure
HttpResult<Void> result = adapter.delete();
if (result.isSuccess()) {
    LOGGER.info("Resource deleted (status: {})", result.getHttpStatus().orElse(0));
}

// HEAD - only care about status
HttpResult<Void> healthCheck = adapter.head();
boolean isHealthy = healthCheck.isSuccess();
----

==== VoidRequestConverter (No Body Requests)

For operations where request has no body:

[source,java]
----
package de.cuioss.http.client.converter;

/**
 * Built-in converter for requests with no body.
 * Returns no-body publisher for any input.
 */
public final class VoidRequestConverter implements HttpRequestConverter<Void> {

    /** Singleton instance */
    public static final VoidRequestConverter INSTANCE = new VoidRequestConverter();

    private VoidRequestConverter() {} // Use INSTANCE

    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable Void content) {
        return HttpRequest.BodyPublishers.noBody();
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;  // Doesn't matter
    }
}
----

== Module Exports

*File:* `src/main/java/module-info.java`

[source,java]
----
module de.cuioss.http {
    // ... requires

    // Exports
    exports de.cuioss.http.client;
    exports de.cuioss.http.client.handler;
    exports de.cuioss.http.client.converter;
    exports de.cuioss.http.client.result;
    exports de.cuioss.http.client.retry;
    exports de.cuioss.http.client.adapter;

    // ... security exports
}
----

== Summary

All core components follow CUI standards:

* ✅ Immutable, thread-safe design
* ✅ Builder patterns where appropriate
* ✅ @Nullable/@NonNull annotations from JSpecify
* ✅ Lombok for boilerplate reduction
* ✅ Comprehensive Javadoc with examples
* ✅ Optional return types instead of null
* ✅ Fail-secure error handling
