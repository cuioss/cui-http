= Core Components Specification
:toc: left
:toclevels: 3
:sectnums:

== Overview

This document provides complete specifications for all core components introduced in the HTTP method extension.

== Implementation Note: HttpMethod Enum

`HttpMethod` is an **internal implementation detail** (package-private in `de.cuioss.http.client.internal`) and is **not exported** from the module. It is used internally by adapter implementations to track the HTTP method being executed.

**Public API:** Users call method-specific methods on `HttpAdapter` directly:

[source,java]
----
// Direct method calls (no HttpMethod enum needed)
HttpResult<User> result = adapter.get();
HttpResult<User> result = adapter.post(user);
HttpResult<User> result = adapter.put(user, Map.of("If-Match", etag));
----

The old pattern `HttpMethod.POST.send(adapter, ...)` is **no longer part of the public API**.

== CacheKeyHeaders Enum

*Package:* `de.cuioss.http.client.adapter`

*Purpose:* Configure which headers are included in ETag cache keys.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client.adapter;

/**
 * Strategy for including HTTP headers in ETag cache keys.
 *
 * <p>Cache keys uniquely identify cached responses. Including headers
 * creates separate cache entries per header combination, excluding
 * headers shares cache entries across different header values.
 *
 * @since 1.0
 */
public enum CacheKeyHeaders {
    /**
     * Include all additional headers in cache key (default).
     *
     * <p><b>Use when:</b>
     * <ul>
     *   <li>Adapter is shared across multiple users</li>
     *   <li>Headers affect response content (Authorization, Accept-Language)</li>
     *   <li>You want defense-in-depth against buggy server ETags</li>
     * </ul>
     *
     * <p><b>Benefits:</b>
     * <ul>
     *   <li>Safe for multi-user scenarios (no cross-user cache pollution)</li>
     *   <li>Efficient: Avoids wasted If-None-Match requests when ETags won't match</li>
     *   <li>Defense against server ETag bugs (user-agnostic ETags)</li>
     * </ul>
     *
     * <p><b>Drawback:</b>
     * <ul>
     *   <li>Token refresh creates duplicate cache entries (cache bloat)</li>
     * </ul>
     */
    ALL,

    /**
     * Exclude all headers from cache key (URI only).
     *
     * <p><b>Use ONLY when:</b>
     * <ul>
     *   <li>Adapter is NOT shared across users (single-user client)</li>
     *   <li>Server implements user-aware ETags correctly</li>
     *   <li>Headers don't affect response content (or server includes in ETag)</li>
     * </ul>
     *
     * <p><b>Benefits:</b>
     * <ul>
     *   <li>No cache bloat from token refresh</li>
     *   <li>Higher cache hit rate for same resource with varying headers</li>
     * </ul>
     *
     * <p><b>Risks:</b>
     * <ul>
     *   <li>In multi-user scenarios: Wasted bandwidth (ETag mismatches)</li>
     *   <li>Relies on server implementing user-aware ETags correctly</li>
     *   <li>May cache wrong content if server doesn't include header-dependent
     *       data in ETag (e.g., Accept-Language)</li>
     * </ul>
     *
     * <p><b>Example - Single User Client:</b>
     * <pre>{@code
     * // Mobile app, desktop app, or service account
     * HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
     *     .httpHandler(handler)
     *     .contentConverter(userConverter)
     *     .cacheKeyHeaders(CacheKeyHeaders.NONE)  // Safe: single user
     *     .build();
     * }</pre>
     *
     * <p><b>Example - Multi-User Server (UNSAFE):</b>
     * <pre>{@code
     * // Web API endpoint (BAD - don't do this!)
     * HttpAdapter<User> sharedAdapter = ETagAwareHttpAdapter.<User>builder()
     *     .httpHandler(handler)
     *     .contentConverter(userConverter)
     *     .cacheKeyHeaders(CacheKeyHeaders.NONE)  // ⚠️ UNSAFE: shared across users
     *     .build();
     *
     * // User A: GET /api/users/me → caches with key "/api/users/me"
     * // User B: GET /api/users/me → sends If-None-Match with User A's ETag
     * // Result: Server sends 200 (ETag mismatch) → wasted bandwidth
     * }</pre>
     */
    NONE;
}
----

=== Decision Guide

[cols="2,2,2"]
|===
|Scenario |Recommended Setting |Rationale

|Multi-user web server
|`CacheKeyHeaders.ALL`
|Separate cache per user, efficient If-None-Match

|Single-user mobile app
|`CacheKeyHeaders.NONE`
|No token refresh cache bloat

|Service account (one token)
|`CacheKeyHeaders.NONE`
|Token rarely changes

|Desktop application
|`CacheKeyHeaders.NONE`
|One user per app instance

|Multi-tenant SaaS
|`CacheKeyHeaders.ALL`
|Defense against cross-tenant leakage

|Per-user adapter instances
|`CacheKeyHeaders.NONE`
|Already isolated per user
|===

== ContentType Enum

*Package:* `de.cuioss.http.client`

*Purpose:* Type-safe MIME type representation with charset support.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Optional;

/**
 * Type-safe content types (MIME types) with charset support.
 *
 * @since 1.0
 */
public enum ContentType {
    APPLICATION_JSON("application/json", StandardCharsets.UTF_8),
    APPLICATION_XML("application/xml", StandardCharsets.UTF_8),
    TEXT_PLAIN("text/plain", StandardCharsets.UTF_8),
    TEXT_HTML("text/html", StandardCharsets.UTF_8),
    TEXT_XML("text/xml", StandardCharsets.UTF_8),
    TEXT_CSV("text/csv", StandardCharsets.UTF_8),
    APPLICATION_FORM_URLENCODED("application/x-www-form-urlencoded", StandardCharsets.UTF_8),
    MULTIPART_FORM_DATA("multipart/form-data", null),
    APPLICATION_OCTET_STREAM("application/octet-stream", null),
    APPLICATION_PDF("application/pdf", null),
    APPLICATION_ZIP("application/zip", null),
    IMAGE_PNG("image/png", null),
    IMAGE_JPEG("image/jpeg", null),
    IMAGE_GIF("image/gif", null),
    IMAGE_SVG("image/svg+xml", StandardCharsets.UTF_8);

    private final String mediaType;
    private final Charset defaultCharset;

    ContentType(String mediaType, Charset defaultCharset) {
        this.mediaType = mediaType;
        this.defaultCharset = defaultCharset;
    }

    /**
     * Returns the media type (e.g., "application/json").
     */
    public String mediaType() {
        return mediaType;
    }

    /**
     * Returns the default charset for this content type.
     */
    public Optional<Charset> defaultCharset() {
        return Optional.ofNullable(defaultCharset);
    }

    /**
     * Returns the complete Content-Type header value with charset if applicable.
     * Example: "application/json; charset=UTF-8"
     */
    public String toHeaderValue() {
        if (defaultCharset != null) {
            return mediaType + "; charset=" + defaultCharset.name();
        }
        return mediaType;
    }
}
----

=== Supported Types

* **JSON**: `APPLICATION_JSON`
* **Text**: `TEXT_PLAIN`, `TEXT_HTML`, `TEXT_CSV`
* **XML**: `APPLICATION_XML`, `TEXT_XML`
* **Form**: `APPLICATION_FORM_URLENCODED`, `MULTIPART_FORM_DATA`
* **Binary**: `APPLICATION_OCTET_STREAM`, `APPLICATION_PDF`, `APPLICATION_ZIP`
* **Images**: `IMAGE_PNG`, `IMAGE_JPEG`, `IMAGE_GIF`, `IMAGE_SVG`

=== Key Methods

[source,java]
----
String mediaType();              // "application/json"
Optional<Charset> defaultCharset(); // UTF_8
String toHeaderValue();          // "application/json; charset=UTF-8"
----

== HttpAdapter Interface

*Package:* `de.cuioss.http.client.adapter`

*Purpose:* Common interface for all HTTP adapters providing method-specific operations.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client.adapter;

import de.cuioss.http.client.result.HttpResult;
import de.cuioss.http.client.converter.HttpContentConverter;
import org.jspecify.annotations.Nullable;
import java.util.Map;

/**
 * Adapter for sending HTTP requests and receiving structured results.
 * Provides method-specific operations following HTTP semantics.
 *
 * <p>The adapter uses a bidirectional HttpContentConverter for the primary
 * type T, handling both request serialization and response deserialization.
 * For cases where request and response types differ, methods accept an
 * additional request converter.
 *
 * @param <T> Response body type (and default request type)
 * @since 1.0
 */
public interface HttpAdapter<T> {

    // ========== NO-BODY METHODS ==========

    /**
     * Sends GET request to retrieve resource.
     * GET requests do not have a body (RFC 7231).
     *
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing response or error information
     */
    HttpResult<T> get(Map<String, String> additionalHeaders);
    default HttpResult<T> get() { return get(Map.of()); }

    /**
     * Sends HEAD request to retrieve headers only (no body in response).
     *
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing response metadata
     */
    HttpResult<T> head(Map<String, String> additionalHeaders);
    default HttpResult<T> head() { return head(Map.of()); }

    /**
     * Sends OPTIONS request to query supported methods.
     *
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing server capabilities
     */
    HttpResult<T> options(Map<String, String> additionalHeaders);
    default HttpResult<T> options() { return options(Map.of()); }

    /**
     * Sends DELETE request to remove resource.
     * Most DELETE requests don't have a body.
     *
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing response or error information
     */
    HttpResult<T> delete(Map<String, String> additionalHeaders);
    default HttpResult<T> delete() { return delete(Map.of()); }

    // ========== BODY METHODS (T → T, bidirectional converter) ==========

    /**
     * Sends POST request to create resource.
     * Uses the adapter's HttpContentConverter for both request serialization
     * and response deserialization.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing created resource or error
     */
    HttpResult<T> post(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default HttpResult<T> post(@Nullable T requestBody) { return post(requestBody, Map.of()); }

    /**
     * Sends PUT request to create or replace resource.
     * Uses the adapter's HttpContentConverter for both directions.
     *
     * @param requestBody Request body content, may be null
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing updated resource or error
     */
    HttpResult<T> put(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default HttpResult<T> put(@Nullable T requestBody) { return put(requestBody, Map.of()); }

    /**
     * Sends PATCH request to partially update resource.
     * Uses the adapter's HttpContentConverter for both directions.
     *
     * @param requestBody Request body content (typically partial object)
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing updated resource or error
     */
    HttpResult<T> patch(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default HttpResult<T> patch(@Nullable T requestBody) { return patch(requestBody, Map.of()); }

    /**
     * Sends DELETE request with body (rare, but allowed by RFC).
     * Uses the adapter's HttpContentConverter for body serialization.
     *
     * @param requestBody Request body content
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing response or error
     */
    HttpResult<T> delete(@Nullable T requestBody, Map<String, String> additionalHeaders);
    default HttpResult<T> delete(@Nullable T requestBody) {
        return delete(requestBody, Map.of());
    }

    // ========== BODY METHODS (R → T, different request type) ==========

    /**
     * Sends POST request with different request and response types.
     * Use when the creation request type differs from the created resource type.
     *
     * @param <R> Request body type
     * @param requestConverter Converter for request body serialization
     * @param requestBody Request body content
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing created resource (type T) or error
     */
    <R> HttpResult<T> post(HttpContentConverter<R> requestConverter,
                           @Nullable R requestBody,
                           Map<String, String> additionalHeaders);
    default <R> HttpResult<T> post(HttpContentConverter<R> requestConverter,
                                   @Nullable R requestBody) {
        return post(requestConverter, requestBody, Map.of());
    }

    /**
     * Sends PUT request with different request and response types.
     *
     * @param <R> Request body type
     * @param requestConverter Converter for request body serialization
     * @param requestBody Request body content
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing updated resource (type T) or error
     */
    <R> HttpResult<T> put(HttpContentConverter<R> requestConverter,
                          @Nullable R requestBody,
                          Map<String, String> additionalHeaders);
    default <R> HttpResult<T> put(HttpContentConverter<R> requestConverter,
                                  @Nullable R requestBody) {
        return put(requestConverter, requestBody, Map.of());
    }

    /**
     * Sends PATCH request with different request and response types.
     *
     * @param <R> Request body type
     * @param requestConverter Converter for request body serialization
     * @param requestBody Request body content
     * @param additionalHeaders Additional HTTP headers
     * @return Result containing updated resource (type T) or error
     */
    <R> HttpResult<T> patch(HttpContentConverter<R> requestConverter,
                            @Nullable R requestBody,
                            Map<String, String> additionalHeaders);
    default <R> HttpResult<T> patch(HttpContentConverter<R> requestConverter,
                                    @Nullable R requestBody) {
        return patch(requestConverter, requestBody, Map.of());
    }
}
----

=== Design Rationale

* **Method-specific APIs** - Clear intent, follows HTTP semantics
* **Bidirectional converter** - Single converter handles request and response (most cases)
* **Flexible for edge cases** - Separate request converter when types differ
* **RFC compliant** - GET/HEAD/OPTIONS have no body methods
* **Type-safe** - Compiler enforces correct usage
* **Enables composition** - Can wrap adapters for retry, auth, metrics
* **Self-documenting** - Method names indicate HTTP verb and semantics

== HttpErrorCategory (Updated)

*Package:* `de.cuioss.http.client.result`

*Purpose:* Classify failures for retry decisions.

=== Updated Enum

[source,java]
----
public enum HttpErrorCategory {
    NETWORK_ERROR,      // IOException - RETRYABLE
    SERVER_ERROR,       // 5xx - RETRYABLE
    CLIENT_ERROR,       // 4xx - NOT retryable
    INVALID_CONTENT,    // Parsing failed - NOT retryable
    CONFIGURATION_ERROR; // SSL, URI configuration issues - NOT retryable

    public boolean isRetryable() {
        return this == NETWORK_ERROR || this == SERVER_ERROR;
    }
}
----

*Note on 3xx Redirects:*

* Most 3xx are followed automatically by `HttpClient`
* 304 Not Modified is handled as application-level success by `ETagAwareHttpAdapter`
* No separate REDIRECTION category needed

== HttpStatusFamily (Updated)

*Package:* `de.cuioss.http.client.handler`

*Purpose:* HTTP protocol-level status classification.

=== New Method: toErrorCategory()

[source,java]
----
/**
 * Converts HTTP status family to error category for retry decisions.
 * Note: REDIRECTION is handled specially by ETagAwareHttpAdapter.
 */
public HttpErrorCategory toErrorCategory() {
    return switch (this) {
        case CLIENT_ERROR -> HttpErrorCategory.CLIENT_ERROR;
        case SERVER_ERROR -> HttpErrorCategory.SERVER_ERROR;
        case SUCCESS -> throw new IllegalStateException(
            "SUCCESS is not an error");
        case REDIRECTION -> HttpErrorCategory.INVALID_CONTENT;  // Rare, handled by adapter
        case INFORMATIONAL, UNKNOWN -> HttpErrorCategory.INVALID_CONTENT;
    };
}
----

*Notes:*

* Most 3xx redirects are followed automatically by `HttpClient`
* 304 Not Modified is intercepted by `ETagAwareHttpAdapter` (never reaches error categorization)
* Other 3xx are rare in modern HTTP and mapped to `INVALID_CONTENT`

== HttpContentConverter (Updated - Bidirectional)

*Package:* `de.cuioss.http.client.converter`

*Purpose:* **Bidirectional converter** - handles both request serialization and response deserialization.

=== Interface Definition

[source,java]
----
package de.cuioss.http.client.converter;

import de.cuioss.http.client.ContentType;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.Optional;
import org.jspecify.annotations.Nullable;

/**
 * Bidirectional converter for HTTP request and response bodies.
 * Handles both serialization (T → HTTP) and deserialization (HTTP → T).
 *
 * <p>This enables symmetric APIs where the same type is used for
 * both request and response (common in CRUD operations).
 *
 * @param <T> The type to convert to/from
 * @since 1.0
 */
public interface HttpContentConverter<T> {

    // ========== RESPONSE DIRECTION (HTTP → T) ==========

    /**
     * Converts HTTP response body to typed object.
     *
     * @param rawContent Raw response content from HTTP response
     * @return Converted object, or empty if conversion failed
     */
    Optional<T> convert(Object rawContent);

    /**
     * Returns body handler for HTTP response processing.
     *
     * @return BodyHandler appropriate for this content type
     */
    HttpResponse.BodyHandler<?> getBodyHandler();

    // ========== REQUEST DIRECTION (T → HTTP) ==========

    /**
     * Converts typed object to HTTP request body publisher.
     *
     * <p>If content is null, implementations should return a no-body publisher.
     *
     * @param content The content to serialize, may be null
     * @return BodyPublisher for the HTTP request
     */
    HttpRequest.BodyPublisher toBodyPublisher(@Nullable T content);

    // ========== SHARED METADATA ==========

    /**
     * Returns the content type for this converter.
     * Used for both request Content-Type header and response validation.
     *
     * @return Content type (e.g., APPLICATION_JSON, TEXT_XML)
     */
    ContentType contentType();
}
----

=== Breaking Changes from Previous Version

[source,java]
----
// REMOVED:
T emptyValue();  // No longer needed, use Optional.empty()

// RENAMED:
ContentType expectedContentType() → contentType()

// ADDED:
HttpRequest.BodyPublisher toBodyPublisher(@Nullable T content);
----

=== Implementation Example: JSON Converter

[source,java]
----
public class JsonConverter<T> extends StringContentConverter<T> {
    private final ObjectMapper objectMapper;
    private final Class<T> type;

    public JsonConverter(Class<T> type) {
        this.objectMapper = new ObjectMapper();
        this.type = type;
    }

    // Response direction: HTTP JSON → T
    @Override
    protected Optional<T> convertString(String rawContent) {
        try {
            T value = objectMapper.readValue(rawContent, type);
            return Optional.ofNullable(value);
        } catch (JsonProcessingException e) {
            LOGGER.error("JSON deserialization failed", e);
            return Optional.empty();
        }
    }

    // Request direction: T → HTTP JSON
    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable T content) {
        if (content == null) {
            return HttpRequest.BodyPublishers.noBody();
        }
        try {
            String json = objectMapper.writeValueAsString(content);
            return HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8);
        } catch (JsonProcessingException e) {
            LOGGER.error("JSON serialization failed", e);
            return HttpRequest.BodyPublishers.noBody();
        }
    }

    // Shared metadata
    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }
}
----

=== Migration Guide

**From Previous Version:**

[source,java]
----
// OLD (response-only converter)
public class UserConverter extends StringContentConverter<User> {
    @Override
    protected Optional<User> convertString(String rawContent) {
        return Optional.ofNullable(parseJson(rawContent));
    }

    @Override
    public User emptyValue() {
        return new User();  // ❌ Remove this
    }

    @Override
    public ContentType expectedContentType() {
        return ContentType.APPLICATION_JSON;  // ✅ Rename to contentType()
    }
}

// NEW (bidirectional converter)
public class UserConverter extends StringContentConverter<User> {
    @Override
    protected Optional<User> convertString(String rawContent) {
        return Optional.ofNullable(parseJson(rawContent));
    }

    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable User content) {
        if (content == null) return HttpRequest.BodyPublishers.noBody();
        String json = toJson(content);
        return HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8);
    }

    @Override
    public ContentType contentType() {  // Renamed from expectedContentType()
        return ContentType.APPLICATION_JSON;
    }
}
----

=== Void Converter (For DELETE/No Response)

[source,java]
----
public class VoidConverter implements HttpContentConverter<Void> {
    @Override
    public Optional<Void> convert(Object rawContent) {
        return Optional.empty();  // Ignore response body
    }

    @Override
    public HttpResponse.BodyHandler<?> getBodyHandler() {
        return HttpResponse.BodyHandlers.discarding();
    }

    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable Void content) {
        return HttpRequest.BodyPublishers.noBody();
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;  // Doesn't matter for Void
    }
}
----

== Module Exports

*File:* `src/main/java/module-info.java`

=== New Exports

[source,java]
----
module de.cuioss.http {
    // ... existing requires

    // Existing exports
    exports de.cuioss.http.client;
    exports de.cuioss.http.client.handler;
    exports de.cuioss.http.client.converter;
    exports de.cuioss.http.client.result;
    exports de.cuioss.http.client.retry;

    // NEW exports
    exports de.cuioss.http.client.adapter;

    // NOT exported (internal use only):
    // - de.cuioss.http.client.internal (HttpMethod enum and other internals)

    // ... security exports
}
----

== Summary

All core components follow CUI standards:

* ✅ Immutable, thread-safe design
* ✅ Builder patterns where appropriate
* ✅ @Nullable/@NonNull annotations from JSpecify
* ✅ Lombok for boilerplate reduction
* ✅ Comprehensive Javadoc with examples
* ✅ Optional return types instead of null
* ✅ Fail-secure error handling
