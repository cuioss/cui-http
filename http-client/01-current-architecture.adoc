= Current Architecture Analysis
:toc: left
:toc-title: Table of Contents
:toclevels: 3
:sectnums:
:source-highlighter: highlight.js

== Overview

This document analyzes the existing cui-http library architecture to understand current capabilities and identify integration points for HTTP method extensions.

== Core Components

=== HttpHandler

*Location:* `src/main/java/de/cuioss/http/client/handler/HttpHandler.java`

==== Current Capabilities

* Builder-based configuration (URI, SSL, timeouts)
* SSL/TLS context management via `SecureSSLContextProvider`
* Provides `HttpRequest.Builder` via `requestBuilder()` method
* Supports HEAD and GET ping operations
* Thread-safe, immutable design

==== Key Methods

[source,java]
----
public class HttpHandler {
    // Creates configured HttpClient instance
    public HttpClient createHttpClient();

    // Provides request builder with base configuration
    public HttpRequest.Builder requestBuilder();

    // Convenience methods
    public HttpResult<Boolean> ping();          // HEAD request
    public HttpResult<Boolean> pingViaGet();    // GET request
}
----

==== Builder Pattern

[source,java]
----
HttpHandler handler = HttpHandler.builder()
    .uri("https://api.example.com/resource")
    .connectionTimeoutSeconds(5)
    .readTimeoutSeconds(10)
    .sslContextProvider(SecureSSLContextProvider.builder().build())
    .build();
----

==== Current Limitations

* No explicit support for POST/PUT/DELETE methods
* No request body handling mechanism
* `requestBuilder()` returns generic builder without HTTP method configured
* GET is the default/implicit method

=== ResilientHttpHandler

*Location:* `src/main/java/de/cuioss/http/client/ResilientHttpHandler.java`

==== Current Capabilities

* ETag-based caching with conditional requests (If-None-Match)
* Retry logic via `RetryStrategy`
* Response body conversion via `HttpContentConverter<T>`
* Thread-safe with `ReentrantLock`
* Returns `HttpResult<T>` with comprehensive state tracking

==== Current Design

[source,java]
----
public class ResilientHttpHandler<T> {
    private final HttpHandler httpHandler;
    private final RetryStrategy retryStrategy;
    private final HttpContentConverter<T> contentConverter;

    // Main method - GET only
    public HttpResult<T> load();
}
----

==== Architectural Issue

The current `ResilientHttpHandler` *mixes three orthogonal concerns*:

. *ETag Caching* (HTTP optimization) - 304 Not Modified, bandwidth reduction
. *Retry Logic* (reliability) - Transient failure handling, exponential backoff
. *Response Conversion* - Type-safe body handling

*Problem:* These are independent! You might want:

* Caching WITHOUT retry (simple GET operations)
* Retry WITHOUT caching (POST/PUT/DELETE operations)
* Neither (direct execution)
* Both (composed together)

==== Proposed Solution

Replace with composable adapter pattern:

* `ETagAwareHttpAdapter` - Base adapter with *built-in* ETag caching (configurable)
* `ResilientHttpAdapter` - Wrapper for retry logic
* Compose as needed: `new ResilientHttpAdapter(baseAdapter, strategy)`

=== HttpContentConverter

*Location:* `src/main/java/de/cuioss/http/client/converter/HttpContentConverter.java`

==== Current Interface

[source,java]
----
public interface HttpContentConverter<T> {
    // Response body → T
    Optional<T> convert(Object rawContent);

    // Response handling
    HttpResponse.BodyHandler<?> getBodyHandler();

    // DEPRECATED: Will be removed
    T emptyValue();
}
----

==== Key Insight

This is a *response-only* converter. It bridges between Java's `HttpResponse.BodyHandler` and application-level types.

==== Existing Implementations

* `StringContentConverter<T>` - Base class for text-based content (JSON, XML, HTML)
* `StringContentConverter.identity()` - Returns raw String

==== Proposed Changes (Breaking)

[source,java]
----
public interface HttpContentConverter<T> {
    Optional<T> convert(Object rawContent);
    HttpResponse.BodyHandler<?> getBodyHandler();

    // NEW: Replaces emptyValue()
    ContentType expectedContentType();
}
----

*Rationale:*

* `emptyValue()` is redundant - `HttpResult<T>` uses `Optional<T>`
* `expectedContentType()` enables validation and documentation

==== Migration Strategy

**Phase 1: Deprecation (Version 1.x)**

1. Mark `HttpContentConverter.emptyValue()` as `@Deprecated`
2. Add default implementation returning `null`:
+
[source,java]
----
@Deprecated(since = "1.0", forRemoval = true)
default T emptyValue() {
    return null;  // Not used by new HttpResult<T> design
}
----

3. Add new `expectedContentType()` method with default:
+
[source,java]
----
default ContentType expectedContentType() {
    return ContentType.TEXT_PLAIN;  // Safe default
}
----

4. Update documentation marking method as deprecated
5. Provide migration examples in release notes

**Phase 2: New Interfaces (Version 1.x)**

Introduce new interfaces alongside old one:

[source,java]
----
// New response converter
public interface HttpResponseConverter<T> {
    Optional<T> convert(Object rawContent);
    HttpResponse.BodyHandler<?> getBodyHandler();
    ContentType contentType();
}

// New request converter
public interface HttpRequestConverter<R> {
    HttpRequest.BodyPublisher toBodyPublisher(@Nullable R content);
    ContentType contentType();
}
----

**Phase 3: Backward Compatibility Adapters (Version 1.x)**

Provide bridge classes for existing code:

[source,java]
----
/**
 * Adapter wrapping legacy HttpContentConverter as HttpResponseConverter.
 *
 * @deprecated Use HttpResponseConverter directly. This adapter will be
 *             removed when HttpContentConverter is removed in version 2.0.
 */
@Deprecated(since = "1.0", forRemoval = true)
public final class LegacyConverterAdapter<T> implements HttpResponseConverter<T> {

    private final HttpContentConverter<T> legacy;
    private final ContentType contentType;

    public LegacyConverterAdapter(HttpContentConverter<T> legacy, ContentType contentType) {
        this.legacy = legacy;
        this.contentType = contentType;
    }

    @Override
    public Optional<T> convert(Object rawContent) {
        return legacy.convert(rawContent);
    }

    @Override
    public HttpResponse.BodyHandler<?> getBodyHandler() {
        return legacy.getBodyHandler();
    }

    @Override
    public ContentType contentType() {
        return contentType;
    }
}
----

**Phase 4: Update Existing Implementations (Version 1.x)**

Update `StringContentConverter` base class:

[source,java]
----
// Old
public abstract class StringContentConverter<T> implements HttpContentConverter<T> {
    @Override
    public T emptyValue() {
        return null;  // Implementations override
    }
}

// New (implements both old and new interfaces during migration)
public abstract class StringContentConverter<T>
    implements HttpContentConverter<T>, HttpResponseConverter<T> {

    @Deprecated
    @Override
    public T emptyValue() {
        return null;  // Not used
    }

    @Override
    public ContentType contentType() {
        return expectedContentType();
    }

    @Override
    public ContentType expectedContentType() {
        return contentType();  // Delegate to new method
    }
}
----

**Phase 5: Removal (Version 2.0)**

1. Remove `HttpContentConverter` interface entirely
2. Remove `LegacyConverterAdapter`
3. Update `StringContentConverter` to only implement `HttpResponseConverter`
4. Update all adapter APIs to use new interfaces

==== Migration Examples

**Example 1: Simple Converter (No Request Support)**

*Before (1.0):*
[source,java]
----
public class UserConverter implements HttpContentConverter<User> {
    @Override
    public Optional<User> convert(Object rawContent) {
        // Parse JSON to User
        return Optional.ofNullable(parseJson((String) rawContent, User.class));
    }

    @Override
    public HttpResponse.BodyHandler<?> getBodyHandler() {
        return HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8);
    }

    @Override
    public User emptyValue() {
        return User.EMPTY;  // This is never actually used!
    }
}
----

*After (1.0+ with deprecation, 2.0+ required):*
[source,java]
----
public class UserResponseConverter implements HttpResponseConverter<User> {
    @Override
    public Optional<User> convert(Object rawContent) {
        // Parse JSON to User
        return Optional.ofNullable(parseJson((String) rawContent, User.class));
    }

    @Override
    public HttpResponse.BodyHandler<?> getBodyHandler() {
        return HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8);
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }

    // NO emptyValue() - HttpResult<T> uses Optional<T>
}
----

**Example 2: Bidirectional Converter (Request + Response)**

*Before (not supported):*
[source,java]
----
// Had to create custom request body handling outside converter
String jsonBody = toJson(user);
// Pass as String to HTTP client
----

*After (1.0+, 2.0+):*
[source,java]
----
public class UserConverter
    implements HttpResponseConverter<User>, HttpRequestConverter<User> {

    // Response conversion
    @Override
    public Optional<User> convert(Object rawContent) {
        return Optional.ofNullable(parseJson((String) rawContent, User.class));
    }

    @Override
    public HttpResponse.BodyHandler<?> getBodyHandler() {
        return HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8);
    }

    @Override
    public ContentType contentType() {
        return ContentType.APPLICATION_JSON;
    }

    // Request conversion (NEW)
    @Override
    public HttpRequest.BodyPublisher toBodyPublisher(@Nullable User content) {
        if (content == null) {
            return HttpRequest.BodyPublishers.noBody();
        }
        String json = toJson(content);
        return HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8);
    }
}

// Usage with new HttpAdapter
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)  // Response conversion
    .requestConverter(userConverter)    // Request conversion (same instance!)
    .build();

// Now POST works with type safety
HttpResult<User> result = adapter.postBlocking(newUser);
----

**Example 3: Using Legacy Adapter Bridge (Temporary)**

*During Migration (1.x only):*
[source,java]
----
// Old converter still works via adapter
HttpContentConverter<User> oldConverter = new OldUserConverter();

// Wrap for new API
HttpResponseConverter<User> newConverter = new LegacyConverterAdapter<>(
    oldConverter,
    ContentType.APPLICATION_JSON
);

// Use in new adapter
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(newConverter)
    .build();
----

==== Migration Checklist

**For Library Users:**

- [ ] Update all custom `HttpContentConverter` implementations to `HttpResponseConverter`
- [ ] Remove `emptyValue()` method implementations
- [ ] Add `contentType()` method returning appropriate `ContentType`
- [ ] For bidirectional converters, implement `HttpRequestConverter` as well
- [ ] Update adapter builders to use `responseConverter` and `requestConverter`
- [ ] Test all converters with new `HttpAdapter` interface
- [ ] Remove usage of `LegacyConverterAdapter` before version 2.0

**For Library Maintainers:**

- [ ] Mark `HttpContentConverter.emptyValue()` as `@Deprecated` in version 1.0
- [ ] Add default implementation for `emptyValue()` returning `null`
- [ ] Create `HttpResponseConverter` and `HttpRequestConverter` interfaces
- [ ] Create `LegacyConverterAdapter` for backward compatibility
- [ ] Update `StringContentConverter` to implement both interfaces
- [ ] Update all documentation and examples
- [ ] Add migration guide to release notes
- [ ] Remove deprecated interfaces in version 2.0

==== Deprecation Timeline

[cols="1,3"]
|===
|Version |Changes

|1.0
|• New interfaces introduced (`HttpResponseConverter`, `HttpRequestConverter`) +
• `HttpContentConverter.emptyValue()` deprecated +
• `LegacyConverterAdapter` provided +
• All existing code continues to work

|1.x
|• Warnings in logs for deprecated usage +
• Documentation promotes new interfaces +
• Examples updated to new interfaces

|2.0
|• `HttpContentConverter` removed +
• `LegacyConverterAdapter` removed +
• Breaking change for unmigrated code
|===

==== Impact Assessment

**High Impact:**

* All custom converter implementations must be updated
* Existing `StringContentConverter` subclasses need modification
* Bidirectional converters (request + response) require new patterns

**Medium Impact:**

* Adapter builder calls change (`.responseConverter()` instead of `.contentConverter()`)
* Import statements change (`HttpResponseConverter` instead of `HttpContentConverter`)

**Low Impact:**

* Users relying only on built-in converters (minimal changes)
* Runtime behavior identical (only interface changes)
* No performance impact

=== HttpResult

*Location:* `src/main/java/de/cuioss/http/client/result/HttpResult.java`

==== Design

Sealed interface with two implementations:

[source,java]
----
public sealed interface HttpResult<T>
    permits HttpResult.Success, HttpResult.Failure {

    boolean isSuccess();
    Optional<T> getContent();
    Optional<String> getETag();
    Optional<Integer> getHttpStatus();
    Optional<HttpErrorCategory> getErrorCategory();

    // ========== Status Code Convenience Methods ==========

    /**
     * Checks if response has specific HTTP status code.
     *
     * @param statusCode Expected HTTP status code
     * @return true if status matches, false otherwise
     */
    default boolean hasStatusCode(int statusCode) {
        return getHttpStatus().orElse(-1) == statusCode;
    }

    /**
     * Checks if response is 412 Precondition Failed (ETag mismatch).
     * Common in optimistic locking when If-Match header doesn't match current ETag.
     *
     * @return true if status is 412
     */
    default boolean isPreconditionFailed() {
        return hasStatusCode(412);
    }

    /**
     * Checks if response is 404 Not Found.
     *
     * @return true if status is 404
     */
    default boolean isNotFound() {
        return hasStatusCode(404);
    }

    /**
     * Checks if response is 409 Conflict.
     * Different from 412: 409 indicates state conflict, 412 indicates ETag mismatch.
     *
     * @return true if status is 409
     */
    default boolean isConflict() {
        return hasStatusCode(409);
    }

    /**
     * Checks if response is 304 Not Modified (cached content valid).
     * Note: ETagAwareHttpAdapter handles this automatically, returning Success.
     *
     * @return true if status is 304
     */
    default boolean isNotModified() {
        return hasStatusCode(304);
    }

    /**
     * Checks if response is 401 Unauthorized (authentication required).
     *
     * @return true if status is 401
     */
    default boolean isUnauthorized() {
        return hasStatusCode(401);
    }

    /**
     * Checks if response is 403 Forbidden (authenticated but not allowed).
     *
     * @return true if status is 403
     */
    default boolean isForbidden() {
        return hasStatusCode(403);
    }

    /**
     * Checks if response is 422 Unprocessable Entity (validation failed).
     *
     * @return true if status is 422
     */
    default boolean isUnprocessableEntity() {
        return hasStatusCode(422);
    }
}
----

==== Success Record

[source,java]
----
record Success<T>(
    T content,              // Never null
    @Nullable String etag,
    int httpStatus
) implements HttpResult<T>
----

==== Failure Record

[source,java]
----
record Failure<T>(
    String errorMessage,
    @Nullable Throwable cause,
    @Nullable Integer httpStatus
) implements HttpResult<T> {

    // Derive category from httpStatus and cause
    public HttpErrorCategory category() {
        if (httpStatus != null) {
            if (httpStatus >= 400 && httpStatus < 500) return HttpErrorCategory.CLIENT_ERROR;
            if (httpStatus >= 500 && httpStatus < 600) return HttpErrorCategory.SERVER_ERROR;
        }
        if (cause instanceof IOException) return HttpErrorCategory.NETWORK_ERROR;
        if (cause instanceof SSLException) return HttpErrorCategory.CONFIGURATION_ERROR;
        return HttpErrorCategory.INVALID_CONTENT;  // Default fallback
    }
}
----

==== Factory Methods

[source,java]
----
// Success
HttpResult.success(content, etag, httpStatus)

// Failure (category derived automatically)
HttpResult.failure(errorMessage, cause, httpStatus)
----

=== HttpStatusFamily

*Location:* `src/main/java/de/cuioss/http/client/handler/HttpStatusFamily.java`

==== Purpose

Classifies HTTP status codes into RFC 7231 families (1xx, 2xx, 3xx, 4xx, 5xx).

==== Enum Values

[source,java]
----
public enum HttpStatusFamily {
    INFORMATIONAL(100, 199, "Informational"),  // 1xx
    SUCCESS(200, 299, "Success"),              // 2xx
    REDIRECTION(300, 399, "Redirection"),      // 3xx
    CLIENT_ERROR(400, 499, "Client Error"),    // 4xx
    SERVER_ERROR(500, 599, "Server Error"),    // 5xx
    UNKNOWN(-1, -1, "Unknown");

    public static HttpStatusFamily fromStatusCode(int statusCode);
    public boolean contains(int statusCode);
}
----

==== Proposed Addition

Add helper method to convert to application-level error category:

[source,java]
----
/**
 * Converts HTTP status family to error category for retry decisions.
 */
public HttpErrorCategory toErrorCategory() {
    return switch (this) {
        case CLIENT_ERROR -> HttpErrorCategory.CLIENT_ERROR;
        case SERVER_ERROR -> HttpErrorCategory.SERVER_ERROR;
        case SUCCESS -> throw new IllegalStateException(
            "SUCCESS is not an error");
        case REDIRECTION -> HttpErrorCategory.INVALID_CONTENT;  // Rare, handled by adapter
        case INFORMATIONAL, UNKNOWN -> HttpErrorCategory.INVALID_CONTENT;
    };
}
----

=== HttpErrorCategory

*Location:* `src/main/java/de/cuioss/http/client/result/HttpErrorCategory.java`

==== Purpose

Classifies ALL failures for retry decisions (broader than HTTP status codes).

==== Current Enum Values

[source,java]
----
public enum HttpErrorCategory {
    NETWORK_ERROR,      // IOException - RETRYABLE
    SERVER_ERROR,       // 5xx - RETRYABLE
    CLIENT_ERROR,       // 4xx - NOT retryable
    INVALID_CONTENT,    // Parsing failed - NOT retryable
    CONFIGURATION_ERROR; // SSL, URI - NOT retryable

    public boolean isRetryable();
}
----

===== Protocol → Application Mapping

*Note:* No REDIRECTION category is needed - most 3xx codes are followed automatically by HttpClient, and 304 Not Modified is handled as application success by ETagAwareHttpAdapter.

[cols="2,2,1"]
|===
|HttpStatusFamily |HttpErrorCategory |Retryable?

|SUCCESS (2xx)
|(not an error)
|N/A

|CLIENT_ERROR (4xx)
|CLIENT_ERROR
|No

|SERVER_ERROR (5xx)
|SERVER_ERROR
|Yes

|INFORMATIONAL (1xx)
|INVALID_CONTENT
|No

|UNKNOWN
|INVALID_CONTENT
|No

|IOException
|NETWORK_ERROR
|Yes

|SSLException
|CONFIGURATION_ERROR
|No

|Parsing failure
|INVALID_CONTENT
|No
|===

=== RetryStrategy

*Location:* `src/main/java/de/cuioss/http/client/retry/RetryStrategy.java`

==== Current Interface

[source,java]
----
public interface RetryStrategy {
    <T> CompletableFuture<HttpResult<T>> execute(
        Supplier<HttpResult<T>> operation,
        RetryContext context
    );

    static RetryStrategy none(); // ❌ Will be removed
}
----

==== Proposed Simplification

Remove `RetryStrategy.none()` - if you don't want retry, don't use `ResilientHttpAdapter`!

==== RetryStrategies Utility

*Location:* `src/main/java/de/cuioss/http/client/retry/RetryStrategies.java`

[source,java]
----
public final class RetryStrategies {
    /**
     * Exponential backoff with sensible defaults.
     */
    public static RetryStrategy exponentialBackoff();
}
----

*Proposed:* Consider builder pattern instead of factory methods.

== Integration Flow

=== Current GET Request Flow

[source]
----
Client Code
    ↓
ResilientHttpHandler.load()
    ↓ creates request
HttpHandler.requestBuilder()
    ↓ adds If-None-Match
buildRequestWithConditionalHeaders()
    ↓ executes
HttpClient.send(request, BodyHandler)
    ↓ receives
HttpResponse<?>
    ↓ converts
HttpContentConverter.convert()
    ↓ returns
HttpResult<T>
----

=== Issues with Current Flow

. *Mixed concerns* - ETag caching, retry, and conversion bundled together
. *No method flexibility* - GET is hardcoded
. *No request body support* - Cannot send POST/PUT/DELETE

== Security Components

=== Validation Pipelines

*Location:* `src/main/java/de/cuioss/http/security/pipeline/`

==== Available Validators

* `URLPathValidationPipeline` - All URL validation (paths, full URLs, directory traversal, CVE exploits)
* `HTTPHeaderValidationPipeline` - Header injection attacks
* `URLParameterValidationPipeline` - Query parameter validation

==== Contract

[source,java]
----
public interface HttpSecurityValidator {
    Optional<String> validate(@Nullable String value)
        throws UrlSecurityException;
}
----

All validators are:

* Thread-safe
* Composable (can be chained)
* Fail-secure (throw `UrlSecurityException` on violations)

==== Integration Points

. *Request body validation* - Before POST/PUT
. *Header validation* - For custom headers
. *URL validation* - Already integrated in HttpHandler

== Module Definition

*Location:* `src/main/java/module-info.java`

=== Current Exports

[source,java]
----
module de.cuioss.http {
    requires de.cuioss.java.tools;
    requires org.jspecify;
    requires static lombok;
    requires java.net.http;

    exports de.cuioss.http.client;
    exports de.cuioss.http.client.handler;
    exports de.cuioss.http.client.converter;
    exports de.cuioss.http.client.result;
    exports de.cuioss.http.client.retry;

    // Security
    exports de.cuioss.http.security;
    exports de.cuioss.http.security.pipeline;
    exports de.cuioss.http.security.validation;
}
----

=== Required Additions

[source,java]
----
exports de.cuioss.http.client.adapter;   // NEW
exports de.cuioss.http.client.request;   // NEW
----

== Summary

=== Strengths to Preserve

* ✅ Security validation pipelines
* ✅ SSL/TLS context management
* ✅ Builder pattern for configuration
* ✅ Type-safe `HttpResult<T>` with pattern matching
* ✅ Thread-safe, immutable design
* ✅ Comprehensive logging via CuiLogger

=== Issues to Address

* ❌ Mixed concerns in `ResilientHttpHandler`
* ❌ No POST/PUT/DELETE support
* ❌ No request body handling
* ❌ No type-safe HTTP method enum
* ❌ No Content-Type enum

=== Proposed Solutions

* ✅ Replace `ResilientHttpHandler` with `ETagAwareHttpAdapter` + `ResilientHttpAdapter`
* ✅ Add `HttpMethod` enum (internal-only, package-private)
* ✅ Add `ContentType` enum
* ✅ Make `HttpContentConverter<T>` bidirectional (request + response)
* ✅ Add method-specific `HttpAdapter<T>` interface (`get()`, `post()`, etc.)
* ✅ Implement If-None-Match prevention (only send when cache exists)
* ✅ Handle 304 as application success, not failure
* ✅ Add `CacheKeyHeaderFilter` interface for fine-grained cache key configuration
