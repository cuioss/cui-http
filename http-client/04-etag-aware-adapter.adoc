= ETagAwareHttpAdapter
:toc: left
:toclevels: 3
:sectnums:

Base HTTP adapter with built-in, configurable ETag caching.

== Structural Correctness Pattern

Correctness achieved through program structure rather than runtime validation:

[source,java]
----
public HttpResult<T> send(...) {
    // 1. Retrieve cache entry BEFORE sending request
    CacheEntry cachedEntry = cache.get(cacheKey);

    // 2. Build request with conditional header IF cache exists
    HttpRequest.Builder builder = handler.requestBuilder();
    if (cachedEntry != null) {
        builder.header("If-None-Match", cachedEntry.etag());
    }

    // 3. Send request
    HttpResponse<?> response = httpClient.send(builder.build(), ...);

    // 4. Handle 304
    if (response.statusCode() == 304) {
        // cachedEntry MUST be non-null here!
        // We only sent If-None-Match if cachedEntry existed.
        // Server only sends 304 if If-None-Match was present.
        // Therefore: cachedEntry cannot be null.
        return HttpResult.success(cachedEntry.content(), cachedEntry.etag(), 304);
    }
}
----

**Guarantees:**

* Local reference held throughout request
* Cannot receive 304 without having sent If-None-Match
* Cannot send If-None-Match without cached entry
* Therefore: 304 handling has guaranteed non-null cache entry
* Thread-safe: local reference immune to concurrent cache clearing

**Reliability:** This is a structural design guarantee enforced by program logic. While Java's type system cannot statically verify this at compile time, the implementation ensures 304 can only occur when a cache entry exists. The guarantee is maintained through:

* Sequential flow: cache lookup → If-None-Match decision → request → 304 handling
* Local reference: cache entry captured before request, held throughout
* Logical impossibility: server cannot send 304 without receiving If-None-Match
* Extensive test coverage: unit and integration tests verify this behavior

This approach is more reliable than runtime null checks, which can mask bugs.

== Responsibilities

. Execute requests via HttpHandler
. Convert responses via HttpContentConverter
. Preserve HTTP metadata (ETag, status)
. ETag caching (when enabled):
** Add If-None-Match for GET requests
** Handle 304 Not Modified
** Return cached content for 304
** Update cache on successful responses
. Error categorization

== ETag Extraction from All Responses

ETags are extracted from **all** HTTP responses (GET, POST, PUT, DELETE) and preserved in `HttpResult`, but only GET responses are **cached** for 304 Not Modified handling. This distinction is important:

* **Extraction** - ETag header read from response and stored in HttpResult (all methods)
* **Caching** - Response body stored for 304 reuse (GET only)

This enables **optimistic locking patterns** for subsequent updates:

[source,java]
----
// POST creates resource, returns ETag
HttpResult<User> created = HttpMethod.POST.send(adapter, publisher, user);
String etag = created.getETag().orElseThrow();

// Later: PUT with If-Match for optimistic locking
Map<String, String> headers = Map.of("If-Match", etag);
HttpResult<User> updated = HttpMethod.PUT.send(adapter, publisher, updatedUser, headers);
// Server returns 412 Precondition Failed if resource changed
----

**Use cases:** Conditional updates (If-Match), resource versioning, conflict detection, audit trails.

== 304 Not Modified Flow

[source]
----
1. send() called for GET request

2. send():
   → Retrieve cache entry at START (holds reference)
      CacheEntry cachedEntry = cache.get(cacheKey);
   → If cachedEntry exists with ETag:
      → Add If-None-Match: cachedEntry.etag to request
   → If no cachedEntry:
      → Don't add If-None-Match (normal GET)

3. Server responds: 304 Not Modified, ETag: "cached-etag"

4. send():
   → Detects status == 304
   → Use cachedEntry reference (structurally guaranteed non-null)
   → return HttpResult.success(cachedEntry.content, cachedEntry.etag, 304)
   → Logs at DEBUG level

5. Client receives Success(cachedContent, "cached-etag", 304)
----

**Design:** 304 returned as Success with cached content. Status preserved for metrics/debugging.

=== Why Preserve 304 Status Code?

The 304 status code is preserved in `HttpResult` for:

* **Metrics and Monitoring** - Track cache hit rate, bandwidth savings
* **Debugging** - Distinguish between fresh (200) and cached (304) responses in logs
* **Performance Analysis** - Measure ETag effectiveness
* **Client Logging** - Visibility into caching behavior

**Important:** Client code typically does NOT need to handle 304 differently from 200. Both are Success with content. The status is informational, not actionable:

[source,java]
----
HttpResult<User> result = HttpMethod.GET.send(adapter);

// ✅ GOOD - Treat all Success the same
if (result.isSuccess()) {
    result.getContent().ifPresent(this::processUser);
}

// ❌ BAD - Don't special-case 304 in business logic
if (result.getHttpStatus().orElse(0) == 304) {
    // No need for special handling
}
----

== Builder API

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .contentConverter(userConverter)
    .etagCachingEnabled(true)         // Default: true
    .cacheKeyHeaders(CacheKeyHeaders.ALL)  // Default: ALL (include all headers)
    .build();
----

=== Builder Parameters

[cols="2,2,3"]
|===
|Parameter |Default |Purpose

|`httpHandler`
|Required
|HTTP client configuration (URI, SSL, timeouts)

|`contentConverter`
|Required
|Response body type conversion

|`etagCachingEnabled`
|`true`
|Enable/disable ETag caching entirely

|`cacheKeyHeaders`
|`CacheKeyHeaders.ALL`
|Include headers in cache key (ALL) or use URI only (NONE)
|===

== Cache Key Generation

=== Algorithm

The cache key is generated based on the `cacheKeyHeaders` setting:

[source,java]
----
String cacheKey = generateCacheKey(uri, additionalHeaders, cacheKeyHeaders);

private String generateCacheKey(URI uri,
                                 Map<String, String> headers,
                                 CacheKeyHeaders strategy) {
    StringBuilder key = new StringBuilder(uri.toString());

    // Include headers based on strategy
    if (strategy == CacheKeyHeaders.ALL && !headers.isEmpty()) {
        // Sort headers by key for consistency
        List<String> sortedKeys = new ArrayList<>(headers.keySet());
        Collections.sort(sortedKeys);

        for (String headerName : sortedKeys) {
            key.append('|').append(headerName)
               .append('=').append(headers.get(headerName));
        }
    }
    // If NONE: use URI only (don't append headers)

    return key.toString();
}
----

=== Key Components

* **URI**: From HttpHandler (fixed per adapter instance) - always included
* **Additional headers**: Included only if `cacheKeyHeaders == CacheKeyHeaders.ALL`
* **Separator**: `|` character separates URI from headers

=== Examples with CacheKeyHeaders.ALL (Default)

[source]
----
// Simple GET (no additional headers)
"https://api.example.com/users"

// GET with Authorization header
"https://api.example.com/users|Authorization=Bearer token123"

// GET with multiple headers (sorted alphabetically)
"https://api.example.com/users|Authorization=Bearer token123|X-Request-ID=abc-123"
----

=== Examples with CacheKeyHeaders.NONE

[source]
----
// All requests to same URI use same cache key, regardless of headers:

// User A
"https://api.example.com/users"

// User B (different token, same cache key!)
"https://api.example.com/users"

// Different request ID (same cache key)
"https://api.example.com/users"
----

=== Important Notes

* HTTP method is **not** part of cache key (only GET requests are cached)
* Headers are sorted to ensure `{A, B}` and `{B, A}` produce the same key (when ALL)
* Request body is **not** part of cache key (POST/PUT/DELETE never cached)

**⚠️ Cache Key Strategy Trade-offs:**

The `cacheKeyHeaders` setting affects efficiency and memory usage:

=== CacheKeyHeaders.ALL (Default)

**Pros:**
* ✅ Efficient in multi-user scenarios: Separate cache per user avoids wasted If-None-Match requests
* ✅ Defense-in-depth: Protects against buggy server ETags (e.g., user-agnostic ETags)
* ✅ Safe for shared adapter instances

**Cons:**
* ❌ Token refresh cache bloat: Each token creates new cache entry for same resource
* ❌ Memory grows unbounded without manual clearing

**Mitigation strategies for single-user clients:**

. **Use CacheKeyHeaders.NONE** - Recommended for single-user scenarios (see below)
. **Periodic cache clearing** - Call `adapter.clearETagCache()` after token refresh
. **Disable caching** - Set `etagCachingEnabled(false)`
. **Separate adapter per token** - Create new adapter on token refresh

=== CacheKeyHeaders.NONE (URI Only)

**Pros:**
* ✅ No token refresh cache bloat: Same URI = same cache entry
* ✅ Higher cache hit rate
* ✅ Better memory efficiency

**Cons:**
* ❌ Multi-user inefficiency: Different users' ETags won't match → server sends full 200 responses
* ❌ Relies on server implementing user-aware ETags correctly

**Safe for:**
* Single-user mobile/desktop apps
* Service accounts (one token)
* Per-user adapter instances

**Unsafe for:**
* Shared adapter instances across multiple users
* Multi-tenant web servers

== Usage Examples

=== Default (ETag Caching Enabled)

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .contentConverter(userConverter)
    .build();  // caching ON by default
----

=== Disable ETag Caching

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .contentConverter(userConverter)
    .etagCachingEnabled(false)
    .build();
----

=== URI-Only Cache Keys (Single-User Client)

For mobile apps, desktop apps, or service accounts where token refresh causes cache bloat:

[source,java]
----
// Mobile app - single user, token refreshes frequently
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .contentConverter(userConverter)
    .cacheKeyHeaders(CacheKeyHeaders.NONE)  // URI only, ignore Authorization
    .build();

// Token refresh doesn't create duplicate cache entries
Map<String, String> headers1 = Map.of("Authorization", "Bearer old-token");
HttpResult<User> result1 = HttpMethod.GET.send(adapter, headers1);
// Cache key: "https://api.example.com/users"

// After token refresh
Map<String, String> headers2 = Map.of("Authorization", "Bearer new-token");
HttpResult<User> result2 = HttpMethod.GET.send(adapter, headers2);
// Same cache key: "https://api.example.com/users"
// → 304 Not Modified (cache hit!)
----

=== Per-User Adapter with URI-Only Keys

Combine per-user adapter instances with URI-only cache keys for optimal efficiency:

[source,java]
----
public class UserSession {
    private final HttpAdapter<User> userAdapter;

    public UserSession(HttpHandler handler, HttpContentConverter<User> converter) {
        // Each user gets their own adapter instance
        this.userAdapter = ETagAwareHttpAdapter.<User>builder()
            .httpHandler(handler)
            .contentConverter(converter)
            .cacheKeyHeaders(CacheKeyHeaders.NONE)  // Safe: adapter not shared
            .build();
    }

    // No need to include Authorization in cache key - already isolated per user
}
----

== Cache Management

=== Cache Lifecycle

The ETag cache has an **unbounded, indefinite lifetime**:

* **No TTL (Time-To-Live)** - Entries never expire automatically
* **No size limit** - Cache grows unbounded with unique cache keys
* **Manual clearing only** - Must explicitly call `clearETagCache()`
* **No LRU eviction** - Least-recently-used entries are not removed

=== When to Clear Cache

[source,java]
----
ETagAwareHttpAdapter<User> adapter = ...;

// Clear cache manually
adapter.clearETagCache();
----

**Clear on:** User logout, token refresh, periodic maintenance, configuration change, memory pressure.

**Thread-safe:** In-flight requests hold local cache references. Clearing cache doesn't affect them.

=== Cache Management Strategies

==== Strategy 1: URI-Only Cache Keys (Recommended for Single-User)

Best for mobile apps, desktop apps, or service accounts with token refresh:

[source,java]
----
// Use URI-only cache keys - token changes don't create new cache entries
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .contentConverter(userConverter)
    .cacheKeyHeaders(CacheKeyHeaders.NONE)  // URI only
    .build();

// Token refresh doesn't affect cache
public void refreshAccessToken() {
    String newToken = authService.refreshToken();
    this.currentToken = newToken;
    // No cache clearing needed!
}
----

==== Strategy 1b: Clear on Token Refresh (If Using CacheKeyHeaders.ALL)

Alternative if you must use `CacheKeyHeaders.ALL` (e.g., multi-user server):

[source,java]
----
public void refreshAccessToken() {
    String newToken = authService.refreshToken();

    // Clear ETag cache to prevent bloat from old token cache keys
    userAdapter.clearETagCache();

    this.currentToken = newToken;
}
----

==== Strategy 2: Periodic Clearing

For long-running applications:

[source,java]
----
// Schedule periodic cache clearing (e.g., every 1 hour)
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
scheduler.scheduleAtFixedRate(
    () -> adapter.clearETagCache(),
    1, 1, TimeUnit.HOURS
);
----

==== Strategy 3: Disable Caching for High-Churn Endpoints

For APIs with frequently-changing headers:

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .contentConverter(userConverter)
    .etagCachingEnabled(false)  // Disable caching
    .build();
----

==== Strategy 4: Separate Adapter Per User (Recommended for Multi-User)

For multi-user scenarios, create one adapter instance per user/session:

[source,java]
----
// Create new adapter per user session
public HttpAdapter<User> createAdapterForUser(String userId) {
    return ETagAwareHttpAdapter.<User>builder()
        .httpHandler(handler)
        .contentConverter(userConverter)
        .cacheKeyHeaders(CacheKeyHeaders.NONE)  // Safe: not shared across users
        .build();
}

// When user logs out, adapter (and its cache) is garbage collected
----

**Benefits:**
* No cross-user cache pollution (each user has own adapter)
* Can use `CacheKeyHeaders.NONE` safely
* Automatic cache cleanup on logout
* Better than shared adapter with `CacheKeyHeaders.ALL`

==== Memory Monitoring

Monitor cache size in production:

[source,java]
----
// Log cache statistics periodically
LOGGER.debug("ETag cache entries: {}", adapter.getCacheSize());

// Alert if cache grows too large
if (adapter.getCacheSize() > 10000) {
    LOGGER.warn("ETag cache size exceeded threshold, clearing");
    adapter.clearETagCache();
}
----

**Note:** `getCacheSize()` method should be added to `ETagAwareHttpAdapter` for monitoring.

== Thread Safety

* Builder: NOT thread-safe
* Built adapter: Fully thread-safe (immutable fields, ConcurrentHashMap cache, local references)

== Test Coverage

* ETag caching on/off, If-None-Match conditional sending
* 304 handling, cache hits/misses, ETag preservation
* POST/PUT/DELETE bypass caching
* Network errors, thread safety, concurrent cache clearing
