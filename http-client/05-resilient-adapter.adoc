= ResilientHttpAdapter Implementation
:toc: left
:toclevels: 3
:sectnums:

== Overview

`ResilientHttpAdapter` is an async decorator that adds retry logic with exponential backoff to any `HttpAdapter` implementation. It uses `CompletableFuture` for fully non-blocking retries.

== Design Goals

* *Async-First* - CompletableFuture-based, non-blocking retries
* *Zero Blocking* - No threads blocked during delays or retries
* *Composition* - Wraps any HttpAdapter implementation
* *Single Algorithm* - Exponential backoff with jitter (industry best practice)
* *Fail-Fast* - No retry for non-retryable errors (CLIENT_ERROR)
* *Configurable* - Builder pattern for retry parameters

== Architecture

Async retry with configuration:

[source]
----
RetryConfig (record with calculateDelay method)
    ↓ configures
ResilientHttpAdapter (async retry orchestration)
    ↓ wraps
Any HttpAdapter implementation

CompletableFuture<HttpResult<T>>
    ↓ non-blocking delays using
CompletableFuture.delayedExecutor
----

== RetryConfig Record

Simple data class with builder:

[source,java]
----
package de.cuioss.http.client.adapter;

/**
 * Configuration for retry behavior with exponential backoff.
 * This is a simple data record that configures retry parameters.
 */
public record RetryConfig(
    int maxAttempts,
    Duration initialDelay,
    double multiplier,
    Duration maxDelay,
    double jitter
) {

    /**
     * Creates builder with sensible defaults.
     * See "Default Values" table below for specific defaults.
     */
    public static Builder builder() {
        return new Builder();
    }

    /**
     * Returns default configuration.
     * Equivalent to builder().build()
     */
    public static RetryConfig defaults() {
        return builder().build();
    }

    public static class Builder {
        private int maxAttempts = 5;
        private Duration initialDelay = Duration.ofSeconds(1);
        private double multiplier = 2.0;
        private Duration maxDelay = Duration.ofMinutes(1);
        private double jitter = 0.1;

        public Builder maxAttempts(int maxAttempts) {
            if (maxAttempts < 1) {
                throw new IllegalArgumentException("maxAttempts must be >= 1");
            }
            this.maxAttempts = maxAttempts;
            return this;
        }

        public Builder initialDelay(Duration delay) {
            if (delay == null || delay.isNegative() || delay.isZero()) {
                throw new IllegalArgumentException("initialDelay must be positive");
            }
            this.initialDelay = delay;
            return this;
        }

        public Builder multiplier(double multiplier) {
            if (multiplier < 1.0) {
                throw new IllegalArgumentException("multiplier must be >= 1.0");
            }
            this.multiplier = multiplier;
            return this;
        }

        public Builder maxDelay(Duration maxDelay) {
            if (maxDelay == null || maxDelay.isNegative() || maxDelay.isZero()) {
                throw new IllegalArgumentException("maxDelay must be positive");
            }
            this.maxDelay = maxDelay;
            return this;
        }

        public Builder jitter(double jitter) {
            if (jitter < 0.0 || jitter > 1.0) {
                throw new IllegalArgumentException("jitter must be between 0.0 and 1.0");
            }
            this.jitter = jitter;
            return this;
        }

        public RetryConfig build() {
            return new RetryConfig(maxAttempts, initialDelay, multiplier, maxDelay, jitter);
        }
    }
}
----

=== Default Values

[cols="2,2,3"]
|===
|Parameter |Default Value |Valid Range

|`maxAttempts`
|`5`
|1 or greater (validated)

|`initialDelay`
|`1 second`
|Positive Duration (non-null, non-negative, non-zero, validated)

|`multiplier`
|`2.0`
|1.0 or greater (exponential backoff, validated)

|`maxDelay`
|`1 minute`
|Positive Duration (non-null, non-negative, non-zero, validated)

|`jitter`
|`0.1` (10%)
|0.0 to 1.0 (0% to 100%, validated)
|===

**Notes:**

* `maxAttempts`: Total attempts including initial try (5 = 1 initial + 4 retries)
* `initialDelay`: Starting delay after first failure
* `multiplier`: Each retry delay multiplied by this value (2.0 = doubling)
* `maxDelay`: Cap on delay regardless of exponential growth
* `jitter`: Randomization to prevent thundering herd (0.1 = ±10%)

=== Why These Defaults?

[cols="2,3"]
|===
|Default |Rationale

|**maxAttempts: 5**
|Industry best practice (AWS SDK, Google Cloud SDK). Balances resilience vs. latency. Too few (< 3) = poor resilience. Too many (> 7) = excessive delays on persistent failures.

|**initialDelay: 1s**
|Enough time for transient issues to clear (network hiccup, server restart). Short enough to feel responsive. Sub-second often too fast for real transient issues.

|**multiplier: 2.0**
|Exponential backoff is proven most effective (RFC 8085, AWS best practices). Linear backoff less effective. Higher multipliers (3.0+) cause excessive delays.

|**maxDelay: 60s**
|Prevents runaway delays from exponential growth. After ~4 retries, delays would exceed 16s without cap. 60s balances patience vs. reasonable timeout expectations.

|**jitter: 10%**
|Prevents thundering herd when many clients fail simultaneously. 10% provides sufficient randomization without excessive variance. Based on AWS recommendations.
|===

**References:**

* AWS SDK retry strategies
* RFC 8085 (Congestion Control)
* Google Cloud SDK best practices
* Polly (.NET resilience library) defaults

=== RetryConfig Methods

The record includes a method to calculate delays:

[source,java]
----
/**
 * Calculates delay for given attempt using exponential backoff with jitter.
 * Formula: initialDelay * (multiplier ^ (attempt - 1)) * (1 ± jitter)
 *
 * @param attemptNumber current attempt (1-based)
 * @return calculated delay with jitter applied, capped at maxDelay
 */
@SuppressWarnings("java:S2245") // Random is fine for jitter
public Duration calculateDelay(int attemptNumber) {
    // Exponential backoff: initialDelay * (multiplier ^ (attempt - 1))
    double exponentialDelay = initialDelay.toMillis()
        * Math.pow(multiplier, (double) attemptNumber - 1);

    // Apply jitter: delay * (1 ± jitter)
    // Random value between -1.0 and 1.0
    double randomFactor = 2.0 * ThreadLocalRandom.current().nextDouble() - 1.0;
    double jitterMultiplier = 1.0 + (randomFactor * jitter);
    long delayMs = Math.round(exponentialDelay * jitterMultiplier);

    // Cap at maximum delay
    return Duration.ofMillis(Math.min(delayMs, maxDelay.toMillis()));
}
----

== ResilientHttpAdapter Implementation

[source,java]
----
package de.cuioss.http.client.adapter;

import de.cuioss.tools.logging.CuiLogger;

import java.time.Duration;
import java.util.Map;
import java.util.concurrent.*;
import java.util.function.Supplier;

import static java.util.Objects.requireNonNull;

/**
 * Wraps any HttpAdapter to add retry support with exponential backoff.
 * Retries transient failures (NETWORK_ERROR, SERVER_ERROR) up to configured attempts.
 * All operations are non-blocking using CompletableFuture.
 */
public class ResilientHttpAdapter<T> implements HttpAdapter<T> {
    private static final CuiLogger LOGGER = new CuiLogger(ResilientHttpAdapter.class);

    private final HttpAdapter<T> delegate;
    private final RetryConfig config;

    public ResilientHttpAdapter(HttpAdapter<T> delegate, RetryConfig config) {
        this.delegate = requireNonNull(delegate, "delegate");
        this.config = requireNonNull(config, "config");
    }

    /**
     * Wrap adapter with retry using default configuration.
     */
    public static <T> HttpAdapter<T> wrap(HttpAdapter<T> delegate) {
        return new ResilientHttpAdapter<>(delegate, RetryConfig.defaults());
    }

    /**
     * Wrap adapter with retry using custom configuration.
     */
    public static <T> HttpAdapter<T> wrap(HttpAdapter<T> delegate, RetryConfig config) {
        return new ResilientHttpAdapter<>(delegate, config);
    }

    @Override
    public CompletableFuture<HttpResult<T>> get(Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.get(additionalHeaders), "GET", 1);
    }

    @Override
    public CompletableFuture<HttpResult<T>> post(@Nullable T requestBody, Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.post(requestBody, additionalHeaders), "POST", 1);
    }

    @Override
    public CompletableFuture<HttpResult<T>> put(@Nullable T requestBody, Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.put(requestBody, additionalHeaders), "PUT", 1);
    }

    @Override
    public CompletableFuture<HttpResult<T>> patch(@Nullable T requestBody, Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.patch(requestBody, additionalHeaders), "PATCH", 1);
    }

    @Override
    public CompletableFuture<HttpResult<T>> delete(Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.delete(additionalHeaders), "DELETE", 1);
    }

    @Override
    public CompletableFuture<HttpResult<T>> delete(@Nullable T requestBody, Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.delete(requestBody, additionalHeaders), "DELETE", 1);
    }

    @Override
    public CompletableFuture<HttpResult<T>> head(Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.head(additionalHeaders), "HEAD", 1);
    }

    @Override
    public CompletableFuture<HttpResult<T>> options(Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.options(additionalHeaders), "OPTIONS", 1);
    }

    @Override
    public <R> CompletableFuture<HttpResult<T>> post(HttpRequestConverter<R> requestConverter,
                                                       @Nullable R requestBody,
                                                       Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.post(requestConverter, requestBody, additionalHeaders), "POST", 1);
    }

    @Override
    public <R> CompletableFuture<HttpResult<T>> put(HttpRequestConverter<R> requestConverter,
                                                      @Nullable R requestBody,
                                                      Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.put(requestConverter, requestBody, additionalHeaders), "PUT", 1);
    }

    @Override
    public <R> CompletableFuture<HttpResult<T>> patch(HttpRequestConverter<R> requestConverter,
                                                        @Nullable R requestBody,
                                                        Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.patch(requestConverter, requestBody, additionalHeaders), "PATCH", 1);
    }

    @Override
    public <R> CompletableFuture<HttpResult<T>> delete(HttpRequestConverter<R> requestConverter,
                                                         @Nullable R requestBody,
                                                         Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.delete(requestConverter, requestBody, additionalHeaders), "DELETE", 1);
    }

    /**
     * Executes HTTP operation with retry support using non-blocking delays.
     * The delegate call is already async (returns CompletableFuture), so no
     * additional thread wrapping is needed.
     *
     * @param operation Supplier that returns CompletableFuture of the HTTP operation
     * @param methodName HTTP method name for logging
     * @param attempt Current attempt number (1-based)
     * @return CompletableFuture containing the result or recursive retry
     */
    private CompletableFuture<HttpResult<T>> executeWithRetry(
            Supplier<CompletableFuture<HttpResult<T>>> operation,
            String methodName,
            int attempt) {

        LOGGER.debug("Attempt {}/{} for {} request", attempt, config.maxAttempts(), methodName);

        // Delegate is already async - no supplyAsync needed!
        return operation.get()
                .thenCompose(result -> {
                    // Success - return immediately
                    if (result.isSuccess()) {
                        if (attempt > 1) {
                            LOGGER.debug("{} request succeeded on attempt {}", methodName, attempt);
                        }
                        return CompletableFuture.completedFuture(result);
                    }

                    // Non-retryable failure - return immediately
                    if (!result.isRetryable()) {
                        LOGGER.debug("{} request failed with non-retryable error: {}",
                            methodName, result.getErrorCategory().orElse(null));
                        return CompletableFuture.completedFuture(result);
                    }

                    // Max attempts reached
                    if (attempt >= config.maxAttempts()) {
                        LOGGER.warn("{} request failed after {} attempts", methodName, config.maxAttempts());
                        return CompletableFuture.completedFuture(result);
                    }

                    // Retryable failure - calculate delay and schedule retry
                    Duration delay = config.calculateDelay(attempt);

                    LOGGER.warn("{} request failed on attempt {}, retrying after {}ms",
                        methodName, attempt, delay.toMillis());

                    int nextAttempt = attempt + 1;

                    // Non-blocking delay using delayedExecutor
                    Executor delayedExecutor = CompletableFuture.delayedExecutor(
                        delay.toMillis(), TimeUnit.MILLISECONDS
                    );

                    // Schedule next attempt after delay - no nested futures
                    return CompletableFuture
                        .supplyAsync(() -> null, delayedExecutor)
                        .thenCompose(ignored -> executeWithRetry(operation, methodName, nextAttempt));
                });
    }
}
----

== Usage Examples

=== Default Configuration

[source,java]
----
HttpAdapter<User> baseAdapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .requestConverter(userConverter)
    .build();

// Wrap with retry using defaults (5 attempts, 1s initial, 2.0 multiplier, 1min max, 10% jitter)
HttpAdapter<User> resilientAdapter = ResilientHttpAdapter.wrap(baseAdapter);

// Async execution - all adapter methods return CompletableFuture
CompletableFuture<HttpResult<User>> futureResult = resilientAdapter.get();

// Handle result asynchronously (recommended)
futureResult.thenAccept(result -> {
    if (result.isSuccess()) {
        User user = result.getValue().orElseThrow();
        // Process user
    } else {
        LOGGER.error("Request failed: {}", result.getErrorMessage());
    }
});

// Or use blocking convenience method for simple cases
HttpResult<User> result = resilientAdapter.getBlocking();
----

=== Custom Configuration

[source,java]
----
// Custom retry configuration
RetryConfig customRetry = RetryConfig.builder()
    .maxAttempts(3)                        // Only 3 attempts
    .initialDelay(Duration.ofMillis(500))  // Start with 500ms
    .multiplier(1.5)                       // Slower backoff
    .maxDelay(Duration.ofSeconds(30))      // Cap at 30s
    .jitter(0.2)                           // 20% jitter
    .build();

HttpAdapter<User> resilientAdapter = ResilientHttpAdapter.wrap(baseAdapter, customRetry);

// Chain async operations
User newUser = User.builder().name("John").build();
resilientAdapter.post(newUser, headers)
    .thenApply(result -> result.getValue().orElse(null))
    .thenAccept(savedUser -> LOGGER.info("User saved: {}", savedUser))
    .exceptionally(ex -> {
        LOGGER.error("Async operation failed", ex);
        return null;
    });
----

=== Minimal Retry

[source,java]
----
// Just 2 quick attempts with minimal delay
RetryConfig minimal = RetryConfig.builder()
    .maxAttempts(2)
    .initialDelay(Duration.ofMillis(100))
    .build();

HttpAdapter<User> adapter = ResilientHttpAdapter.wrap(baseAdapter, minimal);

// Parallel async requests
CompletableFuture<HttpResult<User>> user1 = adapter.get(Map.of("X-User-Id", "1"));
CompletableFuture<HttpResult<User>> user2 = adapter.get(Map.of("X-User-Id", "2"));
CompletableFuture<HttpResult<User>> user3 = adapter.get(Map.of("X-User-Id", "3"));

// Wait for all to complete
CompletableFuture.allOf(user1, user2, user3)
    .thenRun(() -> LOGGER.info("All requests completed"));
----

=== Aggressive Retry

[source,java]
----
// More attempts, longer waits for critical operations
RetryConfig aggressive = RetryConfig.builder()
    .maxAttempts(10)
    .initialDelay(Duration.ofSeconds(2))
    .maxDelay(Duration.ofMinutes(5))
    .build();

HttpAdapter<CriticalData> adapter = ResilientHttpAdapter.wrap(baseAdapter, aggressive);

// Timeout on the entire retry cycle (not individual attempts)
CompletableFuture<HttpResult<CriticalData>> future = adapter.get();
CompletableFuture<HttpResult<CriticalData>> withTimeout =
    future.orTimeout(10, TimeUnit.MINUTES);

withTimeout.thenAccept(result -> {
    // Process result
});
----

== Retry Behavior

=== Retryable Errors

Retry happens for:

* `NETWORK_ERROR` - IOException, timeouts, connection failures
* `SERVER_ERROR` - HTTP 5xx responses (503, 502, 500, etc.)

=== Non-Retryable Errors

No retry for:

* `CLIENT_ERROR` - HTTP 4xx (bad request, auth failure, not found, etc.)
* `INVALID_CONTENT` - Response parsing failed
* `CONFIGURATION_ERROR` - SSL issues, invalid URI

*Note:* Most 3xx redirects are followed automatically by `HttpClient`. 304 Not Modified is handled as application success by `ETagAwareHttpAdapter`.

=== Exponential Backoff Example

With defaults (initial=1s, multiplier=2.0, jitter=10%):

[source]
----
Attempt 1: delegate.get() returns CompletableFuture
  ↓ CompletableFuture completes with failure (retryable)
Schedule retry: ~1000ms using delayedExecutor (1s * 2^0 * 1.05)
  ↓ Non-blocking delay

Attempt 2: delegate.get() returns CompletableFuture (after delay)
  ↓ CompletableFuture completes with failure (retryable)
Schedule retry: ~2100ms using delayedExecutor (1s * 2^1 * 1.05)
  ↓ Non-blocking delay

Attempt 3: delegate.get() returns CompletableFuture (after delay)
  ↓ CompletableFuture completes with failure (retryable)
Schedule retry: ~4200ms using delayedExecutor (1s * 2^2 * 1.05)
  ↓ Non-blocking delay

Attempt 4: delegate.get() returns CompletableFuture (after delay)
  ↓ CompletableFuture completes with failure (retryable)
Schedule retry: ~8400ms using delayedExecutor (1s * 2^3 * 1.05)
  ↓ Non-blocking delay

Attempt 5: delegate.get() returns CompletableFuture (after delay, final)
  ↓ CompletableFuture completes with result (success or failure)
----

**Key Points:**

* Zero blocking - delays use `CompletableFuture.delayedExecutor`
* No thread pools needed - CompletableFuture handles scheduling
* Delegate operations are already async (no supplyAsync wrapping)
* Jitter adds randomness (±10%) to prevent thundering herd
* Caller's thread returns immediately

== Async Execution Model

=== Non-Blocking Delays

[source,java]
----
// Delays use CompletableFuture.delayedExecutor (no threads blocked)
CompletableFuture.delayedExecutor(
    delay.toMillis(),
    TimeUnit.MILLISECONDS
)

// Chain next attempt after delay completes
CompletableFuture
    .supplyAsync(() -> null, delayedExecutor)
    .thenCompose(ignored -> executeWithRetry(operation, methodName, nextAttempt))
----

**Benefits:**

* Zero threads blocked during delays
* Millions of concurrent retry operations possible
* Minimal memory overhead per request
* Natural backpressure handling
* No thread pool management needed

=== CompletableFuture Chaining

[source,java]
----
// Pattern: attempt → evaluate → retry or complete (no blocking!)
return operation.get()  // Already returns CompletableFuture
    .thenCompose(result -> {
        if (shouldRetry(result)) {
            // Schedule next attempt after non-blocking delay
            return CompletableFuture
                .supplyAsync(() -> null, delayedExecutor)
                .thenCompose(ignored -> executeWithRetry(operation, methodName, nextAttempt));
        }
        return CompletableFuture.completedFuture(result);
    });
----

**Advantages:**

* Non-blocking throughout entire retry cycle
* No fake async (supplyAsync wrapping of sync calls)
* Compositional - can chain with other async operations
* Timeout-friendly - use `orTimeout()` or `completeOnTimeout()`
* Exception-safe - use `exceptionally()` or `handle()`
* Tail-recursive via `thenCompose()` - no stack overflow

== Thread Safety

* `ResilientHttpAdapter` is thread-safe
* All fields are final and immutable
* Each request gets independent async execution chain
* No shared state between requests
* No thread pool management - uses CompletableFuture's internal scheduling

== Composition

=== With ETag Caching

[source,java]
----
HttpAdapter<User> adapter = ResilientHttpAdapter.wrap(
    ETagAwareHttpAdapter.<User>builder()
        .httpHandler(handler)
        .responseConverter(userConverter)
    .requestConverter(userConverter)
        .build(),
    RetryConfig.defaults()
);

// Async execution with retry + caching
CompletableFuture<HttpResult<User>> future = adapter.get(headers);
----

=== Multiple Async Operations

[source,java]
----
// Execute multiple operations in parallel
List<String> userIds = List.of("123", "456", "789");
List<CompletableFuture<HttpResult<User>>> futures = userIds.stream()
    .map(id -> resilientAdapter.get(Map.of("X-User-Id", id)))
    .toList();

// Wait for all and collect results
CompletableFuture<List<HttpResult<User>>> allResults =
    CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
        .thenApply(v -> futures.stream()
            .map(CompletableFuture::join)
            .toList());
----

== Benefits of Async Approach

[cols="1,2"]
|===
|Benefit |Description

|**Non-blocking**
|Caller thread never blocks during retries - uses CompletableFuture

|**Scalable**
|Non-blocking CompletableFuture enables millions of concurrent retry operations

|**Compositional**
|Can chain with other async operations using `thenCompose()`, `thenApply()`, etc.

|**Timeout-friendly**
|Easy to add timeouts with `orTimeout()` or `completeOnTimeout()`

|**Resource-efficient**
|No thread blocking during delays - uses scheduled executor

|**Modern Java**
|Leverages CompletableFuture async patterns and non-blocking I/O

|**Testable**
|Easy to test with `CompletableFuture` test utilities
|===

== Testing Requirements

* ✅ Default configuration values
* ✅ Custom configuration via builder
* ✅ Retry on NETWORK_ERROR (async)
* ✅ Retry on SERVER_ERROR (async)
* ✅ No retry on CLIENT_ERROR
* ✅ Max attempts respected
* ✅ Exponential backoff delay calculation (via RetryConfig.calculateDelay)
* ✅ Jitter applied correctly (via RetryConfig.calculateDelay)
* ✅ maxDelay cap enforced (via RetryConfig.calculateDelay)
* ✅ CompletableFuture composition
* ✅ Non-blocking delays using delayedExecutor
* ✅ No blocking cascade - delegate already async
* ✅ Success on first attempt (immediate future completion)
* ✅ Success on retry attempt (after async delay)
* ✅ Failure after max attempts
* ✅ Async timeout handling (orTimeout)
* ✅ Parallel execution of multiple requests
* ✅ Composition with ETagAwareHttpAdapter

== Design Decisions

[cols="1,2,2"]
|===
|Decision |Choice |Rationale

|Architecture
|Async decorator with RetryConfig
|Non-blocking, simple configuration object pattern

|Return type
|CompletableFuture<HttpResult<T>>
|Enables non-blocking, compositional async operations

|Execution model
|CompletableFuture with non-blocking delays
|True async, zero blocked threads, millions of concurrent operations

|Delay mechanism
|CompletableFuture.delayedExecutor
|Non-blocking delays, no Thread.sleep, integrates with CompletableFuture

|Retry algorithm
|Exponential backoff only
|Industry best practice, covers 99% of cases

|Delay calculation
|RetryConfig.calculateDelay method
|Configuration record with behavior, keeps logic with config

|Jitter
|Configurable (default 10%)
|Prevents thundering herd

|Thread safety
|Immutable config, stateless adapter
|Safe for concurrent use, each request independent

|Recursion
|Tail-recursive via thenCompose
|Clean async retry chain, no stack overflow risk

|Logging
|WARN for retries, ERROR for exhaustion
|Appropriate visibility for operations team
|===
