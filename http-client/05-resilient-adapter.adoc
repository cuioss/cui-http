= ResilientHttpAdapter Implementation
:toc: left
:toclevels: 3
:sectnums:

== Overview

`ResilientHttpAdapter` is an async decorator that adds retry logic with exponential backoff to any `HttpAdapter` implementation. It uses `CompletableFuture` for non-blocking retries with virtual threads and shared retry logic from `ExponentialBackoffRetryStrategy`.

== Design Goals

* *Async-First* - CompletableFuture-based, non-blocking retries
* *Virtual Threads* - Leverages Java 21+ virtual threads for scalability
* *Code Reuse* - Shares delay calculation and retry logic with ExponentialBackoffRetryStrategy
* *Composition* - Wraps any HttpAdapter implementation
* *Single Algorithm* - Exponential backoff with jitter (industry best practice)
* *Fail-Fast* - No retry for non-retryable errors (CLIENT_ERROR)
* *Configurable* - Builder pattern for retry parameters

== Architecture

Async retry with shared logic:

[source]
----
RetryConfig (record)
    ↓ configures
ResilientHttpAdapter (async retry orchestration)
    ├─ reuses → DelayCalculator (shared with ExponentialBackoffRetryStrategy)
    └─ wraps → Any HttpAdapter implementation

CompletableFuture<HttpResult<T>>
    ↓ non-blocking delays using
Virtual Threads + delayedExecutor
----

== RetryConfig Record

Simple data class with builder:

[source,java]
----
package de.cuioss.http.client.adapter;

/**
 * Configuration for retry behavior with exponential backoff.
 * This is a simple data record that configures retry parameters.
 */
public record RetryConfig(
    int maxAttempts,
    Duration initialDelay,
    double multiplier,
    Duration maxDelay,
    double jitter
) {

    /**
     * Creates builder with sensible defaults.
     * See "Default Values" table below for specific defaults.
     */
    public static Builder builder() {
        return new Builder();
    }

    /**
     * Returns default configuration.
     * Equivalent to builder().build()
     */
    public static RetryConfig defaults() {
        return builder().build();
    }

    public static class Builder {
        private int maxAttempts = 5;
        private Duration initialDelay = Duration.ofSeconds(1);
        private double multiplier = 2.0;
        private Duration maxDelay = Duration.ofMinutes(1);
        private double jitter = 0.1;

        public Builder maxAttempts(int maxAttempts) {
            if (maxAttempts < 1) {
                throw new IllegalArgumentException("maxAttempts must be >= 1");
            }
            this.maxAttempts = maxAttempts;
            return this;
        }

        public Builder initialDelay(Duration delay) {
            if (delay == null || delay.isNegative() || delay.isZero()) {
                throw new IllegalArgumentException("initialDelay must be positive");
            }
            this.initialDelay = delay;
            return this;
        }

        public Builder multiplier(double multiplier) {
            if (multiplier < 1.0) {
                throw new IllegalArgumentException("multiplier must be >= 1.0");
            }
            this.multiplier = multiplier;
            return this;
        }

        public Builder maxDelay(Duration maxDelay) {
            if (maxDelay == null || maxDelay.isNegative() || maxDelay.isZero()) {
                throw new IllegalArgumentException("maxDelay must be positive");
            }
            this.maxDelay = maxDelay;
            return this;
        }

        public Builder jitter(double jitter) {
            if (jitter < 0.0 || jitter > 1.0) {
                throw new IllegalArgumentException("jitter must be between 0.0 and 1.0");
            }
            this.jitter = jitter;
            return this;
        }

        public RetryConfig build() {
            return new RetryConfig(maxAttempts, initialDelay, multiplier, maxDelay, jitter);
        }
    }
}
----

=== Default Values

[cols="2,2,3"]
|===
|Parameter |Default Value |Valid Range

|`maxAttempts`
|`5`
|1 or greater (validated)

|`initialDelay`
|`1 second`
|Positive Duration (non-null, non-negative, non-zero, validated)

|`multiplier`
|`2.0`
|1.0 or greater (exponential backoff, validated)

|`maxDelay`
|`1 minute`
|Positive Duration (non-null, non-negative, non-zero, validated)

|`jitter`
|`0.1` (10%)
|0.0 to 1.0 (0% to 100%, validated)
|===

**Notes:**

* `maxAttempts`: Total attempts including initial try (5 = 1 initial + 4 retries)
* `initialDelay`: Starting delay after first failure
* `multiplier`: Each retry delay multiplied by this value (2.0 = doubling)
* `maxDelay`: Cap on delay regardless of exponential growth
* `jitter`: Randomization to prevent thundering herd (0.1 = ±10%)

=== Why These Defaults?

[cols="2,3"]
|===
|Default |Rationale

|**maxAttempts: 5**
|Industry best practice (AWS SDK, Google Cloud SDK). Balances resilience vs. latency. Too few (< 3) = poor resilience. Too many (> 7) = excessive delays on persistent failures.

|**initialDelay: 1s**
|Enough time for transient issues to clear (network hiccup, server restart). Short enough to feel responsive. Sub-second often too fast for real transient issues.

|**multiplier: 2.0**
|Exponential backoff is proven most effective (RFC 8085, AWS best practices). Linear backoff less effective. Higher multipliers (3.0+) cause excessive delays.

|**maxDelay: 60s**
|Prevents runaway delays from exponential growth. After ~4 retries, delays would exceed 16s without cap. 60s balances patience vs. reasonable timeout expectations.

|**jitter: 10%**
|Prevents thundering herd when many clients fail simultaneously. 10% provides sufficient randomization without excessive variance. Based on AWS recommendations.
|===

**References:**

* AWS SDK retry strategies
* RFC 8085 (Congestion Control)
* Google Cloud SDK best practices
* Polly (.NET resilience library) defaults

== DelayCalculator (Shared Logic)

Extracted for reuse between `ResilientHttpAdapter` and `ExponentialBackoffRetryStrategy`:

[source,java]
----
package de.cuioss.http.client.retry;

import java.time.Duration;
import java.util.concurrent.ThreadLocalRandom;

/**
 * Calculates exponential backoff delays with jitter.
 * Shared by ResilientHttpAdapter and ExponentialBackoffRetryStrategy.
 */
public final class DelayCalculator {

    private DelayCalculator() {} // Utility class

    /**
     * Calculates delay for given attempt using exponential backoff with jitter.
     *
     * @param attemptNumber current attempt (1-based)
     * @param initialDelay starting delay
     * @param backoffMultiplier exponential multiplier
     * @param maxDelay maximum delay cap
     * @param jitterFactor randomization factor (0.0-1.0)
     * @return calculated delay with jitter applied
     */
    @SuppressWarnings("java:S2245") // Random is fine for jitter
    public static Duration calculateDelay(int attemptNumber, Duration initialDelay,
                                         double backoffMultiplier, Duration maxDelay,
                                         double jitterFactor) {
        // Exponential backoff: initialDelay * (multiplier ^ (attempt - 1))
        double exponentialDelay = initialDelay.toMillis()
            * Math.pow(backoffMultiplier, (double) attemptNumber - 1);

        // Apply jitter: delay * (1 ± jitterFactor)
        // Random value between -1.0 and 1.0
        double randomFactor = 2.0 * ThreadLocalRandom.current().nextDouble() - 1.0;
        double jitter = 1.0 + (randomFactor * jitterFactor);
        long delayMs = Math.round(exponentialDelay * jitter);

        // Cap at maximum delay
        return Duration.ofMillis(Math.min(delayMs, maxDelay.toMillis()));
    }
}
----

== ResilientHttpAdapter Implementation

[source,java]
----
package de.cuioss.http.client.adapter;

import de.cuioss.http.client.retry.DelayCalculator;
import de.cuioss.tools.logging.CuiLogger;

import java.time.Duration;
import java.util.Map;
import java.util.concurrent.*;

import static java.util.Objects.requireNonNull;

/**
 * Wraps any HttpAdapter to add async retry support with exponential backoff.
 * Retries transient failures (NETWORK_ERROR, SERVER_ERROR) up to configured attempts.
 * Uses CompletableFuture and virtual threads for non-blocking operation.
 */
public class ResilientHttpAdapter<T> implements HttpAdapter<T> {
    private static final CuiLogger LOGGER = new CuiLogger(ResilientHttpAdapter.class);

    private final HttpAdapter<T> delegate;
    private final RetryConfig config;

    public ResilientHttpAdapter(HttpAdapter<T> delegate, RetryConfig config) {
        this.delegate = requireNonNull(delegate, "delegate");
        this.config = requireNonNull(config, "config");
    }

    /**
     * Wrap adapter with retry using default configuration.
     */
    public static <T> HttpAdapter<T> wrap(HttpAdapter<T> delegate) {
        return new ResilientHttpAdapter<>(delegate, RetryConfig.defaults());
    }

    /**
     * Wrap adapter with retry using custom configuration.
     */
    public static <T> HttpAdapter<T> wrap(HttpAdapter<T> delegate, RetryConfig config) {
        return new ResilientHttpAdapter<>(delegate, config);
    }

    @Override
    public <R> CompletableFuture<HttpResult<T>> send(
            HttpMethod method,
            HttpRequestBodyPublisher<R> bodyPublisher,
            @Nullable R requestBody,
            Map<String, String> additionalHeaders) {

        String operationName = method.methodName() + " request";
        return executeAttempt(method, bodyPublisher, requestBody, additionalHeaders,
                             operationName, 1);
    }

    /**
     * Executes a single retry attempt using virtual threads with async delays.
     *
     * @param method HTTP method
     * @param bodyPublisher request body publisher
     * @param requestBody request body
     * @param additionalHeaders additional headers
     * @param operationName operation name for logging
     * @param attempt current attempt number (1-based)
     * @return CompletableFuture containing the result of this attempt or recursive retry
     */
    private <R> CompletableFuture<HttpResult<T>> executeAttempt(
            HttpMethod method,
            HttpRequestBodyPublisher<R> bodyPublisher,
            @Nullable R requestBody,
            Map<String, String> additionalHeaders,
            String operationName,
            int attempt) {

        // Execute operation on virtual thread
        return CompletableFuture
                .supplyAsync(() -> {
                    LOGGER.debug("Attempt {}/{} for {}", attempt, config.maxAttempts(), operationName);
                    return delegate.send(method, bodyPublisher, requestBody, additionalHeaders);
                }, Executors.newVirtualThreadPerTaskExecutor())
                .thenCompose(result -> {
                    // Success - return immediately
                    if (result.isSuccess()) {
                        if (attempt > 1) {
                            LOGGER.info("{} succeeded on attempt {}", operationName, attempt);
                        }
                        return CompletableFuture.completedFuture(result);
                    }

                    // Non-retryable failure - return immediately
                    if (!result.isRetryable()) {
                        LOGGER.debug("{} failed with non-retryable error: {}",
                            operationName, result.getErrorCategory().orElse(null));
                        return CompletableFuture.completedFuture(result);
                    }

                    // Max attempts reached
                    if (attempt >= config.maxAttempts()) {
                        LOGGER.error("{} failed after {} attempts", operationName, config.maxAttempts());
                        return CompletableFuture.completedFuture(result);
                    }

                    // Retryable failure - calculate delay and schedule retry
                    Duration delay = DelayCalculator.calculateDelay(
                        attempt,
                        config.initialDelay(),
                        config.multiplier(),
                        config.maxDelay(),
                        config.jitter()
                    );

                    LOGGER.warn("{} failed on attempt {}, retrying after {}ms",
                        operationName, attempt, delay.toMillis());

                    int nextAttempt = attempt + 1;

                    // Use CompletableFuture.delayedExecutor with virtual threads
                    Executor delayedExecutor = CompletableFuture.delayedExecutor(
                        delay.toMillis(), TimeUnit.MILLISECONDS,
                        Executors.newVirtualThreadPerTaskExecutor()
                    );

                    // Schedule next attempt after delay
                    return CompletableFuture
                        .supplyAsync(() -> executeAttempt(method, bodyPublisher, requestBody,
                                                         additionalHeaders, operationName, nextAttempt),
                                    delayedExecutor)
                        .thenCompose(future -> future);
                });
    }
}
----

== Usage Examples

=== Default Configuration

[source,java]
----
HttpAdapter<User> baseAdapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .contentConverter(userConverter)
    .build();

// Wrap with retry using defaults (5 attempts, 1s initial, 2.0 multiplier, 1min max, 10% jitter)
HttpAdapter<User> resilientAdapter = ResilientHttpAdapter.wrap(
    baseAdapter,
    RetryConfig.defaults()
);

// Async execution - returns CompletableFuture
CompletableFuture<HttpResult<User>> futureResult = resilientAdapter.send(
    HttpMethod.GET,
    HttpRequestBodyPublisher.empty(),
    null,
    Map.of()
);

// Handle result asynchronously
futureResult.thenAccept(result -> {
    if (result.isSuccess()) {
        User user = result.getValue().orElseThrow();
        // Process user
    } else {
        LOGGER.error("Request failed: {}", result.getErrorMessage());
    }
});

// Or block if needed (not recommended in async contexts)
HttpResult<User> result = futureResult.join();
----

=== Custom Configuration

[source,java]
----
// Custom retry configuration
RetryConfig customRetry = RetryConfig.builder()
    .maxAttempts(3)                        // Only 3 attempts
    .initialDelay(Duration.ofMillis(500))  // Start with 500ms
    .multiplier(1.5)                       // Slower backoff
    .maxDelay(Duration.ofSeconds(30))      // Cap at 30s
    .jitter(0.2)                           // 20% jitter
    .build();

HttpAdapter<User> resilientAdapter = ResilientHttpAdapter.wrap(baseAdapter, customRetry);

// Chain async operations
resilientAdapter.send(HttpMethod.POST, bodyPublisher, user, headers)
    .thenApply(result -> result.getValue().orElse(null))
    .thenAccept(savedUser -> LOGGER.info("User saved: {}", savedUser))
    .exceptionally(ex -> {
        LOGGER.error("Async operation failed", ex);
        return null;
    });
----

=== Minimal Retry

[source,java]
----
// Just 2 quick attempts with minimal delay
RetryConfig minimal = RetryConfig.builder()
    .maxAttempts(2)
    .initialDelay(Duration.ofMillis(100))
    .build();

HttpAdapter<User> adapter = ResilientHttpAdapter.wrap(baseAdapter, minimal);

// Parallel async requests
CompletableFuture<HttpResult<User>> user1 = adapter.send(/*...*/);
CompletableFuture<HttpResult<User>> user2 = adapter.send(/*...*/);
CompletableFuture<HttpResult<User>> user3 = adapter.send(/*...*/);

// Wait for all to complete
CompletableFuture.allOf(user1, user2, user3)
    .thenRun(() -> LOGGER.info("All requests completed"));
----

=== Aggressive Retry

[source,java]
----
// More attempts, longer waits for critical operations
RetryConfig aggressive = RetryConfig.builder()
    .maxAttempts(10)
    .initialDelay(Duration.ofSeconds(2))
    .maxDelay(Duration.ofMinutes(5))
    .build();

HttpAdapter<CriticalData> adapter = ResilientHttpAdapter.wrap(baseAdapter, aggressive);

// Timeout on the future, not on individual attempts
CompletableFuture<HttpResult<CriticalData>> future = adapter.send(/*...*/);
CompletableFuture<HttpResult<CriticalData>> withTimeout =
    future.orTimeout(10, TimeUnit.MINUTES);

withTimeout.thenAccept(result -> {
    // Process result
});
----

== Retry Behavior

=== Retryable Errors

Retry happens for:

* `NETWORK_ERROR` - IOException, timeouts, connection failures
* `SERVER_ERROR` - HTTP 5xx responses (503, 502, 500, etc.)

=== Non-Retryable Errors

No retry for:

* `CLIENT_ERROR` - HTTP 4xx (bad request, auth failure, not found, etc.)
* `INVALID_CONTENT` - Response parsing failed
* `CONFIGURATION_ERROR` - SSL issues, invalid URI

*Note:* Most 3xx redirects are followed automatically by `HttpClient`. 304 Not Modified is handled as application success by `ETagAwareHttpAdapter`.

=== Exponential Backoff Example

With defaults (initial=1s, multiplier=2.0, jitter=10%):

[source]
----
Attempt 1: Execute on virtual thread
  ↓ CompletableFuture completes with failure (retryable)
Schedule retry: ~1000ms using delayedExecutor (1s * 2^0 * 1.05)

Attempt 2: Execute on new virtual thread after delay
  ↓ CompletableFuture completes with failure (retryable)
Schedule retry: ~2100ms using delayedExecutor (1s * 2^1 * 1.05)

Attempt 3: Execute on new virtual thread after delay
  ↓ CompletableFuture completes with failure (retryable)
Schedule retry: ~4200ms using delayedExecutor (1s * 2^2 * 1.05)

Attempt 4: Execute on new virtual thread after delay
  ↓ CompletableFuture completes with failure (retryable)
Schedule retry: ~8400ms using delayedExecutor (1s * 2^3 * 1.05)

Attempt 5: Execute on new virtual thread after delay (final)
  ↓ CompletableFuture completes with result (success or failure)
----

**Key Points:**

* No blocking - delays use `CompletableFuture.delayedExecutor`
* Each attempt runs on a fresh virtual thread
* Jitter adds randomness (±10%) to prevent thundering herd
* Caller's thread never blocks during retries

== Async Execution Model

=== Virtual Threads

[source,java]
----
// Each attempt executes on a new virtual thread
Executors.newVirtualThreadPerTaskExecutor()

// Delays use scheduled executor with virtual threads
CompletableFuture.delayedExecutor(
    delay.toMillis(),
    TimeUnit.MILLISECONDS,
    Executors.newVirtualThreadPerTaskExecutor()
)
----

**Benefits:**

* Millions of concurrent operations possible
* No thread pool exhaustion
* Minimal memory overhead per request
* Natural backpressure handling

=== CompletableFuture Chaining

[source,java]
----
// Pattern: attempt → evaluate → retry or complete
CompletableFuture
    .supplyAsync(() -> delegate.send(...), virtualThreadExecutor)
    .thenCompose(result -> {
        if (shouldRetry(result)) {
            // Schedule next attempt after delay
            return CompletableFuture
                .supplyAsync(() -> executeAttempt(...), delayedExecutor)
                .thenCompose(future -> future);
        }
        return CompletableFuture.completedFuture(result);
    });
----

**Advantages:**

* Non-blocking throughout entire retry cycle
* Compositional - can chain with other async operations
* Timeout-friendly - use `orTimeout()` or `completeOnTimeout()`
* Exception-safe - use `exceptionally()` or `handle()`

== Thread Safety

* `ResilientHttpAdapter` is thread-safe
* All fields are final and immutable
* Each request gets independent async execution chain
* No shared state between requests
* Virtual threads eliminate traditional thread pool concerns

== Composition

=== With ETag Caching

[source,java]
----
HttpAdapter<User> adapter = ResilientHttpAdapter.wrap(
    ETagAwareHttpAdapter.<User>builder()
        .httpHandler(handler)
        .contentConverter(userConverter)
        .build(),
    RetryConfig.defaults()
);

// Async execution with retry + caching
CompletableFuture<HttpResult<User>> future = adapter.send(
    HttpMethod.GET,
    HttpRequestBodyPublisher.empty(),
    null,
    headers
);
----

=== Multiple Async Operations

[source,java]
----
// Execute multiple operations in parallel
List<CompletableFuture<HttpResult<User>>> futures = userIds.stream()
    .map(id -> resilientAdapter.send(
        HttpMethod.GET,
        HttpRequestBodyPublisher.empty(),
        null,
        Map.of("X-User-Id", id)
    ))
    .toList();

// Wait for all and collect results
CompletableFuture<List<HttpResult<User>>> allResults =
    CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
        .thenApply(v -> futures.stream()
            .map(CompletableFuture::join)
            .toList());
----

== Code Reuse with ExponentialBackoffRetryStrategy

Both `ResilientHttpAdapter` and `ExponentialBackoffRetryStrategy` share:

[cols="1,2"]
|===
|Shared Component |Location

|**DelayCalculator**
|`de.cuioss.http.client.retry.DelayCalculator` - calculates exponential backoff with jitter

|**RetryConfig fields**
|Same configuration parameters (maxAttempts, initialDelay, multiplier, maxDelay, jitter)

|**Virtual thread pattern**
|`Executors.newVirtualThreadPerTaskExecutor()`

|**Async delay pattern**
|`CompletableFuture.delayedExecutor(delay, MILLISECONDS, virtualThreadExecutor)`
|===

**Benefits:**

* Single source of truth for delay calculation
* Consistent retry behavior across HTTP client and general retry use cases
* Same algorithm tuning applies everywhere
* Less code duplication, easier maintenance

== Benefits of Async Approach

[cols="1,2"]
|===
|Benefit |Description

|**Non-blocking**
|Caller thread never blocks during retries - uses CompletableFuture

|**Scalable**
|Virtual threads enable millions of concurrent retry operations

|**Compositional**
|Can chain with other async operations using `thenCompose()`, `thenApply()`, etc.

|**Timeout-friendly**
|Easy to add timeouts with `orTimeout()` or `completeOnTimeout()`

|**Resource-efficient**
|No thread pool exhaustion - virtual threads are cheap

|**Modern Java**
|Leverages Java 21+ features (virtual threads, structured concurrency patterns)

|**Testable**
|Easy to test with `CompletableFuture` test utilities

|**Shared logic**
|Reuses `DelayCalculator` with `ExponentialBackoffRetryStrategy`
|===

== Testing Requirements

* ✅ Default configuration values
* ✅ Custom configuration via builder
* ✅ Retry on NETWORK_ERROR (async)
* ✅ Retry on SERVER_ERROR (async)
* ✅ No retry on CLIENT_ERROR
* ✅ Max attempts respected
* ✅ Exponential backoff delay calculation (via DelayCalculator)
* ✅ Jitter applied correctly (via DelayCalculator)
* ✅ maxDelay cap enforced (via DelayCalculator)
* ✅ CompletableFuture composition
* ✅ Virtual thread execution
* ✅ Non-blocking delays using delayedExecutor
* ✅ Success on first attempt (immediate future completion)
* ✅ Success on retry attempt (after async delay)
* ✅ Failure after max attempts
* ✅ Async timeout handling (orTimeout)
* ✅ Parallel execution of multiple requests
* ✅ Composition with ETagAwareHttpAdapter
* ✅ DelayCalculator shared logic correctness

== Design Decisions

[cols="1,2,2"]
|===
|Decision |Choice |Rationale

|Architecture
|Async decorator with shared utilities
|Non-blocking, reuses logic with ExponentialBackoffRetryStrategy

|Return type
|CompletableFuture<HttpResult<T>>
|Enables non-blocking, compositional async operations

|Execution model
|Virtual threads
|Scalable, millions of concurrent operations, no thread pool limits

|Delay mechanism
|CompletableFuture.delayedExecutor
|Non-blocking delays, no Thread.sleep, integrates with CompletableFuture

|Retry algorithm
|Exponential backoff only
|Industry best practice, covers 99% of cases

|Code reuse
|Shared DelayCalculator utility
|Single source of truth for delay calculation logic

|Jitter
|Configurable (default 10%)
|Prevents thundering herd, same algorithm as ExponentialBackoffRetryStrategy

|Thread safety
|Immutable config, stateless adapter
|Safe for concurrent use, each request independent

|Recursion
|Tail-recursive via thenCompose
|Clean async retry chain, no stack overflow risk

|Logging
|WARN for retries, ERROR for exhaustion
|Appropriate visibility for operations team
|===

== Migration from Sync to Async

If you have existing synchronous code:

[cols="1,1"]
|===
|Old (Synchronous) |New (Asynchronous)

a|[source,java]
----
HttpResult<T> result =
  adapter.send(...);
----
a|[source,java]
----
CompletableFuture<HttpResult<T>> future =
  adapter.send(...);
HttpResult<T> result = future.join();
----

a|[source,java]
----
if (result.isSuccess()) {
  process(result.getValue());
}
----
a|[source,java]
----
future.thenAccept(result -> {
  if (result.isSuccess()) {
    process(result.getValue());
  }
});
----

a|[source,java]
----
// Multiple sequential calls
var r1 = adapter.send(...);
var r2 = adapter.send(...);
var r3 = adapter.send(...);
----
a|[source,java]
----
// Multiple parallel calls
var f1 = adapter.send(...);
var f2 = adapter.send(...);
var f3 = adapter.send(...);
CompletableFuture.allOf(f1, f2, f3).join();
----
|===
