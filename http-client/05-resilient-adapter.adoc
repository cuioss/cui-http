= ResilientHttpAdapter Implementation
:toc: left
:toc-title: Table of Contents
:toclevels: 3
:sectnums:
:source-highlighter: highlight.js

== Overview

`ResilientHttpAdapter` is an async decorator that adds retry logic with exponential backoff to any `HttpAdapter` implementation. It uses `CompletableFuture` for fully non-blocking retries.

== Design Goals

* *Async-First* - CompletableFuture-based, non-blocking retries
* *Zero Blocking* - No threads blocked during delays or retries
* *Composition* - Wraps any HttpAdapter implementation
* *Single Algorithm* - Exponential backoff with jitter (industry best practice)
* *Fail-Fast* - No retry for non-retryable errors (CLIENT_ERROR)
* *Configurable* - Builder pattern for retry parameters

== Architecture

Async retry with configuration:

[source]
----
RetryConfig (record with calculateDelay method)
    ‚Üì configures
ResilientHttpAdapter (async retry orchestration)
    ‚Üì wraps
Any HttpAdapter implementation

CompletableFuture<HttpResult<T>>
    ‚Üì non-blocking delays using
CompletableFuture.delayedExecutor
----

== RetryConfig Record

Simple data class with builder:

[source,java]
----
package de.cuioss.http.client.adapter;

/**
 * Configuration for retry behavior with exponential backoff.
 * This is a simple data record that configures retry parameters.
 */
public record RetryConfig(
    int maxAttempts,
    Duration initialDelay,
    double multiplier,
    Duration maxDelay,
    double jitter,
    boolean idempotentOnly
) {

    /**
     * Creates builder with sensible defaults.
     * See "Default Values" table below for specific defaults.
     */
    public static Builder builder() {
        return new Builder();
    }

    /**
     * Returns default configuration.
     * Equivalent to builder().build()
     */
    public static RetryConfig defaults() {
        return builder().build();
    }

    public static class Builder {
        private int maxAttempts = 5;
        private Duration initialDelay = Duration.ofSeconds(1);
        private double multiplier = 2.0;
        private Duration maxDelay = Duration.ofMinutes(1);
        private double jitter = 0.1;
        private boolean idempotentOnly = false;

        public Builder maxAttempts(int maxAttempts) {
            if (maxAttempts < 1) {
                throw new IllegalArgumentException("maxAttempts must be >= 1");
            }
            this.maxAttempts = maxAttempts;
            return this;
        }

        public Builder initialDelay(Duration delay) {
            if (delay == null || delay.isNegative() || delay.isZero()) {
                throw new IllegalArgumentException("initialDelay must be positive");
            }
            this.initialDelay = delay;
            return this;
        }

        public Builder multiplier(double multiplier) {
            if (multiplier < 1.0) {
                throw new IllegalArgumentException("multiplier must be >= 1.0");
            }
            this.multiplier = multiplier;
            return this;
        }

        public Builder maxDelay(Duration maxDelay) {
            if (maxDelay == null || maxDelay.isNegative() || maxDelay.isZero()) {
                throw new IllegalArgumentException("maxDelay must be positive");
            }
            this.maxDelay = maxDelay;
            return this;
        }

        public Builder jitter(double jitter) {
            if (jitter < 0.0 || jitter > 1.0) {
                throw new IllegalArgumentException("jitter must be between 0.0 and 1.0");
            }
            this.jitter = jitter;
            return this;
        }

        /**
         * Only retry idempotent methods (GET, PUT, DELETE, HEAD, OPTIONS).
         * POST and PATCH will never be retried when enabled.
         *
         * @param idempotentOnly true to skip retry for POST/PATCH
         * @return builder for chaining
         */
        public Builder idempotentOnly(boolean idempotentOnly) {
            this.idempotentOnly = idempotentOnly;
            return this;
        }

        public RetryConfig build() {
            return new RetryConfig(maxAttempts, initialDelay, multiplier, maxDelay, jitter, idempotentOnly);
        }
    }
}
----

=== Default Values

[cols="2,2,3"]
|===
|Parameter |Default Value |Valid Range

|`maxAttempts`
|`5`
|1 or greater (validated)

|`initialDelay`
|`1 second`
|Positive Duration (non-null, non-negative, non-zero, validated)

|`multiplier`
|`2.0`
|1.0 or greater (exponential backoff, validated)

|`maxDelay`
|`1 minute`
|Positive Duration (non-null, non-negative, non-zero, validated)

|`jitter`
|`0.1` (10%)
|0.0 to 1.0 (0% to 100%, validated)

|`idempotentOnly`
|`false`
|true or false (retries all methods if false, only idempotent methods if true)
|===

**Notes:**

* `maxAttempts`: Total attempts including initial try (5 = 1 initial + 4 retries)
* `initialDelay`: Starting delay after first failure
* `multiplier`: Each retry delay multiplied by this value (2.0 = doubling)
* `maxDelay`: Cap on delay regardless of exponential growth
* `jitter`: Randomization to prevent thundering herd (0.1 = ¬±10%)
* `idempotentOnly`: When true, only retry GET/PUT/DELETE/HEAD/OPTIONS; skip POST/PATCH

=== Why These Defaults?

[cols="2,3"]
|===
|Default |Rationale

|**maxAttempts: 5**
|Industry best practice (AWS SDK, Google Cloud SDK). Balances resilience vs. latency. Too few (< 3) = poor resilience. Too many (> 7) = excessive delays on persistent failures.

|**initialDelay: 1s**
|Enough time for transient issues to clear (network hiccup, server restart). Short enough to feel responsive. Sub-second often too fast for real transient issues.

|**multiplier: 2.0**
|Exponential backoff is proven most effective (RFC 8085, AWS best practices). Linear backoff less effective. Higher multipliers (3.0+) cause excessive delays.

|**maxDelay: 60s**
|Prevents runaway delays from exponential growth. After ~4 retries, delays would exceed 16s without cap. 60s balances patience vs. reasonable timeout expectations.

|**jitter: 10%**
|Prevents thundering herd when many clients fail simultaneously. 10% provides sufficient randomization without excessive variance. Based on AWS recommendations.

|**idempotentOnly: false**
|Conservative default: retries all methods. Users must explicitly opt-in to idempotent-only retry to prevent accidental POST/PATCH retries. Change to true if your application uses idempotency keys or wants strict safety.
|===

**References:**

* AWS SDK retry strategies
* RFC 8085 (Congestion Control)
* Google Cloud SDK best practices
* Polly (.NET resilience library) defaults

=== RetryConfig Methods

The record includes a method to calculate delays:

[source,java]
----
/**
 * Calculates delay for given attempt using exponential backoff with jitter.
 * Formula: initialDelay * (multiplier ^ (attempt - 1)) * (1 ¬± jitter)
 *
 * @param attemptNumber current attempt (1-based)
 * @return calculated delay with jitter applied, capped at maxDelay
 */
@SuppressWarnings("java:S2245") // Random is fine for jitter
public Duration calculateDelay(int attemptNumber) {
    // Exponential backoff: initialDelay * (multiplier ^ (attempt - 1))
    double exponentialDelay = initialDelay.toMillis()
        * Math.pow(multiplier, (double) attemptNumber - 1);

    // Apply jitter: delay * (1 ¬± jitter)
    // Random value between -1.0 and 1.0
    double randomFactor = 2.0 * ThreadLocalRandom.current().nextDouble() - 1.0;
    double jitterMultiplier = 1.0 + (randomFactor * jitter);
    long delayMs = Math.round(exponentialDelay * jitterMultiplier);

    // Cap at maximum delay
    return Duration.ofMillis(Math.min(delayMs, maxDelay.toMillis()));
}
----

== Idempotency Considerations

**CRITICAL SAFETY WARNING:** Retrying non-idempotent operations can cause unintended side effects.

=== HTTP Method Idempotency

[cols="1,1,3"]
|===
|Method |Idempotent? |Retry Safety

|**GET**
|‚úÖ Yes
|Safe to retry - reads don't change state

|**HEAD**
|‚úÖ Yes
|Safe to retry - metadata only, no state change

|**OPTIONS**
|‚úÖ Yes
|Safe to retry - queries capabilities, no state change

|**PUT**
|‚úÖ Yes
|Safe to retry - multiple identical PUTs produce same result

|**DELETE**
|‚úÖ Yes*
|Usually safe - DELETE on non-existent resource typically succeeds

|**POST**
|‚ùå No
|**UNSAFE** - May create duplicate resources

|**PATCH**
|‚ùå No
|**UNSAFE** - May apply changes multiple times
|===

*DELETE idempotency depends on server implementation (404 vs 204 for non-existent resources)

=== Risks of Retrying Non-Idempotent Operations

==== POST Risk: Duplicate Resource Creation

[source,java]
----
// DANGEROUS: Retry on network timeout might create duplicates
HttpAdapter<Order> adapter = ResilientHttpAdapter.wrap(baseAdapter);

Order order = new Order(items, totalPrice);
HttpResult<Order> result = adapter.postBlocking(order);

// Scenario:
// Attempt 1: Request sent, server creates order, response lost (network timeout)
// Attempt 2: Retry creates SECOND order with same data
// Result: Customer charged twice!
----

**Impact:** Duplicate orders, payments, emails, database records.

==== PATCH Risk: Applying Changes Multiple Times

[source,java]
----
// DANGEROUS: Retry might apply increment twice
PatchRequest adjustInventory = new PatchRequest("increment", "quantity", 5);
adapter.patchBlocking(adjustInventory);

// Scenario:
// Attempt 1: Server increments quantity by 5, response lost
// Attempt 2: Retry increments quantity by 5 AGAIN
// Result: Quantity increased by 10 instead of 5!
----

**Impact:** Incorrect state, data corruption, inconsistent balances.

=== Mitigation Strategies

==== Option 1: Only Retry Idempotent Methods (Recommended)

Configure `ResilientHttpAdapter` to skip retry for POST/PATCH:

[source,java]
----
RetryConfig config = RetryConfig.builder()
    .maxAttempts(5)
    .idempotentOnly(true)  // Only retry GET, PUT, DELETE, HEAD, OPTIONS
    .build();

HttpAdapter<User> adapter = ResilientHttpAdapter.wrap(baseAdapter, config);

// POST/PATCH execute once, GET/PUT/DELETE retry on failure
----

**Status:** Available in version 1.0.

==== Option 2: Use Idempotency Keys

Implement idempotency at application level using unique keys:

[source,java]
----
// Generate unique idempotency key per operation
String idempotencyKey = UUID.randomUUID().toString();

Map<String, String> headers = Map.of(
    "Idempotency-Key", idempotencyKey
);

HttpResult<Order> result = adapter.post(order, headers);

// Server uses key to detect duplicate requests
// Retry with same key returns original result, doesn't create duplicate
----

**Server Implementation:**
[source,java]
----
// Server-side pseudocode
if (cache.containsKey(idempotencyKey)) {
    return cache.get(idempotencyKey);  // Return cached result
}

Order created = createOrder(request);
cache.put(idempotencyKey, created);
return created;
----

**Standards:**

* Stripe API uses `Idempotency-Key` header
* Many REST APIs support similar patterns
* Requires server-side implementation

==== Option 3: Don't Use ResilientHttpAdapter for POST/PATCH

Only wrap safe operations:

[source,java]
----
// Base adapter without retry
HttpAdapter<Order> postAdapter = ETagAwareHttpAdapter.<Order>builder()
    .httpHandler(handler)
    .responseConverter(orderConverter)
    .build();

// Resilient adapter only for GET (safe to retry)
HttpAdapter<Order> getAdapter = ResilientHttpAdapter.wrap(postAdapter);

// Use appropriate adapter per operation
HttpResult<Order> created = postAdapter.postBlocking(newOrder);  // No retry
HttpResult<Order> fetched = getAdapter.getBlocking();            // With retry
----

==== Option 4: Use Conditional Requests

For PUT/PATCH, use `If-Match` with ETags:

[source,java]
----
// Fetch current resource with ETag
HttpResult<User> current = adapter.getBlocking();
String etag = current.getETag().orElseThrow();

// Update with conditional header
Map<String, String> headers = Map.of(
    "If-Match", etag
);

HttpResult<User> updated = adapter.put(modifiedUser, headers);

// Retry fails with 412 Precondition Failed if resource changed
// Prevents lost update problem
----

=== Current Implementation Behavior

**As of Version 1.0:**

* `ResilientHttpAdapter` uses `HttpMethod` enum internally for type-safe method tracking
* Supports `idempotentOnly` configuration via `RetryConfig.builder().idempotentOnly(true)`
* When `idempotentOnly=false` (default), retries **ALL** HTTP methods
* When `idempotentOnly=true`, only retries idempotent methods (GET, PUT, DELETE, HEAD, OPTIONS)
* POST and PATCH are automatically skipped when `idempotentOnly=true`

**Recommendation:**

* ‚úÖ Use `ResilientHttpAdapter` with `idempotentOnly=true` for safe retry behavior
* ‚úÖ Use `idempotentOnly=false` (default) only when using idempotency keys or accepting retry risks
* ‚ö†Ô∏è Use with caution for PUT (idempotent by HTTP spec, but verify server behavior)
* üí° For POST/PATCH, either use idempotency keys OR configure `idempotentOnly=true`

=== Examples

==== Safe: Retry GET

[source,java]
----
// Safe - reads are idempotent
HttpAdapter<User> adapter = ResilientHttpAdapter.wrap(baseAdapter);
HttpResult<User> user = adapter.getBlocking();  // Retry on network failure
----

==== Safe: Retry PUT with Idempotency

[source,java]
----
// Safe - PUT is idempotent by HTTP spec
HttpAdapter<User> adapter = ResilientHttpAdapter.wrap(baseAdapter);
HttpResult<User> updated = adapter.putBlocking(user);  // Same result on retry
----

==== Unsafe: Retry POST without Protection

[source,java]
----
// UNSAFE - may create duplicates
HttpAdapter<Order> adapter = ResilientHttpAdapter.wrap(baseAdapter);
HttpResult<Order> order = adapter.postBlocking(newOrder);  // ‚ö†Ô∏è Risk of duplicates
----

==== Safe: POST with Idempotency Key

[source,java]
----
// Safe - idempotency key prevents duplicates
HttpAdapter<Order> adapter = ResilientHttpAdapter.wrap(baseAdapter);

String idempotencyKey = UUID.randomUUID().toString();
Map<String, String> headers = Map.of("Idempotency-Key", idempotencyKey);

HttpResult<Order> order = adapter.post(newOrder, headers);  // ‚úÖ Safe to retry
----

==== Safe: No Retry for POST

[source,java]
----
// Safe - no retry wrapper
HttpAdapter<Order> adapter = ETagAwareHttpAdapter.<Order>builder()
    .httpHandler(handler)
    .responseConverter(orderConverter)
    .build();

HttpResult<Order> order = adapter.postBlocking(newOrder);  // ‚úÖ No retry
----

=== Roadmap

**Completed in version 1.0:**

1. ‚úÖ Added `idempotentOnly` boolean to `RetryConfig`
2. ‚úÖ Added `HttpMethod` enum with `isIdempotent()` classification
3. ‚úÖ Skip retry for POST/PATCH when `idempotentOnly=true`
4. ‚úÖ Comprehensive idempotency documentation with mitigation strategies

**Planned for future versions:**

1. Metrics and observability hooks (retry count, success rate per method)
2. Circuit breaker pattern integration
3. Adaptive retry strategies based on response headers (Retry-After)
4. Per-method retry configuration override

See `06-implementation-plan.adoc` for detailed roadmap.

== ResilientHttpAdapter Implementation

[source,java]
----
package de.cuioss.http.client.adapter;

import de.cuioss.tools.logging.CuiLogger;

import java.time.Duration;
import java.util.Map;
import java.util.concurrent.*;
import java.util.function.Supplier;

import static java.util.Objects.requireNonNull;

/**
 * Wraps any HttpAdapter to add retry support with exponential backoff.
 * Retries transient failures (NETWORK_ERROR, SERVER_ERROR) up to configured attempts.
 * All operations are non-blocking using CompletableFuture.
 */
public class ResilientHttpAdapter<T> implements HttpAdapter<T> {
    private static final CuiLogger LOGGER = new CuiLogger(ResilientHttpAdapter.class);

    private final HttpAdapter<T> delegate;
    private final RetryConfig config;

    public ResilientHttpAdapter(HttpAdapter<T> delegate, RetryConfig config) {
        this.delegate = requireNonNull(delegate, "delegate");
        this.config = requireNonNull(config, "config");
    }

    /**
     * Wrap adapter with retry using default configuration.
     */
    public static <T> HttpAdapter<T> wrap(HttpAdapter<T> delegate) {
        return new ResilientHttpAdapter<>(delegate, RetryConfig.defaults());
    }

    /**
     * Wrap adapter with retry using custom configuration.
     */
    public static <T> HttpAdapter<T> wrap(HttpAdapter<T> delegate, RetryConfig config) {
        return new ResilientHttpAdapter<>(delegate, config);
    }

    @Override
    public CompletableFuture<HttpResult<T>> get(Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.get(additionalHeaders), HttpMethod.GET, 1);
    }

    @Override
    public CompletableFuture<HttpResult<T>> post(@Nullable T requestBody, Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.post(requestBody, additionalHeaders), HttpMethod.POST, 1);
    }

    @Override
    public CompletableFuture<HttpResult<T>> put(@Nullable T requestBody, Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.put(requestBody, additionalHeaders), HttpMethod.PUT, 1);
    }

    @Override
    public CompletableFuture<HttpResult<T>> patch(@Nullable T requestBody, Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.patch(requestBody, additionalHeaders), HttpMethod.PATCH, 1);
    }

    @Override
    public CompletableFuture<HttpResult<T>> delete(Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.delete(additionalHeaders), HttpMethod.DELETE, 1);
    }

    @Override
    public CompletableFuture<HttpResult<T>> delete(@Nullable T requestBody, Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.delete(requestBody, additionalHeaders), HttpMethod.DELETE, 1);
    }

    @Override
    public CompletableFuture<HttpResult<T>> head(Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.head(additionalHeaders), HttpMethod.HEAD, 1);
    }

    @Override
    public CompletableFuture<HttpResult<T>> options(Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.options(additionalHeaders), HttpMethod.OPTIONS, 1);
    }

    @Override
    public <R> CompletableFuture<HttpResult<T>> post(HttpRequestConverter<R> requestConverter,
                                                       @Nullable R requestBody,
                                                       Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.post(requestConverter, requestBody, additionalHeaders), HttpMethod.POST, 1);
    }

    @Override
    public <R> CompletableFuture<HttpResult<T>> put(HttpRequestConverter<R> requestConverter,
                                                      @Nullable R requestBody,
                                                      Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.put(requestConverter, requestBody, additionalHeaders), HttpMethod.PUT, 1);
    }

    @Override
    public <R> CompletableFuture<HttpResult<T>> patch(HttpRequestConverter<R> requestConverter,
                                                        @Nullable R requestBody,
                                                        Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.patch(requestConverter, requestBody, additionalHeaders), HttpMethod.PATCH, 1);
    }

    @Override
    public <R> CompletableFuture<HttpResult<T>> delete(HttpRequestConverter<R> requestConverter,
                                                         @Nullable R requestBody,
                                                         Map<String, String> additionalHeaders) {
        return executeWithRetry(() -> delegate.delete(requestConverter, requestBody, additionalHeaders), HttpMethod.DELETE, 1);
    }

    /**
     * Executes HTTP operation with retry support using non-blocking delays.
     * The delegate call is already async (returns CompletableFuture), so no
     * additional thread wrapping is needed.
     *
     * @param operation Supplier that returns CompletableFuture of the HTTP operation
     * @param method HTTP method for logging and idempotency checking
     * @param attempt Current attempt number (1-based)
     * @return CompletableFuture containing the result or recursive retry
     */
    private CompletableFuture<HttpResult<T>> executeWithRetry(
            Supplier<CompletableFuture<HttpResult<T>>> operation,
            HttpMethod method,
            int attempt) {

        LOGGER.debug("Attempt {}/{} for {} request", attempt, config.maxAttempts(), method.methodName());

        // Delegate is already async - no supplyAsync needed!
        return operation.get()
                .thenCompose(result -> {
                    // Success - return immediately
                    if (result.isSuccess()) {
                        if (attempt > 1) {
                            LOGGER.debug("{} request succeeded on attempt {}", method.methodName(), attempt);
                        }
                        return CompletableFuture.completedFuture(result);
                    }

                    // Idempotency check - skip retry for non-idempotent methods if configured
                    if (config.idempotentOnly() && !method.isIdempotent()) {
                        LOGGER.warn("Skipping retry for non-idempotent method: {} (idempotentOnly=true)",
                            method.methodName());
                        return CompletableFuture.completedFuture(result);
                    }

                    // Non-retryable failure - return immediately
                    if (!result.isRetryable()) {
                        LOGGER.debug("{} request failed with non-retryable error: {}",
                            method.methodName(), result.getErrorCategory().orElse(null));
                        return CompletableFuture.completedFuture(result);
                    }

                    // Max attempts reached
                    if (attempt >= config.maxAttempts()) {
                        LOGGER.warn("{} request failed after {} attempts", method.methodName(), config.maxAttempts());
                        return CompletableFuture.completedFuture(result);
                    }

                    // Retryable failure - calculate delay and schedule retry
                    Duration delay = config.calculateDelay(attempt);

                    LOGGER.warn("{} request failed on attempt {}, retrying after {}ms",
                        method.methodName(), attempt, delay.toMillis());

                    int nextAttempt = attempt + 1;

                    // Non-blocking delay using delayedExecutor
                    Executor delayedExecutor = CompletableFuture.delayedExecutor(
                        delay.toMillis(), TimeUnit.MILLISECONDS
                    );

                    // Schedule next attempt after delay - no nested futures
                    return CompletableFuture
                        .supplyAsync(() -> null, delayedExecutor)
                        .thenCompose(ignored -> executeWithRetry(operation, method, nextAttempt));
                });
    }
}
----

== Usage Examples

=== Default Configuration

[source,java]
----
HttpAdapter<User> baseAdapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .requestConverter(userConverter)
    .build();

// Wrap with retry using defaults (5 attempts, 1s initial, 2.0 multiplier, 1min max, 10% jitter)
HttpAdapter<User> resilientAdapter = ResilientHttpAdapter.wrap(baseAdapter);

// Async execution - all adapter methods return CompletableFuture
CompletableFuture<HttpResult<User>> futureResult = resilientAdapter.get();

// Handle result asynchronously (recommended)
futureResult.thenAccept(result -> {
    if (result.isSuccess()) {
        User user = result.getContent().orElseThrow();
        // Process user
    } else {
        LOGGER.error("Request failed: {}", result.getErrorMessage());
    }
});

// Or use blocking convenience method for simple cases
HttpResult<User> result = resilientAdapter.getBlocking();
----

=== Custom Configuration

[source,java]
----
// Custom retry configuration
RetryConfig customRetry = RetryConfig.builder()
    .maxAttempts(3)                        // Only 3 attempts
    .initialDelay(Duration.ofMillis(500))  // Start with 500ms
    .multiplier(1.5)                       // Slower backoff
    .maxDelay(Duration.ofSeconds(30))      // Cap at 30s
    .jitter(0.2)                           // 20% jitter
    .build();

HttpAdapter<User> resilientAdapter = ResilientHttpAdapter.wrap(baseAdapter, customRetry);

// Chain async operations
User newUser = User.builder().name("John").build();
resilientAdapter.post(newUser, headers)
    .thenApply(result -> result.getContent().orElse(null))
    .thenAccept(savedUser -> LOGGER.info("User saved: {}", savedUser))
    .exceptionally(ex -> {
        LOGGER.error("Async operation failed", ex);
        return null;
    });
----

=== Minimal Retry

[source,java]
----
// Just 2 quick attempts with minimal delay
RetryConfig minimal = RetryConfig.builder()
    .maxAttempts(2)
    .initialDelay(Duration.ofMillis(100))
    .build();

HttpAdapter<User> adapter = ResilientHttpAdapter.wrap(baseAdapter, minimal);

// Parallel async requests
CompletableFuture<HttpResult<User>> user1 = adapter.get(Map.of("X-User-Id", "1"));
CompletableFuture<HttpResult<User>> user2 = adapter.get(Map.of("X-User-Id", "2"));
CompletableFuture<HttpResult<User>> user3 = adapter.get(Map.of("X-User-Id", "3"));

// Wait for all to complete
CompletableFuture.allOf(user1, user2, user3)
    .thenRun(() -> LOGGER.info("All requests completed"));
----

=== Aggressive Retry

[source,java]
----
// More attempts, longer waits for critical operations
RetryConfig aggressive = RetryConfig.builder()
    .maxAttempts(10)
    .initialDelay(Duration.ofSeconds(2))
    .maxDelay(Duration.ofMinutes(5))
    .build();

HttpAdapter<CriticalData> adapter = ResilientHttpAdapter.wrap(baseAdapter, aggressive);

// Timeout on the entire retry cycle (not individual attempts)
CompletableFuture<HttpResult<CriticalData>> future = adapter.get();
CompletableFuture<HttpResult<CriticalData>> withTimeout =
    future.orTimeout(10, TimeUnit.MINUTES);

withTimeout.thenAccept(result -> {
    // Process result
});
----

== Retry Behavior

=== Retryable Errors

Retry happens for:

* `NETWORK_ERROR` - IOException, timeouts, connection failures
* `SERVER_ERROR` - HTTP 5xx responses (503, 502, 500, etc.)

=== Non-Retryable Errors

No retry for:

* `CLIENT_ERROR` - HTTP 4xx (bad request, auth failure, not found, etc.)
* `INVALID_CONTENT` - Response parsing failed
* `CONFIGURATION_ERROR` - SSL issues, invalid URI

*Note:* Most 3xx redirects are followed automatically by `HttpClient`. 304 Not Modified is handled as application success by `ETagAwareHttpAdapter`.

=== Exponential Backoff Example

With defaults (initial=1s, multiplier=2.0, jitter=10%):

[source]
----
Attempt 1: delegate.get() returns CompletableFuture
  ‚Üì CompletableFuture completes with failure (retryable)
Schedule retry: ~1000ms using delayedExecutor (1s * 2^0 * 1.05)
  ‚Üì Non-blocking delay

Attempt 2: delegate.get() returns CompletableFuture (after delay)
  ‚Üì CompletableFuture completes with failure (retryable)
Schedule retry: ~2100ms using delayedExecutor (1s * 2^1 * 1.05)
  ‚Üì Non-blocking delay

Attempt 3: delegate.get() returns CompletableFuture (after delay)
  ‚Üì CompletableFuture completes with failure (retryable)
Schedule retry: ~4200ms using delayedExecutor (1s * 2^2 * 1.05)
  ‚Üì Non-blocking delay

Attempt 4: delegate.get() returns CompletableFuture (after delay)
  ‚Üì CompletableFuture completes with failure (retryable)
Schedule retry: ~8400ms using delayedExecutor (1s * 2^3 * 1.05)
  ‚Üì Non-blocking delay

Attempt 5: delegate.get() returns CompletableFuture (after delay, final)
  ‚Üì CompletableFuture completes with result (success or failure)
----

**Key Points:**

* Zero blocking - delays use `CompletableFuture.delayedExecutor`
* No thread pools needed - CompletableFuture handles scheduling
* Delegate operations are already async (no supplyAsync wrapping)
* Jitter adds randomness (¬±10%) to prevent thundering herd
* Caller's thread returns immediately

== Async Execution Model

=== Non-Blocking Delays

[source,java]
----
// Delays use CompletableFuture.delayedExecutor (no threads blocked)
CompletableFuture.delayedExecutor(
    delay.toMillis(),
    TimeUnit.MILLISECONDS
)

// Chain next attempt after delay completes
CompletableFuture
    .supplyAsync(() -> null, delayedExecutor)
    .thenCompose(ignored -> executeWithRetry(operation, methodName, nextAttempt))
----

**Benefits:**

* Zero threads blocked during delays
* Millions of concurrent retry operations possible
* Minimal memory overhead per request
* Natural backpressure handling
* No thread pool management needed

=== CompletableFuture Chaining

[source,java]
----
// Pattern: attempt ‚Üí evaluate ‚Üí retry or complete (no blocking!)
return operation.get()  // Already returns CompletableFuture
    .thenCompose(result -> {
        if (shouldRetry(result)) {
            // Schedule next attempt after non-blocking delay
            return CompletableFuture
                .supplyAsync(() -> null, delayedExecutor)
                .thenCompose(ignored -> executeWithRetry(operation, methodName, nextAttempt));
        }
        return CompletableFuture.completedFuture(result);
    });
----

**Advantages:**

* Non-blocking throughout entire retry cycle
* No fake async (supplyAsync wrapping of sync calls)
* Compositional - can chain with other async operations
* Timeout-friendly - use `orTimeout()` or `completeOnTimeout()`
* Exception-safe - use `exceptionally()` or `handle()`
* Tail-recursive via `thenCompose()` - no stack overflow

== Thread Safety

* `ResilientHttpAdapter` is thread-safe
* All fields are final and immutable
* Each request gets independent async execution chain
* No shared state between requests
* No thread pool management - uses CompletableFuture's internal scheduling

== Composition

=== With ETag Caching

[source,java]
----
HttpAdapter<User> adapter = ResilientHttpAdapter.wrap(
    ETagAwareHttpAdapter.<User>builder()
        .httpHandler(handler)
        .responseConverter(userConverter)
    .requestConverter(userConverter)
        .build(),
    RetryConfig.defaults()
);

// Async execution with retry + caching
CompletableFuture<HttpResult<User>> future = adapter.get(headers);
----

=== Multiple Async Operations

[source,java]
----
// Execute multiple operations in parallel
List<String> userIds = List.of("123", "456", "789");
List<CompletableFuture<HttpResult<User>>> futures = userIds.stream()
    .map(id -> resilientAdapter.get(Map.of("X-User-Id", id)))
    .toList();

// Wait for all and collect results
CompletableFuture<List<HttpResult<User>>> allResults =
    CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
        .thenApply(v -> futures.stream()
            .map(CompletableFuture::join)
            .toList());
----

== Benefits of Async Approach

[cols="1,2"]
|===
|Benefit |Description

|**Non-blocking**
|Caller thread never blocks during retries - uses CompletableFuture

|**Scalable**
|Non-blocking CompletableFuture enables millions of concurrent retry operations

|**Compositional**
|Can chain with other async operations using `thenCompose()`, `thenApply()`, etc.

|**Timeout-friendly**
|Easy to add timeouts with `orTimeout()` or `completeOnTimeout()`

|**Resource-efficient**
|No thread blocking during delays - uses scheduled executor

|**Modern Java**
|Leverages CompletableFuture async patterns and non-blocking I/O

|**Testable**
|Easy to test with `CompletableFuture` test utilities
|===

== Testing Requirements

* ‚úÖ Default configuration values
* ‚úÖ Custom configuration via builder
* ‚úÖ Retry on NETWORK_ERROR (async)
* ‚úÖ Retry on SERVER_ERROR (async)
* ‚úÖ No retry on CLIENT_ERROR
* ‚úÖ Max attempts respected
* ‚úÖ Exponential backoff delay calculation (via RetryConfig.calculateDelay)
* ‚úÖ Jitter applied correctly (via RetryConfig.calculateDelay)
* ‚úÖ maxDelay cap enforced (via RetryConfig.calculateDelay)
* ‚úÖ CompletableFuture composition
* ‚úÖ Non-blocking delays using delayedExecutor
* ‚úÖ No blocking cascade - delegate already async
* ‚úÖ Success on first attempt (immediate future completion)
* ‚úÖ Success on retry attempt (after async delay)
* ‚úÖ Failure after max attempts
* ‚úÖ Async timeout handling (orTimeout)
* ‚úÖ Parallel execution of multiple requests
* ‚úÖ Composition with ETagAwareHttpAdapter

== Design Decisions

[cols="1,2,2"]
|===
|Decision |Choice |Rationale

|Architecture
|Async decorator with RetryConfig
|Non-blocking, simple configuration object pattern

|Return type
|CompletableFuture<HttpResult<T>>
|Enables non-blocking, compositional async operations

|Execution model
|CompletableFuture with non-blocking delays
|True async, zero blocked threads, millions of concurrent operations

|Delay mechanism
|CompletableFuture.delayedExecutor
|Non-blocking delays, no Thread.sleep, integrates with CompletableFuture

|Retry algorithm
|Exponential backoff only
|Industry best practice, covers 99% of cases

|Delay calculation
|RetryConfig.calculateDelay method
|Configuration record with behavior, keeps logic with config

|Jitter
|Configurable (default 10%)
|Prevents thundering herd

|Thread safety
|Immutable config, stateless adapter
|Safe for concurrent use, each request independent

|Recursion
|Tail-recursive via thenCompose
|Clean async retry chain, no stack overflow risk

|Logging
|WARN for retries, ERROR for exhaustion
|Appropriate visibility for operations team
|===
