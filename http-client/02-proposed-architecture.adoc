= Proposed Architecture
:toc: left
:toc-title: Table of Contents
:toclevels: 3
:sectnums:
:source-highlighter: highlight.js

== Component Layers

[source]
----
Client Code
    ↓
HttpAdapter.{get()|post()|put()|...}
    ↓
ResilientHttpAdapter (optional retry)
    ↓
ETagAwareHttpAdapter (base + built-in ETag caching)
    ↓
HttpHandler (SSL, timeouts, configuration)
    ↓
java.net.http.HttpClient
----

**Key characteristics:**
* Single `ETagAwareHttpAdapter` with built-in ETag caching (configurable)
* Method-specific API (`adapter.get()`, `adapter.post()`, etc.)
* Separate `HttpResponseConverter<T>` and `HttpRequestConverter<R>` interfaces for request and response conversion

== HttpAdapter<T> Interface

[source,java]
----
public interface HttpAdapter<T> {
    // No-body methods (async)
    CompletableFuture<HttpResult<T>> get(Map<String, String> additionalHeaders);
    CompletableFuture<HttpResult<T>> delete(Map<String, String> additionalHeaders);
    // ... head(), options()

    // Body methods (T → T, same type for request and response)
    CompletableFuture<HttpResult<T>> post(@Nullable T requestBody, Map<String, String> additionalHeaders);
    CompletableFuture<HttpResult<T>> put(@Nullable T requestBody, Map<String, String> additionalHeaders);
    // ... patch(), delete(T, Map)

    // Body methods (R → T, different request type)
    <R> CompletableFuture<HttpResult<T>> post(HttpRequestConverter<R> requestConverter,
                           @Nullable R requestBody,
                           Map<String, String> additionalHeaders);
    // ... put(R), patch(R)

    // Blocking convenience methods
    default HttpResult<T> getBlocking(Map<String, String> additionalHeaders) {
        return get(additionalHeaders).join();
    }
    // ... similar for other methods
}
----

**Purpose:** Enable composition and extensions with method-specific type-safe async APIs

**Design:** Async-first with blocking convenience methods for simple cases

See link:03-core-components.adoc#_httpadapter_interface[Full Specification]

== Component Responsibilities

=== ETagAwareHttpAdapter

**Role:** Base adapter with built-in ETag caching

* Execute HTTP requests via HttpHandler
* Convert responses via HttpResponseConverter
* Preserve HTTP metadata (ETag, status)
* Built-in ETag caching (enabled by default, disable via `etagCachingEnabled(false)`)
* Cache only GET requests
* Thread-safe (ConcurrentHashMap)

See link:04-etag-aware-adapter.adoc[Complete Specification]

=== ResilientHttpAdapter

**Role:** Retry decorator

* Wrap any HttpAdapter<T>
* Retry on NETWORK_ERROR and SERVER_ERROR
* Use RetryConfig for backoff/jitter
* Async execution with CompletableFuture (virtual threads)

See link:05-resilient-adapter.adoc[Complete Specification]

=== HttpHandler

**Role:** Low-level HTTP client configuration

* SSL/TLS context management
* Timeout configuration
* URI management
* HttpClient creation

== Data Flows

=== GET with ETag Caching

[source]
----
1. Client: adapter.get()

2. ResilientHttpAdapter (if used):
   → Delegate to ETagAwareHttpAdapter

3. ETagAwareHttpAdapter:
   → Check cache for ETag
   → Build request with If-None-Match: "etag" (if cached)
   → Send via HttpHandler

4. Server: 304 Not Modified

5. ETagAwareHttpAdapter:
   → Detect 304
   → Return Success(cachedContent, etag, 304)

6. ResilientHttpAdapter:
   → Success, no retry

7. Client: Success(cachedContent, etag, 304)
----

=== POST with Retry

[source]
----
1. Client: adapter.post(userObject)

2. ResilientHttpAdapter:
   → Delegate to ETagAwareHttpAdapter

3. ETagAwareHttpAdapter:
   → POST: no ETag caching
   → Convert body via requestConverter.toBodyPublisher(userObject)
   → Build request with body
   → Send via HttpHandler

4. Network fails (IOException)

5. ETagAwareHttpAdapter:
   → Return Failure(NETWORK_ERROR, ...)

6. ResilientHttpAdapter:
   → NETWORK_ERROR is retryable
   → Wait (exponential backoff)
   → Retry (attempt 2)

7. Attempt 2 succeeds:
   → Return Success(content, etag, 201)
----

=== 304 Not Modified (Structural Correctness)

**Critical:** 304 handled as success through structural guarantees.

* Cache entry retrieved at request start, reference held throughout
* If cached: add `If-None-Match` header
* 304 response uses cached content: `HttpResult.success(cachedContent, etag, 304)`
* Thread-safe: local reference immune to concurrent cache modifications
* Status 304 preserved for metrics/logging

See link:04-etag-aware-adapter.adoc#_304_not_modified_handling[Implementation Details]

== Type System

See link:03-core-components.adoc[Core Components] for complete specifications.

=== HttpAdapter<T> Interface

Method-specific interface for HTTP operations (`get()`, `post()`, `put()`, `delete()`, `patch()`, `head()`, `options()`).

=== HttpResponseConverter<T>

Handles response deserialization (HTTP → T). Implementations define how to convert HTTP response bodies to domain objects.

=== HttpRequestConverter<R>

Handles request serialization (R → HTTP). Implementations define how to convert domain objects to HTTP request bodies.

=== ContentType Enum

Type-safe MIME types (APPLICATION_JSON, TEXT_PLAIN, etc.) with charset support.

=== CacheKeyHeaderFilter Interface

Fine-grained control over which headers are included in ETag cache keys using functional predicates. Preset filters (`ALL`, `NONE`) or custom logic (`excluding()`, `including()`, `matching()`).

=== HttpErrorCategory

[source,java]
----
public enum HttpErrorCategory {
    NETWORK_ERROR,      // IOException - RETRYABLE
    SERVER_ERROR,       // 5xx - RETRYABLE
    CLIENT_ERROR,       // 4xx - NOT retryable
    INVALID_CONTENT,    // Parsing failed - NOT retryable
    CONFIGURATION_ERROR; // SSL, URI - NOT retryable

    public boolean isRetryable() {
        return this == NETWORK_ERROR || this == SERVER_ERROR;
    }
}
----

**Note:** Most 3xx redirects followed automatically by HttpClient. 304 handled specially by ETagAwareHttpAdapter as success.

== Configuration Examples

=== Basic GET (ETag Enabled)

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .requestConverter(userConverter)
    .build();  // ETag ON by default

// Async execution
CompletableFuture<HttpResult<User>> futureResult = adapter.get();

// Or blocking for simple cases
HttpResult<User> result = adapter.getBlocking();
----

=== Disable ETag

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .requestConverter(userConverter)
    .etagCachingEnabled(false)
    .build();
----

=== Single-User Client (URI-Only Cache Keys)

[source,java]
----
// Mobile app, desktop app, or service account
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .requestConverter(userConverter)
    .cacheKeyHeaderFilter(CacheKeyHeaderFilter.NONE)  // URI only, ignore all headers
    .build();
// Token refresh doesn't create duplicate cache entries
----

=== POST with Retry

[source,java]
----
HttpAdapter<User> baseAdapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .requestConverter(userConverter)
    .build();

HttpAdapter<User> resilientAdapter = ResilientHttpAdapter.wrap(baseAdapter);

User newUser = User.builder().name("John").build();

// Async execution with retry
CompletableFuture<HttpResult<User>> futureResult = resilientAdapter.post(newUser);

// Or blocking
HttpResult<User> result = resilientAdapter.postBlocking(newUser);
----
