= HTTP Client Extension Documentation
:toc: left
:toclevels: 2
:sectnums:

== Navigation

=== Implementers Path

. link:01-current-architecture.adoc[Current Architecture] - Existing code analysis
. link:02-proposed-architecture.adoc[Architecture] - Design patterns and layers
. link:03-core-components.adoc[Components] - Interface specifications
. link:04-etag-aware-adapter.adoc[ETag Adapter] - Base adapter with caching
. link:05-resilient-adapter.adoc[Resilient Adapter] - Retry logic
. link:06-implementation-plan.adoc[Implementation Plan] - Phases and steps

=== Users Path

. link:07-usage-examples.adoc[Usage Examples] - 24 complete examples
. link:08-migration-guide.adoc[Migration Guide] - Pre-1.0 to 1.0
. link:09-security-considerations.adoc[Security] - Best practices

== Architecture

[source]
----
Client Code
    ↓
HttpAdapter.{get()|post()|put()|delete()|...}
    ↓
ResilientHttpAdapter (optional retry)
    ↓
ETagAwareHttpAdapter (base + ETag caching)
    ↓
HttpHandler (SSL, timeouts)
    ↓
java.net.http.HttpClient
----

== Key Decisions

[cols="1,2"]
|===
|Decision |Choice

|HTTP Methods |Method-specific API (`adapter.get()`, `adapter.post()`, etc.)
|ETag Caching |Built into `ETagAwareHttpAdapter` (default enabled, configurable)
|Retry Logic |`ResilientHttpAdapter` with `RetryConfig` record
|Content Conversion |Bidirectional `HttpContentConverter<T>` (request + response)
|Content Types |`ContentType` enum
|===

== Quick Examples

=== GET Request

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .build();

HttpResult<User> result = adapter.get();
----

=== POST with JSON

[source,java]
----
User newUser = User.builder().name("John").email("john@example.com").build();
HttpResult<User> result = adapter.post(newUser);
----

=== With Retry

[source,java]
----
HttpAdapter<User> resilient = ResilientHttpAdapter.wrap(baseAdapter);

// Async execution - returns CompletableFuture
CompletableFuture<HttpResult<User>> future = resilient.get();

// Handle asynchronously
future.thenAccept(result -> {
    if (result.isSuccess()) {
        processUser(result.getValue().orElseThrow());
    }
});
----

=== Single-User Client (No Token Bloat)

[source,java]
----
// Mobile app, desktop app, or service account
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .cacheKeyHeaders(CacheKeyHeaders.NONE)  // URI only, ignore Authorization
    .build();
// Token refresh doesn't create duplicate cache entries
----

== Adapter Composition Order

Order matters when composing multiple adapters:

[cols="2,2,2"]
|===
|Pattern |Behavior |Use When

|`Retry(Auth(Base))`
|Retries entire operation including auth
|Auth failures are transient

|`Auth(Retry(Base))`
|Retries requests, reuses auth
|Auth is stable

|`Base → Retry → Auth`
|Standard composition
|Recommended default
|===

Example trade-offs:

[source,java]
----
// Option 1: Retry includes auth
// Pro: Handles auth token race conditions
// Con: More token refresh calls
HttpAdapter<User> option1 = ResilientHttpAdapter.wrap(
    new BearerTokenAdapter<>(baseAdapter, tokenSupplier)
);

// Option 2: Auth wraps retry
// Pro: Fewer token refresh calls
// Con: Auth failures not retried
HttpAdapter<User> option2 = new BearerTokenAdapter<>(
    ResilientHttpAdapter.wrap(baseAdapter),
    tokenSupplier
);

// Both return CompletableFuture for async execution
CompletableFuture<HttpResult<User>> future1 = option1.get();
CompletableFuture<HttpResult<User>> future2 = option2.get();
----

**Rule:** Place stable concerns outside, variable concerns inside retry loop.

== 304 Not Modified Handling

The adapter uses structural correctness: cache entry retrieved at request start, reference held throughout. This guarantees:

* 304 response returns `Success` with cached content
* Thread-safe: local reference immune to concurrent cache modifications
* No defensive null checks needed

See link:04-etag-aware-adapter.adoc#_304_not_modified_handling[304 Implementation]

== Breaking Changes

**Deleted:**

* `ResilientHttpHandler` → Use `ETagAwareHttpAdapter` + `ResilientHttpAdapter`
* `RetryStrategy` interface → Use `RetryConfig` record
* `HttpContentConverter.emptyValue()` → Use `contentType()`
* `HttpRequestBodyPublisher<T>` → Use bidirectional `HttpContentConverter<T>`

**Modified:**

* `HttpAdapter<T>` → Method-specific interface (`get()`, `post()`, `put()`, etc.)
* `HttpContentConverter<T>` → Bidirectional (added `toBodyPublisher()`)
* `HttpContentConverter.expectedContentType()` → Renamed to `contentType()`

**New:**

* `ContentType` enum
* `RetryConfig` record
* `CacheKeyHeaders` enum

**Internal-Only (not exported):**

* `HttpMethod` enum (package-private)

See link:08-migration-guide.adoc[Complete Migration Guide]

== Documents

[cols="1,2"]
|===
|Document |Content

|README |This file - navigation and quick reference
|01-current-architecture |Analysis of existing components
|02-proposed-architecture |Design patterns and data flows
|03-core-components |Interface specifications
|04-etag-aware-adapter |Base adapter implementation
|05-resilient-adapter |Retry implementation
|06-implementation-plan |Implementation phases
|07-usage-examples |Code examples
|08-migration-guide |Breaking changes and migration
|09-security-considerations |Security best practices
|===
