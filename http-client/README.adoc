= HTTP Client Extension Documentation
:toc: left
:toclevels: 2
:sectnums:

== Navigation

=== Architecture & Design

. link:02-proposed-architecture.adoc[Architecture] - Design patterns and layers
. link:03-core-components.adoc[Components] - Interface specifications
. link:04-etag-aware-adapter.adoc[ETag Adapter] - Base adapter with caching
. link:05-resilient-adapter.adoc[Resilient Adapter] - Retry logic with async

=== Usage & Examples

. link:07-usage-examples.adoc[Usage Examples] - 24 complete examples
. link:09-security-considerations.adoc[Security] - Best practices

== Architecture

[source]
----
Client Code
    ↓
HttpAdapter.{get()|post()|put()|delete()|...}
    ↓
ResilientHttpAdapter (optional retry)
    ↓
ETagAwareHttpAdapter (base + ETag caching)
    ↓
HttpHandler (SSL, timeouts)
    ↓
java.net.http.HttpClient
----

== Key Decisions

[cols="1,2"]
|===
|Decision |Choice

|HTTP Methods |Method-specific API (`adapter.get()`, `adapter.post()`, etc.)
|ETag Caching |Built into `ETagAwareHttpAdapter` (default enabled, configurable)
|Retry Logic |`ResilientHttpAdapter` with `RetryConfig` record - async with CompletableFuture
|Content Conversion |Separate `HttpResponseConverter<T>` and `HttpRequestConverter<R>` interfaces
|Content Types |`ContentType` enum
|Async First |All operations return `CompletableFuture<HttpResult<T>>` with blocking convenience methods
|===

== Quick Examples

=== GET Request (Async)

[source,java]
----
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .build();

// Async execution
CompletableFuture<HttpResult<User>> futureResult = adapter.get();

// Handle asynchronously (recommended)
futureResult.thenAccept(result -> {
    if (result.isSuccess()) {
        processUser(result.getValue().orElseThrow());
    }
});

// Or blocking for simple cases
HttpResult<User> result = adapter.getBlocking();
----

=== POST with JSON

[source,java]
----
User newUser = User.builder().name("John").email("john@example.com").build();

// Async
CompletableFuture<HttpResult<User>> futureResult = adapter.post(newUser);

// Or blocking
HttpResult<User> result = adapter.postBlocking(newUser);
----

=== With Retry

[source,java]
----
HttpAdapter<User> resilient = ResilientHttpAdapter.wrap(baseAdapter);

// Async execution with retry - returns CompletableFuture
CompletableFuture<HttpResult<User>> future = resilient.get();

// Handle asynchronously (recommended)
future.thenAccept(result -> {
    if (result.isSuccess()) {
        processUser(result.getValue().orElseThrow());
    }
});

// Or blocking
HttpResult<User> result = resilient.getBlocking();
----

=== Single-User Client (No Token Bloat)

[source,java]
----
// Mobile app, desktop app, or service account
HttpAdapter<User> adapter = ETagAwareHttpAdapter.<User>builder()
    .httpHandler(handler)
    .responseConverter(userConverter)
    .cacheKeyHeaders(CacheKeyHeaders.NONE)  // URI only, ignore Authorization
    .build();
// Token refresh doesn't create duplicate cache entries
----

== Adapter Composition Order

Order matters when composing multiple adapters:

[cols="2,2,2"]
|===
|Pattern |Behavior |Use When

|`Retry(Auth(Base))`
|Retries entire operation including auth
|Auth failures are transient

|`Auth(Retry(Base))`
|Retries requests, reuses auth
|Auth is stable

|`Base → Retry → Auth`
|Standard composition
|Recommended default
|===

Example trade-offs:

[source,java]
----
// Option 1: Retry includes auth
// Pro: Handles auth token race conditions
// Con: More token refresh calls
HttpAdapter<User> option1 = ResilientHttpAdapter.wrap(
    new BearerTokenAdapter<>(baseAdapter, tokenSupplier)
);

// Option 2: Auth wraps retry
// Pro: Fewer token refresh calls
// Con: Auth failures not retried
HttpAdapter<User> option2 = new BearerTokenAdapter<>(
    ResilientHttpAdapter.wrap(baseAdapter),
    tokenSupplier
);

// Both return CompletableFuture for async execution
CompletableFuture<HttpResult<User>> future1 = option1.get();
CompletableFuture<HttpResult<User>> future2 = option2.get();

// Or use blocking methods
HttpResult<User> result1 = option1.getBlocking();
HttpResult<User> result2 = option2.getBlocking();
----

**Rule:** Place stable concerns outside, variable concerns inside retry loop.

== 304 Not Modified Handling

The adapter uses structural correctness: cache entry retrieved at request start, reference held throughout. This guarantees:

* 304 response returns `Success` with cached content
* Thread-safe: local reference immune to concurrent cache modifications
* No defensive null checks needed

See link:04-etag-aware-adapter.adoc#_304_not_modified_handling[304 Implementation]

== Documents

[cols="1,2"]
|===
|Document |Content

|README |This file - navigation and quick reference
|02-proposed-architecture |Design patterns and data flows
|03-core-components |Interface specifications
|04-etag-aware-adapter |Base adapter implementation
|05-resilient-adapter |Retry implementation
|07-usage-examples |Code examples
|09-security-considerations |Security best practices
|===
