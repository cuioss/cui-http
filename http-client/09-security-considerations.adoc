= Security Considerations
:toc: left
:toclevels: 3
:sectnums:

== Overview

This document outlines security considerations when using the HTTP client extension, with emphasis on integrating the existing security validation pipelines.

== Request Body Validation

=== Risk

POST/PUT/DELETE requests send data that could contain:

* SQL injection payloads
* XSS scripts
* Path traversal sequences
* Malicious Unicode
* Overlong encodings

=== Mitigation

Use `URLParameterValidationPipeline` to validate request bodies before sending:

[source,java]
----
import de.cuioss.http.security.pipeline.URLParameterValidationPipeline;
import de.cuioss.http.security.UrlSecurityException;

// Create validator
URLParameterValidationPipeline validator = new URLParameterValidationPipeline();

// Validate JSON body before POST
String jsonBody = buildUserJson(user);

try {
    Optional<String> validatedJson = validator.validate(jsonBody);
    if (validatedJson.isEmpty()) {
        throw new UrlSecurityException("Request body contains invalid content");
    }

    // Send validated content
    HttpResult<User> result = HttpMethod.POST.send(
        adapter,
        HttpRequestBodyPublisher.json(),
        validatedJson.get()
    );
} catch (UrlSecurityException e) {
    LOGGER.error("Security validation failed: {}", e.getMessage());
    // Handle security violation
}
----

=== Best Practices

* ✅ Validate ALL user-provided request bodies
* ✅ Use appropriate pipeline (URLParameterValidationPipeline, HTTPHeaderValidationPipeline)
* ✅ Fail-secure: reject on validation failure
* ✅ Log security violations for monitoring
* ❌ Never bypass validation for "trusted" inputs
* ❌ Never disable validation in production

== Custom Header Validation

=== Risk

`additionalHeaders` parameter could be exploited for:

* Header injection attacks
* CRLF injection
* HTTP request smuggling
* Authentication bypass

=== Mitigation

Use `HTTPHeaderValidationPipeline` to validate custom headers:

[source,java]
----
import de.cuioss.http.security.pipeline.HTTPHeaderValidationPipeline;

HTTPHeaderValidationPipeline headerValidator = new HTTPHeaderValidationPipeline();

Map<String, String> headers = new HashMap<>();
headers.put("Authorization", "Bearer " + token);
headers.put("X-Custom-Header", userProvidedValue);

// Validate each header value
for (Map.Entry<String, String> entry : headers.entrySet()) {
    try {
        Optional<String> validated = headerValidator.validate(entry.getValue());
        if (validated.isEmpty()) {
            throw new UrlSecurityException("Invalid header value: " + entry.getKey());
        }
    } catch (UrlSecurityException e) {
        LOGGER.error("Header validation failed for {}: {}",
            entry.getKey(), e.getMessage());
        throw e;
    }
}

// Send request with validated headers
HttpResult<User> result = HttpMethod.GET.send(adapter, headers);
----

=== Headers to Validate

Always validate user-provided values for:

* `Authorization`
* `X-Request-ID`
* `X-Correlation-ID`
* Any custom headers from user input

Never validate (framework-controlled):

* `Content-Type` (set by HttpRequestBodyPublisher)
* `If-None-Match` (set by ETag caching)
* `User-Agent` (set by HttpClient)

== Content-Type Validation

=== Risk

Server returns different Content-Type than expected:

* May indicate server compromise
* Could be attempt to bypass parsing
* May lead to XSS if HTML returned instead of JSON

=== Mitigation

Define expected Content-Type in your converter:

[source,java]
----
public class UserConverter extends StringContentConverter<User> {
    @Override
    protected Optional<User> convertString(String rawContent) {
        return Optional.ofNullable(parseJson(rawContent));
    }

    @Override
    public ContentType expectedContentType() {
        return ContentType.APPLICATION_JSON;  // Define expected type
    }
}
----

If the converter returns `Optional.empty()` due to parsing failure, the result will have `HttpErrorCategory.INVALID_CONTENT`.

=== Best Practices

* ✅ Define expected Content-Type in converter
* ✅ Log warnings when conversion fails
* ✅ Check for INVALID_CONTENT error category
* ❌ Don't silently accept unexpected Content-Types

== SSL/TLS Configuration

=== Risk

Insecure SSL/TLS configuration:

* Man-in-the-middle attacks
* Certificate validation bypass
* Weak cipher suites

=== Mitigation

Use `SecureSSLContextProvider` with secure defaults:

[source,java]
----
HttpHandler handler = HttpHandler.builder()
    .uri("https://api.example.com/users")  // HTTPS, not HTTP
    .sslContextProvider(SecureSSLContextProvider.builder()
        .trustAllCertificates(false)  // ✅ Verify certificates
        .build())
    .build();
----

=== Best Practices

* ✅ Always use HTTPS for sensitive data
* ✅ Verify certificates (don't trust all)
* ✅ Use system trust store
* ✅ Keep Java runtime updated for latest cipher suites
* ❌ Never disable certificate validation in production
* ❌ Never trust all certificates

== Request Body Size Limits

=== Risk

Large request bodies could cause:

* Memory exhaustion
* Denial of service
* Slow performance

=== Mitigation

Validate body size before sending:

[source,java]
----
private static final int MAX_REQUEST_BODY_SIZE = 10 * 1024 * 1024; // 10 MB

public <R> HttpResult<T> send(HttpMethod method,
                               HttpRequestBodyPublisher<R> bodyPublisher,
                               @Nullable R requestBody,
                               Map<String, String> additionalHeaders) {

    // Validate body size
    if (requestBody instanceof String str && str.length() > MAX_REQUEST_BODY_SIZE) {
        return new HttpResult.Failure<>(
            "Request body exceeds maximum size",
            null,  // no exception
            null   // no HTTP status (validation failed before request)
        );
        // category() will return INVALID_CONTENT (default)
    }

    if (requestBody instanceof byte[] bytes && bytes.length > MAX_REQUEST_BODY_SIZE) {
        return new HttpResult.Failure<>(
            "Request body exceeds maximum size",
            null,  // no exception
            null   // no HTTP status (validation failed before request)
        );
        // category() will return INVALID_CONTENT (default)
    }

    return sendDirect(method, bodyPublisher, requestBody, additionalHeaders);
}
----

== Sensitive Data in ETag Cache

=== Risk

ETag cache stores response data in memory:

* Could cache PII (personally identifiable information)
* Could cache credentials or tokens
* Could leak via side-channel attacks

=== Mitigation

Disable ETag caching for sensitive endpoints:

[source,java]
----
// For sensitive data endpoints
HttpAdapter<SensitiveData> adapter = ETagAwareHttpAdapter.<SensitiveData>builder()
    .httpHandler(handler)
    .responseConverter(converter)
    .etagCachingEnabled(false)  // Disable for sensitive data
    .build();
----

=== Best Practices

* ✅ Disable ETag caching for PII
* ✅ Disable for authentication tokens
* ✅ Respect Cache-Control: no-store
* ✅ Clear cache on logout/session end
* ❌ Don't cache sensitive financial data
* ❌ Don't cache credentials

== URL Validation

=== Risk

URLs constructed from user input could contain:

* Directory traversal (../)
* Protocol confusion (javascript:, data:)
* CVE-specific exploits

=== Mitigation

Use `URLPathValidationPipeline` for URL validation:

[source,java]
----
import de.cuioss.http.security.pipeline.URLPathValidationPipeline;

URLPathValidationPipeline urlValidator = new URLPathValidationPipeline();

// Validate user-provided path before constructing URL
String userPath = getUserInput();

try {
    Optional<String> validatedPath = urlValidator.validate(userPath);
    if (validatedPath.isEmpty()) {
        throw new UrlSecurityException("Invalid URL path");
    }

    String safeUrl = "https://api.example.com/" + validatedPath.get();

    HttpHandler handler = HttpHandler.builder()
        .uri(safeUrl)
        .build();
} catch (UrlSecurityException e) {
    LOGGER.error("URL validation failed: {}", e.getMessage());
    throw e;
}
----

=== Best Practices

* ✅ Validate ALL user-provided URL components
* ✅ Use allowlist for paths when possible
* ✅ Validate query parameters separately
* ❌ Never concatenate raw user input into URLs

== Timeout Configuration

=== Risk

Missing timeouts could lead to:

* Resource exhaustion
* Thread starvation
* Denial of service

=== Mitigation

Always configure timeouts:

[source,java]
----
HttpHandler handler = HttpHandler.builder()
    .uri("https://api.example.com")
    .connectionTimeoutSeconds(5)   // ✅ Connection timeout
    .readTimeoutSeconds(10)         // ✅ Read timeout
    .build();
----

=== Best Practices

* ✅ Set connection timeout (5-10s typical)
* ✅ Set read timeout (10-30s typical)
* ✅ Adjust based on expected response time
* ✅ Monitor timeout metrics
* ❌ Never use infinite timeouts

== Retry Strategy Security

=== Risk

Aggressive retry could:

* Amplify attacks (retry bomb)
* Leak information via timing
* Exhaust resources

=== Mitigation

Use reasonable retry configuration:

[source,java]
----
RetryConfig safeRetry = RetryConfig.builder()
    .maxAttempts(3)                    // ✅ Limited attempts
    .initialDelay(Duration.ofSeconds(1))
    .maxDelay(Duration.ofMinutes(1))   // ✅ Cap max delay
    .jitter(0.1)                       // ✅ Add jitter
    .build();
----

=== Best Practices

* ✅ Limit max retry attempts (3-5)
* ✅ Use exponential backoff
* ✅ Add jitter to prevent thundering herd
* ✅ Don't retry authentication failures (4xx)
* ❌ Don't retry indefinitely
* ❌ Don't retry too aggressively

== Logging Security

=== Risk

Logging could expose:

* PII or sensitive data
* Authentication tokens
* Stack traces with internal details

=== Mitigation

Sanitize logs:

[source,java]
----
// ❌ BAD - Logs full request body
LOGGER.debug("Sending request: {}", requestBody);

// ✅ GOOD - Logs only metadata
LOGGER.debug("Sending {} request to {}, body size: {}",
    method, uri, bodySize);

// ✅ GOOD - Sanitize headers
Map<String, String> sanitizedHeaders = new HashMap<>(headers);
sanitizedHeaders.computeIfPresent("Authorization",
    (k, v) -> "Bearer [REDACTED]");
LOGGER.debug("Request headers: {}", sanitizedHeaders);
----

=== Best Practices

* ✅ Redact Authorization headers
* ✅ Redact API keys and tokens
* ✅ Redact PII (emails, names, etc.)
* ✅ Log at appropriate levels (DEBUG for details)
* ❌ Never log full request/response bodies in production
* ❌ Never log credentials

== Security Checklist

Before deploying to production:

* [ ] All request bodies validated
* [ ] All custom headers validated
* [ ] HTTPS with certificate verification
* [ ] Timeouts configured
* [ ] Request size limits enforced
* [ ] ETag caching disabled for sensitive data
* [ ] Retry strategy configured reasonably
* [ ] Logging sanitized (no PII/credentials)
* [ ] Security tests passing
* [ ] Pre-commit checks passing

== References

* CUI Security Validation: `doc/http-security/specification/`
* Pipeline Architecture: `doc/http-security/specification/pipeline-architecture-standards.adoc`
* OWASP Top 10: https://owasp.org/www-project-top-ten/
* Java Security Guidelines: https://www.oracle.com/java/technologies/javase/seccodeguide.html
